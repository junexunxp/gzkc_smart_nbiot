###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         26/Jun/2019  16:21:13
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  C:\Development\gzkc_smart_nbiot\csdk\eng\atm\at_parser.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\2\EWEB73.tmp
#        (C:\Development\gzkc_smart_nbiot\csdk\eng\atm\at_parser.c -D DEBUG -D
#        USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1 -D
#        CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list -lA
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list --diag_suppress
#        Pa082,Pa050 -o C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\gzkc_smart_nbiot/source\app_preinclude.h -I
#        C:\Development\gzkc_smart_nbiot/board\ -I
#        C:\Development\gzkc_smart_nbiot/source\ -I
#        C:\Development\gzkc_smart_nbiot/CMSIS\ -I
#        C:\Development\gzkc_smart_nbiot/amazon-freertos/freertos/portable\ -I
#        C:\Development\gzkc_smart_nbiot/amazon-freertos/include\ -I
#        C:\Development\gzkc_smart_nbiot/component/lists\ -I
#        C:\Development\gzkc_smart_nbiot/component/serial_manager\ -I
#        C:\Development\gzkc_smart_nbiot/component/uart\ -I
#        C:\Development\gzkc_smart_nbiot/component/kv\ -I
#        C:\Development\gzkc_smart_nbiot/component/kv/include\ -I
#        C:\Development\gzkc_smart_nbiot/device\ -I
#        C:\Development\gzkc_smart_nbiot/doc\ -I
#        C:\Development\gzkc_smart_nbiot/drivers\ -I
#        C:\Development\gzkc_smart_nbiot/src\ -I
#        C:\Development\gzkc_smart_nbiot/startup\ -I
#        C:\Development\gzkc_smart_nbiot/utilities\ -I
#        C:\Development\gzkc_smart_nbiot/xip\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\atm\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_model\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_sign\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\infra\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\mqtt\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\external_libs\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_cloud\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\CoAPPacket\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\server\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\os\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\awss_reset\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\include\mbedtls\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\include\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list\at_parser.lst
#    Object file  =  
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\obj\at_parser.o
#
###############################################################################

C:\Development\gzkc_smart_nbiot\csdk\eng\atm\at_parser.c
      1          /*
      2           * Copyright (C) 2015-2017 Alibaba Group Holding Limited
      3           */
      4          
      5          #include <stdio.h>
      6          #include <string.h>
      7          
      8          #include "infra_types.h"
      9          #include "at_wrapper.h"
     10          #include "at_parser.h"
     11          
     12          #define OOB_MAX 5
     13          
     14          typedef struct oob_s
     15          {
     16              char *     prefix;
     17              char *     postfix;
     18              char *     oobinputdata;
     19              uint32_t   reallen;
     20              uint32_t   maxlen;
     21              at_recv_cb cb;
     22              void *     arg;
     23          } oob_t;
     24          
     25          /*
     26           * --> | slist | --> | slist | --> NULL
     27           *     ---------     ---------
     28           *     | smhr  |     | smpr  |
     29           *     ---------     ---------
     30           *     | rsp   |     | rsp   |
     31           *     ---------     ---------
     32           */
     33          #if !AT_SINGLE_TASK
     34          #include "infra_list.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void slist_add(slist_t *, slist_t *)
   \                     slist_add: (+1)
   \        0x0   0x680A             LDR      R2,[R1, #+0]
   \        0x2   0x6002             STR      R2,[R0, #+0]
   \        0x4   0x6008             STR      R0,[R1, #+0]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void slist_add_tail(slist_t *, slist_t *)
   \                     slist_add_tail: (+1)
   \        0x0   0xE000             B.N      ??slist_add_tail_0
   \                     ??slist_add_tail_1: (+1)
   \        0x2   0x4611             MOV      R1,R2
   \                     ??slist_add_tail_0: (+1)
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD1FB             BNE.N    ??slist_add_tail_1
   \        0xA   0x....             B.N      slist_add

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void slist_del(slist_t *, slist_t *)
   \                     slist_del: (+1)
   \        0x0   0xE000             B.N      ??slist_del_0
   \                     ??slist_del_1: (+1)
   \        0x2   0x4611             MOV      R1,R2
   \                     ??slist_del_0: (+1)
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD003             BEQ.N    ??slist_del_2
   \        0xA   0x4282             CMP      R2,R0
   \        0xC   0xD1F9             BNE.N    ??slist_del_1
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x6008             STR      R0,[R1, #+0]
   \                     ??slist_del_2: (+1)
   \       0x12   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int slist_empty(slist_t const *)
   \                     slist_empty: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??slist_empty_0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x4770             BX       LR
   \                     ??slist_empty_0: (+1)
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void slist_init(slist_t *)
   \                     slist_init: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
     35          typedef struct at_task_s
     36          {
     37              slist_t   next;
     38              void *    smpr;
     39              char *    command;
     40              char *    rsp;
     41              char *    rsp_prefix;
     42              char *    rsp_success_postfix;
     43              char *    rsp_fail_postfix;
     44              uint32_t  rsp_prefix_len;
     45              uint32_t  rsp_success_postfix_len;
     46              uint32_t  rsp_fail_postfix_len;
     47              uint32_t  rsp_offset;
     48              uint32_t  rsp_len;
     49          } at_task_t;
     50          #endif
     51          
     52          /**
     53           * Parser structure for parsing AT commands
     54           */
     55          typedef struct
     56          {
     57              uart_dev_t *_pstuart;
     58              int         _timeout;
     59              char *      _default_recv_prefix;
     60              char *      _default_recv_success_postfix;
     61              char *      _default_recv_fail_postfix;
     62              char *      _send_delimiter;
     63              int         _recv_prefix_len;
     64              int         _recv_success_postfix_len;
     65              int         _recv_fail_postfix_len;
     66              int         _send_delim_size;
     67              oob_t       _oobs[OOB_MAX];
     68              int         _oobs_num;
     69              void *      at_uart_recv_mutex;
     70              void *      at_uart_send_mutex;
     71              void *      task_mutex;
     72          #if !AT_SINGLE_TASK
     73              slist_t     task_l;
     74          #endif
     75          } at_parser_t;
     76          
     77          #define TASK_DEFAULT_WAIT_TIME 5000
     78          
     79          #ifndef AT_WORKER_STACK_SIZE
     80          #define AT_WORKER_STACK_SIZE   1024
     81          #endif
     82          
     83          #ifndef AT_UART_TIMEOUT_MS
     84          #define AT_UART_TIMEOUT_MS     1000
     85          #endif
     86          
     87          #ifndef AT_CMD_DATA_INTERVAL_MS
     88          #define AT_CMD_DATA_INTERVAL_MS   0
     89          #endif
     90          
     91          #ifdef AT_DEBUG_MODE
     92          #define atpsr_err(...)               do{HAL_Printf(__VA_ARGS__);HAL_Printf("\r\n");}while(0)
     93          #define atpsr_warning(...)           do{HAL_Printf(__VA_ARGS__);HAL_Printf("\r\n");}while(0)
     94          #define atpsr_info(...)              do{HAL_Printf(__VA_ARGS__);HAL_Printf("\r\n");}while(0)
     95          #define atpsr_debug(...)             do{HAL_Printf(__VA_ARGS__);HAL_Printf("\r\n");}while(0)
     96          #else
     97          #define atpsr_err(...)
     98          #define atpsr_warning(...)
     99          #define atpsr_info(...)
    100          #define atpsr_debug(...)
    101          #endif
    102          

   \                                 In section .bss, align 1
    103          static uint8_t    inited = 0;
   \                     inited:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
    104          static uart_dev_t at_uart;
   \                     at_uart:
   \        0x0                      DS8 20
    105          

   \                                 In section .bss, align 4
    106          static at_parser_t at;
   \                     at:
   \        0x0                      DS8 200
    107          
    108          #if !AT_SINGLE_TASK
    109          static void* at_worker(void *arg);
    110          #endif
    111          
    112          #ifndef PLATFORM_HAS_DYNMEM
    113          #if !AT_SINGLE_TASK
    114          static at_task_t g_at_task;
    115          #endif
    116          #endif
    117          

   \                                 In section .text, align 2, keep-with-next
    118          static void at_uart_configure(uart_dev_t *u)
    119          {
    120              u->port                = AT_UART_PORT;
   \                     at_uart_configure: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x7001             STRB     R1,[R0, #+0]
    121              u->config.baud_rate    = AT_UART_BAUDRATE;
   \        0x4   0xF44F 0x31E1      MOV      R1,#+115200
   \        0x8   0x6041             STR      R1,[R0, #+4]
    122              u->config.data_width   = AT_UART_DATA_WIDTH;
   \        0xA   0x2103             MOVS     R1,#+3
   \        0xC   0x7201             STRB     R1,[R0, #+8]
    123              u->config.parity       = AT_UART_PARITY;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x7241             STRB     R1,[R0, #+9]
    124              u->config.stop_bits    = AT_UART_STOP_BITS;
   \       0x12   0x7281             STRB     R1,[R0, #+10]
    125              u->config.flow_control = AT_UART_FLOW_CONTROL;
   \       0x14   0x72C1             STRB     R1,[R0, #+11]
    126              u->config.mode         = AT_UART_MODE;
   \       0x16   0x2102             MOVS     R1,#+2
   \       0x18   0x7301             STRB     R1,[R0, #+12]
    127          }
   \       0x1A   0x4770             BX       LR               ;; return
    128          

   \                                 In section .text, align 2, keep-with-next
    129          static int at_init_uart()
    130          {
   \                     at_init_uart: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    131              at_uart_configure(&at_uart);
   \        0x2   0x....'....        LDR.W    R4,??DataTable20
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x....'....        BL       at_uart_configure
    132          
    133              if (HAL_AT_Uart_Init(&at_uart) != 0) {
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x....'....        BL       HAL_AT_Uart_Init
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD002             BEQ.N    ??at_init_uart_0
    134                  return -1;
   \       0x16   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1A   0xBD10             POP      {R4,PC}
    135              }
    136          
    137              at._pstuart = &at_uart;
   \                     ??at_init_uart_0: (+1)
   \       0x1C   0x....'....        LDR.W    R0,??DataTable20_1
   \       0x20   0x6004             STR      R4,[R0, #+0]
    138          
    139              return 0;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
    140          }
    141          

   \                                 In section .text, align 2, keep-with-next
    142          static void at_set_timeout(int timeout)
    143          {
    144              at._timeout = timeout;
   \                     at_set_timeout: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable20_1
   \        0x4   0x6048             STR      R0,[R1, #+4]
    145          }
   \        0x6   0x4770             BX       LR               ;; return
    146          

   \                                 In section .text, align 2, keep-with-next
    147          static void at_set_recv_delimiter(const char *recv_prefix,
    148                                            const char *recv_success_postfix,
    149                                            const char *recv_fail_postfix)
    150          {
   \                     at_set_recv_delimiter: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
    151              at._default_recv_prefix          = (char *)recv_prefix;
   \        0x6   0x....'....        LDR.W    R6,??DataTable20_1
   \        0xA   0x60B0             STR      R0,[R6, #+8]
    152              at._default_recv_success_postfix = (char *)recv_success_postfix;
   \        0xC   0x60F4             STR      R4,[R6, #+12]
    153              at._default_recv_fail_postfix    = (char *)recv_fail_postfix;
   \        0xE   0x6135             STR      R5,[R6, #+16]
    154              at._recv_prefix_len              = strlen(recv_prefix);
   \       0x10   0x....'....        BL       strlen
   \       0x14   0x61B0             STR      R0,[R6, #+24]
    155              at._recv_success_postfix_len     = strlen(recv_success_postfix);
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x....'....        BL       strlen
   \       0x1C   0x61F0             STR      R0,[R6, #+28]
    156              at._recv_fail_postfix_len        = strlen(recv_fail_postfix);
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x....'....        BL       strlen
   \       0x24   0x6230             STR      R0,[R6, #+32]
    157          }
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
    158          

   \                                 In section .text, align 2, keep-with-next
    159          static void at_set_send_delimiter(const char *delimiter)
    160          {
   \                     at_set_send_delimiter: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    161              at._send_delimiter  = (char *)delimiter;
   \        0x2   0x....'....        LDR.W    R4,??DataTable20_1
   \        0x6   0x6160             STR      R0,[R4, #+20]
    162              at._send_delim_size = strlen(delimiter);
   \        0x8   0x....'....        BL       strlen
   \        0xC   0x6260             STR      R0,[R4, #+36]
    163          }
   \        0xE   0xBD10             POP      {R4,PC}          ;; return
    164          

   \                                 In section .text, align 2, keep-with-next
    165          static int at_init_task_mutex()
    166          {
   \                     at_init_task_mutex: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    167              at.task_mutex = HAL_MutexCreate();
   \        0x2   0x....'....        LDR.W    R4,??DataTable20_1
   \        0x6   0x....'....        BL       HAL_MutexCreate
   \        0xA   0xF8C4 0x00C0      STR      R0,[R4, #+192]
    168              if (NULL == at.task_mutex) {
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD102             BNE.N    ??at_init_task_mutex_0
    169                  atpsr_err("Creating task mutex failed\r\n");
    170                  return -1;
   \       0x12   0xF04F 0x30FF      MOV      R0,#-1
   \       0x16   0xBD10             POP      {R4,PC}
    171              }
    172          
    173              return 0;
   \                     ??at_init_task_mutex_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
    174          }
    175          

   \                                 In section .text, align 2, keep-with-next
    176          static void at_deinit_task_mutex()
    177          {
    178              if (at.task_mutex) {
   \                     at_deinit_task_mutex: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable20_1
   \        0x4   0xF8D1 0x00C0      LDR      R0,[R1, #+192]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD001             BEQ.N    ??at_deinit_task_mutex_0
    179                  HAL_MutexDestroy(at.task_mutex);
   \        0xC   0x....'....        B.W      HAL_MutexDestroy
    180              }
    181              return;
   \                     ??at_deinit_task_mutex_0: (+1)
   \       0x10   0x4770             BX       LR               ;; return
    182          }
    183          

   \                                 In section .text, align 2, keep-with-next
    184          static int at_init_uart_recv_mutex()
    185          {
   \                     at_init_uart_recv_mutex: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    186              at.at_uart_recv_mutex = HAL_MutexCreate();
   \        0x2   0x....'....        LDR.W    R4,??DataTable20_1
   \        0x6   0x....'....        BL       HAL_MutexCreate
   \        0xA   0xF8C4 0x00B8      STR      R0,[R4, #+184]
    187              if (NULL == at.at_uart_recv_mutex) {
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD102             BNE.N    ??at_init_uart_recv_mutex_0
    188                  atpsr_err("Creating at_uart_recv_mutex failed\r\n");
    189                  return -1;
   \       0x12   0xF04F 0x30FF      MOV      R0,#-1
   \       0x16   0xBD10             POP      {R4,PC}
    190              }
    191          
    192              return 0;
   \                     ??at_init_uart_recv_mutex_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
    193          }
    194          

   \                                 In section .text, align 2, keep-with-next
    195          static void at_deinit_uart_recv_mutex()
    196          {
    197              if (at.at_uart_recv_mutex) {
   \                     at_deinit_uart_recv_mutex: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable20_1
   \        0x4   0xF8D1 0x00B8      LDR      R0,[R1, #+184]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD001             BEQ.N    ??at_deinit_uart_recv_mutex_0
    198                  HAL_MutexDestroy(at.at_uart_recv_mutex);
   \        0xC   0x....'....        B.W      HAL_MutexDestroy
    199              }
    200              return;
   \                     ??at_deinit_uart_recv_mutex_0: (+1)
   \       0x10   0x4770             BX       LR               ;; return
    201          }
    202          

   \                                 In section .text, align 2, keep-with-next
    203          static int at_worker_uart_send_mutex_init()
    204          {
   \                     at_worker_uart_send_mutex_init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    205              at.at_uart_send_mutex = HAL_MutexCreate();
   \        0x2   0x....'....        LDR.W    R4,??DataTable20_1
   \        0x6   0x....'....        BL       HAL_MutexCreate
   \        0xA   0xF8C4 0x00BC      STR      R0,[R4, #+188]
    206              if (NULL == at.at_uart_send_mutex) {
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD102             BNE.N    ??at_worker_uart_send_mutex_init_0
    207                  atpsr_err("Creating at worker sem failed\r\n");
    208                  return -1;
   \       0x12   0xF04F 0x30FF      MOV      R0,#-1
   \       0x16   0xBD10             POP      {R4,PC}
    209              }
    210              return 0;
   \                     ??at_worker_uart_send_mutex_init_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
    211          }
    212          
    213          #if !AT_SINGLE_TASK

   \                                 In section .text, align 2, keep-with-next
    214          static void at_worker_uart_send_mutex_deinit()
    215          {
    216              if (at.at_uart_send_mutex) {
   \                     at_worker_uart_send_mutex_deinit: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable20_1
   \        0x4   0xF8D1 0x00BC      LDR      R0,[R1, #+188]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD001             BEQ.N    ??at_worker_uart_send_mutex_deinit_0
    217                  HAL_MutexDestroy(at.at_uart_send_mutex);
   \        0xC   0x....'....        B.W      HAL_MutexDestroy
    218              }
    219          }
   \                     ??at_worker_uart_send_mutex_deinit_0: (+1)
   \       0x10   0x4770             BX       LR               ;; return
    220          #endif
    221          

   \                                 In section .text, align 2, keep-with-next
    222          int at_parser_init(void)
    223          {
   \                     at_parser_init: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
    224              char *recv_prefix = AT_RECV_PREFIX;
   \        0x6   0x....             ADR.N    R4,??DataTable14  ;; 0x0D, 0x0A, 0x00, 0x00
    225              char *recv_success_postfix = AT_RECV_SUCCESS_POSTFIX;
   \        0x8   0x....'....        LDR.W    R5,??DataTable20_2
    226              char *recv_fail_postfix = AT_RECV_FAIL_POSTFIX;
   \        0xC   0x....'....        LDR.W    R6,??DataTable20_3
    227              char *send_delimiter = AT_SEND_DELIMITER;
   \       0x10   0x....             ADR.N    R7,??DataTable15  ;; "\r"
    228              int  timeout = AT_UART_TIMEOUT_MS;
    229          #if !AT_SINGLE_TASK
    230              void *task;
    231              int stack_used;
    232              hal_os_thread_param_t task_parms = {0};
                                                         ^
Warning[Pe188]: enumerated type mixed with another type
   \       0x12   0xA803             ADD      R0,SP,#+12
   \       0x14   0x2114             MOVS     R1,#+20
   \       0x16   0x....'....        BL       __aeabi_memclr4
    233          #endif
    234          
    235              if (inited == 1) {
   \       0x1A   0x....'....        LDR.W    R0,??DataTable20_4
   \       0x1E   0x7800             LDRB     R0,[R0, #+0]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD102             BNE.N    ??at_parser_init_0
    236                  atpsr_info("have already inited ,it will init again\r\n");
    237                  return -1;
   \       0x24   0xF04F 0x30FF      MOV      R0,#-1
   \       0x28   0xE059             B.N      ??at_parser_init_1
    238              }
    239          
    240              memset(&at, 0, sizeof(at_parser_t));
   \                     ??at_parser_init_0: (+1)
   \       0x2A   0x....'....        LDR.W    R8,??DataTable20_1
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x21C8             MOVS     R1,#+200
   \       0x32   0x4640             MOV      R0,R8
   \       0x34   0x....'....        BL       __aeabi_memset4
    241          
    242              if (at_init_uart() != 0) {
   \       0x38   0x....'....        BL       at_init_uart
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD002             BEQ.N    ??at_parser_init_2
    243                  atpsr_err("at uart init fail \r\n");
    244                  return -1;
   \       0x40   0xF04F 0x30FF      MOV      R0,#-1
   \       0x44   0xE04B             B.N      ??at_parser_init_1
    245              }
    246          
    247              memset(at._oobs, 0, sizeof(oob_t) * OOB_MAX);
   \                     ??at_parser_init_2: (+1)
   \       0x46   0x2200             MOVS     R2,#+0
   \       0x48   0x218C             MOVS     R1,#+140
   \       0x4A   0xF108 0x0028      ADD      R0,R8,#+40
   \       0x4E   0x....'....        BL       __aeabi_memset4
    248          
    249              at_set_timeout(timeout);
   \       0x52   0xF44F 0x707A      MOV      R0,#+1000
   \       0x56   0x....'....        BL       at_set_timeout
    250              at_set_recv_delimiter(recv_prefix, recv_success_postfix, recv_fail_postfix);
   \       0x5A   0x4632             MOV      R2,R6
   \       0x5C   0x4629             MOV      R1,R5
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0x....'....        BL       at_set_recv_delimiter
    251              at_set_send_delimiter(send_delimiter);
   \       0x64   0x4638             MOV      R0,R7
   \       0x66   0x....'....        BL       at_set_send_delimiter
    252          
    253              if (at_init_uart_recv_mutex() != 0) {
   \       0x6A   0x....'....        BL       at_init_uart_recv_mutex
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD002             BEQ.N    ??at_parser_init_3
    254                  atpsr_err("at_uart_recv_mutex init fail \r\n");
    255                  return -1;
   \       0x72   0xF04F 0x30FF      MOV      R0,#-1
   \       0x76   0xE032             B.N      ??at_parser_init_1
    256              }
    257          
    258              if (at_init_task_mutex() != 0) {
   \                     ??at_parser_init_3: (+1)
   \       0x78   0x....'....        BL       at_init_task_mutex
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD004             BEQ.N    ??at_parser_init_4
    259                  at_deinit_uart_recv_mutex();
   \       0x80   0x....'....        BL       at_deinit_uart_recv_mutex
    260                  atpsr_err("at mutex init fail \r\n");
    261                  return -1;
   \       0x84   0xF04F 0x30FF      MOV      R0,#-1
   \       0x88   0xE029             B.N      ??at_parser_init_1
    262              }
    263          
    264              if (at_worker_uart_send_mutex_init() != 0) {
   \                     ??at_parser_init_4: (+1)
   \       0x8A   0x....'....        BL       at_worker_uart_send_mutex_init
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD003             BEQ.N    ??at_parser_init_5
    265                  at_deinit_uart_recv_mutex();
   \       0x92   0x....'....        BL       at_deinit_uart_recv_mutex
    266                  at_deinit_task_mutex();
   \       0x96   0x....'....        BL       at_deinit_task_mutex
    267                  atpsr_err("fail to creat at worker sem\r\n");
    268              }
    269          
    270          #if AT_SINGLE_TASK
    271              inited = true;
    272          #else
    273              slist_init(&at.task_l);
   \                     ??at_parser_init_5: (+1)
   \       0x9A   0xF108 0x00C4      ADD      R0,R8,#+196
   \       0x9E   0x....'....        BL       slist_init
    274          
    275              task_parms.priority = os_thread_priority_normal;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    276              task_parms.stack_size = AT_WORKER_STACK_SIZE;
   \       0xA8   0xF44F 0x6080      MOV      R0,#+1024
   \       0xAC   0x9005             STR      R0,[SP, #+20]
    277              task_parms.name = "at_worker";
   \       0xAE   0x....'....        LDR.W    R0,??DataTable20_5
   \       0xB2   0x9007             STR      R0,[SP, #+28]
    278              if (HAL_ThreadCreate(&task, at_worker, NULL, &task_parms, &stack_used) != 0) {
   \       0xB4   0xA801             ADD      R0,SP,#+4
   \       0xB6   0x9000             STR      R0,[SP, #+0]
   \       0xB8   0xAB03             ADD      R3,SP,#+12
   \       0xBA   0x2200             MOVS     R2,#+0
   \       0xBC   0x....'....        ADR.W    R1,at_worker
   \       0xC0   0xA802             ADD      R0,SP,#+8
   \       0xC2   0x....'....        BL       HAL_ThreadCreate
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD008             BEQ.N    ??at_parser_init_6
    279                  at_deinit_uart_recv_mutex();
   \       0xCA   0x....'....        BL       at_deinit_uart_recv_mutex
    280                  at_deinit_task_mutex();
   \       0xCE   0x....'....        BL       at_deinit_task_mutex
    281                  at_worker_uart_send_mutex_deinit();
   \       0xD2   0x....'....        BL       at_worker_uart_send_mutex_deinit
    282                  atpsr_err("fail to creat at task\r\n");
    283                  return -1;
   \       0xD6   0xF04F 0x30FF      MOV      R0,#-1
   \       0xDA   0xE000             B.N      ??at_parser_init_1
    284              }
    285          #endif
    286          
    287              return 0;
   \                     ??at_parser_init_6: (+1)
   \       0xDC   0x2000             MOVS     R0,#+0
   \                     ??at_parser_init_1: (+1)
   \       0xDE   0xB008             ADD      SP,SP,#+32
   \       0xE0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    288          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000             DC16 0
   \        0x2   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    289          

   \                                 In section .text, align 2, keep-with-next
    290          static int at_sendto_lower(uart_dev_t *uart, void *data, uint32_t size,
    291                                     uint32_t timeout, bool ackreq)
    292          {
    293              int ret = -1;
    294          
    295              (void) ackreq;
    296              ret = HAL_AT_Uart_Send(uart, data, size, timeout);
    297          
    298              return ret;
   \                     at_sendto_lower: (+1)
   \        0x0   0x....'....        B.W      HAL_AT_Uart_Send
    299          }
    300          

   \                                 In section .text, align 2, keep-with-next
    301          static int at_recvfrom_lower(uart_dev_t *uart, void *data, uint32_t expect_size,
    302                                       uint32_t *recv_size, uint32_t timeout)
    303          {
   \                     at_recvfrom_lower: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x9C04             LDR      R4,[SP, #+16]
    304              int ret = -1;
    305          
    306              ret = HAL_AT_Uart_Recv(uart, data, expect_size, recv_size, timeout);
    307          
    308              return ret;
   \        0x4   0x9400             STR      R4,[SP, #+0]
   \        0x6   0x....'....        BL       HAL_AT_Uart_Recv
   \        0xA   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    309          }
    310          
    311          #if AT_SINGLE_TASK
    312          int at_send_wait_reply(const char *cmd, int cmdlen, bool delimiter,
    313                                 const char *data, int datalen,
    314                                 char *replybuf, int bufsize,
    315                                 const atcmd_config_t *atcmdconfig)
    316          {
    317              int intval_ms = AT_CMD_DATA_INTERVAL_MS;
    318          
    319              if (at_send_no_reply(cmd, cmdlen, delimiter) < 0) {
    320                  return -1;
    321              }
    322          
    323              if (data && datalen) {
    324                  if (intval_ms > 0)
    325                      HAL_SleepMs(intval_ms);
    326          
    327                  if (at_send_no_reply(data, datalen, false) < 0) {
    328                      return -1;
    329                  }
    330              }
    331          
    332              if (at_yield(replybuf, bufsize, atcmdconfig, at._timeout) <  0) {
    333                  return -1;
    334              }
    335          
    336              return 0;
    337          }
    338          #else

   \                                 In section .text, align 2, keep-with-next
    339          static int at_worker_task_add(at_task_t *tsk)
    340          {
   \                     at_worker_task_add: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    341              if (NULL == tsk) {
   \        0x4   0xD102             BNE.N    ??at_worker_task_add_0
    342                  atpsr_err("invalid input %s \r\n", __func__);
    343                  return -1;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
    344              }
    345          
    346              HAL_MutexLock(at.task_mutex);
   \                     ??at_worker_task_add_0: (+1)
   \        0xC   0x....'....        LDR.W    R5,??DataTable20_1
   \       0x10   0xF8D5 0x00C0      LDR      R0,[R5, #+192]
   \       0x14   0x....'....        BL       HAL_MutexLock
    347              slist_add_tail(&tsk->next, &at.task_l);
   \       0x18   0xF105 0x01C4      ADD      R1,R5,#+196
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       slist_add_tail
    348              HAL_MutexUnlock(at.task_mutex);
   \       0x22   0xF8D5 0x00C0      LDR      R0,[R5, #+192]
   \       0x26   0x....'....        BL       HAL_MutexUnlock
    349          
    350              return 0;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    351          }
    352          

   \                                 In section .text, align 2, keep-with-next
    353          static int at_worker_task_del(at_task_t *tsk)
    354          {
   \                     at_worker_task_del: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    355              if (NULL == tsk) {
   \        0x4   0xD102             BNE.N    ??at_worker_task_del_0
    356                  atpsr_err("invalid input %s \r\n", __func__);
    357                  return -1;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
    358              }
    359          
    360              HAL_MutexLock(at.task_mutex);
   \                     ??at_worker_task_del_0: (+1)
   \        0xC   0x....'....        LDR.W    R5,??DataTable20_1
   \       0x10   0xF8D5 0x00C0      LDR      R0,[R5, #+192]
   \       0x14   0x....'....        BL       HAL_MutexLock
    361              slist_del(&tsk->next, &at.task_l);
   \       0x18   0xF105 0x01C4      ADD      R1,R5,#+196
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       slist_del
    362              HAL_MutexUnlock(at.task_mutex);
   \       0x22   0xF8D5 0x00C0      LDR      R0,[R5, #+192]
   \       0x26   0x....'....        BL       HAL_MutexUnlock
    363              if (tsk->smpr) {
   \       0x2A   0x6860             LDR      R0,[R4, #+4]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD001             BEQ.N    ??at_worker_task_del_1
    364                  HAL_SemaphoreDestroy(tsk->smpr);
   \       0x30   0x....'....        BL       HAL_SemaphoreDestroy
    365              }
    366              if (tsk) {
    367          #ifdef PLATFORM_HAS_DYNMEM
    368                  HAL_Free(tsk);
   \                     ??at_worker_task_del_1: (+1)
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       HAL_Free
    369          #endif
    370              }
    371          
    372              return 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    373          }
    374          

   \                                 In section .text, align 2, keep-with-next
    375          int at_send_wait_reply(const char *cmd, int cmdlen, bool delimiter,
    376                                 const char *data, int datalen,
    377                                 char *replybuf, int bufsize,
    378                                 const atcmd_config_t *atcmdconfig)
    379          { 
   \                     at_send_wait_reply: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4691             MOV      R9,R2
   \        0x6   0x4698             MOV      R8,R3
    380              int ret = 0;
   \        0x8   0x2400             MOVS     R4,#+0
    381              int intval_ms = AT_CMD_DATA_INTERVAL_MS;
    382              at_task_t *tsk;
    383          
    384              if (inited == 0) {
   \        0xA   0x....'....        LDR.W    R2,??DataTable20_4
   \        0xE   0x7812             LDRB     R2,[R2, #+0]
   \       0x10   0x2A00             CMP      R2,#+0
   \       0x12   0xD00D             BEQ.N    ??at_send_wait_reply_0
   \       0x14   0x0005             MOVS     R5,R0
    385                  atpsr_err("at have not init yet\r\n");
    386                  return -1;
    387              }
    388          
    389              if (NULL == cmd || cmdlen <= 0) {
   \       0x16   0xD00B             BEQ.N    ??at_send_wait_reply_0
   \       0x18   0x9101             STR      R1,[SP, #+4]
   \       0x1A   0x4608             MOV      R0,R1
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xDB07             BLT.N    ??at_send_wait_reply_0
   \       0x20   0x9F0D             LDR      R7,[SP, #+52]
    390                  atpsr_err("%s invalid input \r\n", __FUNCTION__);
    391                  return -1;
    392              }
    393          
    394              if (NULL == replybuf || 0 == bufsize) {
   \       0x22   0x2F00             CMP      R7,#+0
   \       0x24   0xD004             BEQ.N    ??at_send_wait_reply_0
   \       0x26   0xF8DD 0xB038      LDR      R11,[SP, #+56]
   \       0x2A   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x2E   0xD102             BNE.N    ??at_send_wait_reply_1
    395                  atpsr_err("%s invalid input \r\n", __FUNCTION__);
    396                  return -1;
   \                     ??at_send_wait_reply_0: (+1)
   \       0x30   0xF04F 0x30FF      MOV      R0,#-1
   \       0x34   0xE07F             B.N      ??at_send_wait_reply_2
    397              }
    398          
    399              HAL_MutexLock(at.at_uart_send_mutex);
   \                     ??at_send_wait_reply_1: (+1)
   \       0x36   0x....'....        LDR.W    R10,??DataTable20_1
   \       0x3A   0xF8DA 0x00BC      LDR      R0,[R10, #+188]
   \       0x3E   0x....'....        BL       HAL_MutexLock
    400          #ifdef PLATFORM_HAS_DYNMEM
    401              tsk = (at_task_t *)HAL_Malloc(sizeof(at_task_t));
   \       0x42   0x2030             MOVS     R0,#+48
   \       0x44   0x....'....        BL       HAL_Malloc
   \       0x48   0x0006             MOVS     R6,R0
    402          #else
    403              tsk = &g_at_task;
    404          #endif
    405              if (NULL == tsk) {
   \       0x4A   0xD106             BNE.N    ??at_send_wait_reply_3
    406                  atpsr_err("tsk buffer allocating failed");
    407                  HAL_MutexUnlock(at.at_uart_send_mutex);
   \       0x4C   0xF8DA 0x00BC      LDR      R0,[R10, #+188]
   \       0x50   0x....'....        BL       HAL_MutexUnlock
    408                  return -1;
   \       0x54   0xF04F 0x30FF      MOV      R0,#-1
   \       0x58   0xE06D             B.N      ??at_send_wait_reply_2
    409              }
    410              memset(tsk, 0, sizeof(at_task_t));
   \                     ??at_send_wait_reply_3: (+1)
   \       0x5A   0x4622             MOV      R2,R4
   \       0x5C   0x2130             MOVS     R1,#+48
   \       0x5E   0x....'....        BL       __aeabi_memset4
    411          
    412              tsk->smpr = HAL_SemaphoreCreate();
   \       0x62   0x....'....        BL       HAL_SemaphoreCreate
   \       0x66   0x6070             STR      R0,[R6, #+4]
    413              if (NULL == tsk->smpr) {
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD05C             BEQ.N    ??at_send_wait_reply_4
   \       0x6C   0x9C0F             LDR      R4,[SP, #+60]
    414                  atpsr_err("failed to allocate semaphore");
    415                  goto end;
    416              }
    417          
    418              if (atcmdconfig) {
   \       0x6E   0x2C00             CMP      R4,#+0
   \       0x70   0xD017             BEQ.N    ??at_send_wait_reply_5
    419                  if (NULL != atcmdconfig->reply_prefix) {
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD004             BEQ.N    ??at_send_wait_reply_6
    420                      tsk->rsp_prefix     = atcmdconfig->reply_prefix;
   \       0x78   0x6130             STR      R0,[R6, #+16]
    421                      tsk->rsp_prefix_len = strlen(atcmdconfig->reply_prefix);
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x....'....        BL       strlen
   \       0x80   0x61F0             STR      R0,[R6, #+28]
    422                  }
    423          
    424                  if (NULL != atcmdconfig->reply_success_postfix) {
   \                     ??at_send_wait_reply_6: (+1)
   \       0x82   0x6860             LDR      R0,[R4, #+4]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD004             BEQ.N    ??at_send_wait_reply_7
    425                      tsk->rsp_success_postfix     = atcmdconfig->reply_success_postfix;
   \       0x88   0x6170             STR      R0,[R6, #+20]
    426                      tsk->rsp_success_postfix_len = strlen(atcmdconfig->reply_success_postfix);
   \       0x8A   0x6860             LDR      R0,[R4, #+4]
   \       0x8C   0x....'....        BL       strlen
   \       0x90   0x6230             STR      R0,[R6, #+32]
    427                  }
    428          
    429                  if (NULL != atcmdconfig->reply_fail_postfix) {
   \                     ??at_send_wait_reply_7: (+1)
   \       0x92   0x68A0             LDR      R0,[R4, #+8]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD004             BEQ.N    ??at_send_wait_reply_5
    430                      tsk->rsp_fail_postfix     = atcmdconfig->reply_fail_postfix;
   \       0x98   0x61B0             STR      R0,[R6, #+24]
    431                      tsk->rsp_fail_postfix_len = strlen(atcmdconfig->reply_fail_postfix);
   \       0x9A   0x68A0             LDR      R0,[R4, #+8]
   \       0x9C   0x....'....        BL       strlen
   \       0xA0   0x6270             STR      R0,[R6, #+36]
    432                  }
    433              }
    434          
    435              tsk->command = (char *)cmd;
   \                     ??at_send_wait_reply_5: (+1)
   \       0xA2   0x60B5             STR      R5,[R6, #+8]
    436              tsk->rsp     = replybuf;
   \       0xA4   0x60F7             STR      R7,[R6, #+12]
    437              tsk->rsp_len = bufsize;
   \       0xA6   0xF8C6 0xB02C      STR      R11,[R6, #+44]
    438          
    439              at_worker_task_add(tsk);
   \       0xAA   0x4630             MOV      R0,R6
   \       0xAC   0x....'....        BL       at_worker_task_add
    440          
    441              if ((ret = at_sendto_lower(at._pstuart, (void *)cmd, cmdlen,
    442                                         at._timeout, true)) != 0) {
   \       0xB0   0x2001             MOVS     R0,#+1
   \       0xB2   0x9000             STR      R0,[SP, #+0]
   \       0xB4   0xF8DA 0x3004      LDR      R3,[R10, #+4]
   \       0xB8   0x9A01             LDR      R2,[SP, #+4]
   \       0xBA   0x4629             MOV      R1,R5
   \       0xBC   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xC0   0x....'....        BL       at_sendto_lower
   \       0xC4   0x0004             MOVS     R4,R0
   \       0xC6   0xD12E             BNE.N    ??at_send_wait_reply_4
    443                  atpsr_err("uart send command failed");
    444                  goto end;
    445              }
    446          
    447              if (delimiter) {
   \       0xC8   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xCC   0xD010             BEQ.N    ??at_send_wait_reply_8
    448                  if ((ret = at_sendto_lower(at._pstuart, (void *)at._send_delimiter,
    449                              strlen(at._send_delimiter), at._timeout, false)) != 0) {
   \       0xCE   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \       0xD2   0x....'....        BL       strlen
   \       0xD6   0x2100             MOVS     R1,#+0
   \       0xD8   0x9100             STR      R1,[SP, #+0]
   \       0xDA   0xF8DA 0x3004      LDR      R3,[R10, #+4]
   \       0xDE   0x4602             MOV      R2,R0
   \       0xE0   0xF8DA 0x1014      LDR      R1,[R10, #+20]
   \       0xE4   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xE8   0x....'....        BL       at_sendto_lower
   \       0xEC   0x0004             MOVS     R4,R0
   \       0xEE   0xD11A             BNE.N    ??at_send_wait_reply_4
   \                     ??at_send_wait_reply_8: (+1)
   \       0xF0   0x4644             MOV      R4,R8
    450                      atpsr_err("uart send delimiter failed");
    451                      goto end;
    452                  }
    453              }
    454          
    455              if (data && datalen > 0) {
   \       0xF2   0x2C00             CMP      R4,#+0
   \       0xF4   0xD011             BEQ.N    ??at_send_wait_reply_9
   \       0xF6   0x9D0C             LDR      R5,[SP, #+48]
   \       0xF8   0x2D01             CMP      R5,#+1
   \       0xFA   0xDB0E             BLT.N    ??at_send_wait_reply_9
    456                  if (intval_ms > 0)
    457                      HAL_SleepMs(intval_ms);
   \       0xFC   0x2032             MOVS     R0,#+50
   \       0xFE   0x....'....        BL       HAL_SleepMs
    458          
    459                  if ((ret = at_sendto_lower(at._pstuart, (void *)data, datalen, at._timeout, true)) != 0) {
   \      0x102   0x2001             MOVS     R0,#+1
   \      0x104   0x9000             STR      R0,[SP, #+0]
   \      0x106   0xF8DA 0x3004      LDR      R3,[R10, #+4]
   \      0x10A   0x462A             MOV      R2,R5
   \      0x10C   0x4621             MOV      R1,R4
   \      0x10E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x112   0x....'....        BL       at_sendto_lower
   \      0x116   0x0004             MOVS     R4,R0
   \      0x118   0xD105             BNE.N    ??at_send_wait_reply_4
    460                      atpsr_err("uart send delimiter failed");
    461                      goto end;
    462                  }
    463              }
    464          
    465              if ((ret = HAL_SemaphoreWait(tsk->smpr, TASK_DEFAULT_WAIT_TIME)) != 0) {
   \                     ??at_send_wait_reply_9: (+1)
   \      0x11A   0xF241 0x3188      MOVW     R1,#+5000
   \      0x11E   0x6870             LDR      R0,[R6, #+4]
   \      0x120   0x....'....        BL       HAL_SemaphoreWait
   \      0x124   0x4604             MOV      R4,R0
    466                  atpsr_err("sem_wait failed");
    467                  goto end;
    468              }
    469          
    470          end:
    471              at_worker_task_del(tsk);
   \                     ??at_send_wait_reply_4: (+1)
   \      0x126   0x4630             MOV      R0,R6
   \      0x128   0x....'....        BL       at_worker_task_del
    472              HAL_MutexUnlock(at.at_uart_send_mutex);
   \      0x12C   0xF8DA 0x00BC      LDR      R0,[R10, #+188]
   \      0x130   0x....'....        BL       HAL_MutexUnlock
    473              return ret;
   \      0x134   0x4620             MOV      R0,R4
   \                     ??at_send_wait_reply_2: (+1)
   \      0x136   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    474          }
    475          #endif
    476          

   \                                 In section .text, align 2, keep-with-next
    477          int at_send_no_reply(const char *data, int datalen, bool delimiter)
    478          {
   \                     at_send_no_reply: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    479              int ret = 0;
    480          
    481              if (inited == 0) {
   \        0x8   0x....'....        LDR.W    R0,??DataTable20_4
   \        0xC   0x7800             LDRB     R0,[R0, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD003             BEQ.N    ??at_send_no_reply_0
    482                  atpsr_err("at have not init yet\r\n");
    483                  return -1;
    484              }
    485          
    486              if (NULL == data || datalen <= 0) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD001             BEQ.N    ??at_send_no_reply_0
   \       0x16   0x2D01             CMP      R5,#+1
   \       0x18   0xDA02             BGE.N    ??at_send_no_reply_1
    487                  atpsr_err("invalid input \r\n");
    488                  return -1;
   \                     ??at_send_no_reply_0: (+1)
   \       0x1A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1E   0xBDF2             POP      {R1,R4-R7,PC}
    489              }
    490          
    491              HAL_MutexLock(at.at_uart_send_mutex);
   \                     ??at_send_no_reply_1: (+1)
   \       0x20   0x....'....        LDR.W    R7,??DataTable20_1
   \       0x24   0xF8D7 0x00BC      LDR      R0,[R7, #+188]
   \       0x28   0x....'....        BL       HAL_MutexLock
    492              if ((ret = at_sendto_lower(at._pstuart, (void *)data,
    493                                         datalen, at._timeout, true)) != 0) {
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   \       0x30   0x687B             LDR      R3,[R7, #+4]
   \       0x32   0x462A             MOV      R2,R5
   \       0x34   0x4621             MOV      R1,R4
   \       0x36   0x6838             LDR      R0,[R7, #+0]
   \       0x38   0x....'....        BL       at_sendto_lower
   \       0x3C   0x0004             MOVS     R4,R0
   \       0x3E   0xD10E             BNE.N    ??at_send_no_reply_2
    494                  atpsr_err("uart send raw content (%s) failed", data);
    495                  HAL_MutexUnlock(at.at_uart_send_mutex);
    496                  return -1;
    497              }
    498          
    499              if (delimiter) {
   \       0x40   0x2E00             CMP      R6,#+0
   \       0x42   0xD013             BEQ.N    ??at_send_no_reply_3
    500                  if ((ret = at_sendto_lower(at._pstuart, (void *)at._send_delimiter,
    501                              strlen(at._send_delimiter), at._timeout, false)) != 0) {
   \       0x44   0x6978             LDR      R0,[R7, #+20]
   \       0x46   0x....'....        BL       strlen
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x9100             STR      R1,[SP, #+0]
   \       0x4E   0x687B             LDR      R3,[R7, #+4]
   \       0x50   0x4602             MOV      R2,R0
   \       0x52   0x6979             LDR      R1,[R7, #+20]
   \       0x54   0x6838             LDR      R0,[R7, #+0]
   \       0x56   0x....'....        BL       at_sendto_lower
   \       0x5A   0x0004             MOVS     R4,R0
   \       0x5C   0xD006             BEQ.N    ??at_send_no_reply_3
    502                      atpsr_err("uart send delimiter failed");
    503                      HAL_MutexUnlock(at.at_uart_send_mutex);
   \                     ??at_send_no_reply_2: (+1)
   \       0x5E   0xF8D7 0x00BC      LDR      R0,[R7, #+188]
   \       0x62   0x....'....        BL       HAL_MutexUnlock
    504                      return -1;
   \       0x66   0xF04F 0x30FF      MOV      R0,#-1
   \       0x6A   0xBDF2             POP      {R1,R4-R7,PC}
    505                  }
    506              }
    507              HAL_MutexUnlock(at.at_uart_send_mutex);
   \                     ??at_send_no_reply_3: (+1)
   \       0x6C   0xF8D7 0x00BC      LDR      R0,[R7, #+188]
   \       0x70   0x....'....        BL       HAL_MutexUnlock
    508          
    509              return ret;
   \       0x74   0x4620             MOV      R0,R4
   \       0x76   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    510          }
    511          

   \                                 In section .text, align 2, keep-with-next
    512          static int at_getc(char *c, int timeout_ms)
    513          {
   \                     at_getc: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    514              int      ret = 0;
    515              char     data;
    516              uint32_t recv_size = 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9002             STR      R0,[SP, #+8]
    517          
    518              if (NULL == c) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??at_getc_0
    519                  return -1;
   \        0xE   0xF04F 0x30FF      MOV      R0,#-1
   \       0x12   0xE028             B.N      ??at_getc_1
    520              }
    521          
    522              if (inited == 0) {
   \                     ??at_getc_0: (+1)
   \       0x14   0x....'....        LDR.W    R0,??DataTable20_4
   \       0x18   0x7800             LDRB     R0,[R0, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??at_getc_2
    523                  atpsr_err("at have not init yet\r\n");
    524                  return -1;
   \       0x1E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x22   0xE020             B.N      ??at_getc_1
    525              }
    526          
    527              HAL_MutexLock(at.at_uart_recv_mutex);
   \                     ??at_getc_2: (+1)
   \       0x24   0x....'....        LDR.W    R6,??DataTable20_1
   \       0x28   0xF8D6 0x00B8      LDR      R0,[R6, #+184]
   \       0x2C   0x....'....        BL       HAL_MutexLock
    528              ret = at_recvfrom_lower(at._pstuart, (void *)&data, 1, &recv_size, timeout_ms);
   \       0x30   0x9500             STR      R5,[SP, #+0]
   \       0x32   0xAB02             ADD      R3,SP,#+8
   \       0x34   0x2201             MOVS     R2,#+1
   \       0x36   0xA901             ADD      R1,SP,#+4
   \       0x38   0x6830             LDR      R0,[R6, #+0]
   \       0x3A   0x....'....        BL       at_recvfrom_lower
   \       0x3E   0x4605             MOV      R5,R0
    529              HAL_MutexUnlock(at.at_uart_recv_mutex);
   \       0x40   0xF8D6 0x00B8      LDR      R0,[R6, #+184]
   \       0x44   0x....'....        BL       HAL_MutexUnlock
    530          
    531              if (ret != 0) {
   \       0x48   0x2D00             CMP      R5,#+0
   \       0x4A   0xD002             BEQ.N    ??at_getc_3
    532          #ifdef WORKAROUND_DEVELOPERBOARD_DMA_UART
    533                  if (ret == 1) {
    534                      HAL_UART_Deinit(at._pstuart);
    535                      at_init_uart();
    536                  }
    537          #endif
    538                  return -1;
   \       0x4C   0xF04F 0x30FF      MOV      R0,#-1
   \       0x50   0xE009             B.N      ??at_getc_1
    539              }
    540          
    541              if (recv_size == 1) {
   \                     ??at_getc_3: (+1)
   \       0x52   0x9802             LDR      R0,[SP, #+8]
   \       0x54   0x2801             CMP      R0,#+1
   \       0x56   0xD104             BNE.N    ??at_getc_4
    542                  *c = data;
   \       0x58   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x5C   0x7020             STRB     R0,[R4, #+0]
    543                  return 0;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xE001             B.N      ??at_getc_1
    544              } else {
    545                  return -1;
   \                     ??at_getc_4: (+1)
   \       0x62   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??at_getc_1: (+1)
   \       0x66   0xB004             ADD      SP,SP,#+16
   \       0x68   0xBD70             POP      {R4-R6,PC}       ;; return
    546              }
    547          }
    548          

   \                                 In section .text, align 2, keep-with-next
    549          int at_read(char *outbuf, int readsize)
    550          {
   \                     at_read: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
    551              int      ret = 0;
   \        0x8   0x2400             MOVS     R4,#+0
    552              uint32_t recv_size, total_read = 0;
   \        0xA   0x4627             MOV      R7,R4
    553          
    554              if (inited == 0) {
   \        0xC   0x....'....        LDR.W    R0,??DataTable20_4
   \       0x10   0x7800             LDRB     R0,[R0, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??at_read_0
    555                  atpsr_err("at have not init yet\r\n");
    556                  return -1;
   \       0x16   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1A   0xE023             B.N      ??at_read_1
    557              }
    558          
    559              HAL_MutexLock(at.at_uart_recv_mutex);
   \                     ??at_read_0: (+1)
   \       0x1C   0x....'....        LDR.W    R8,??DataTable20_1
   \       0x20   0xF8D8 0x00B8      LDR      R0,[R8, #+184]
   \       0x24   0x....'....        BL       HAL_MutexLock
    560              while (total_read < readsize) {
   \                     ??at_read_2: (+1)
   \       0x28   0x42B7             CMP      R7,R6
   \       0x2A   0xD211             BCS.N    ??at_read_3
    561                  ret = at_recvfrom_lower(at._pstuart, (void *)(outbuf + total_read),
    562                                          readsize - total_read, &recv_size, at._timeout);
   \       0x2C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x30   0x9000             STR      R0,[SP, #+0]
   \       0x32   0xAB01             ADD      R3,SP,#+4
   \       0x34   0x1BF2             SUBS     R2,R6,R7
   \       0x36   0x19E9             ADDS     R1,R5,R7
   \       0x38   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x3C   0x....'....        BL       at_recvfrom_lower
   \       0x40   0x0004             MOVS     R4,R0
    563                  if (ret != 0) {
   \       0x42   0xD105             BNE.N    ??at_read_3
    564                      atpsr_err("at_read failed on uart_recv.");
    565                      break;
    566                  }
    567          
    568                  if (recv_size <= 0) {
   \       0x44   0x9801             LDR      R0,[SP, #+4]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD0EE             BEQ.N    ??at_read_2
    569                      continue;
    570                  }
    571                  total_read += recv_size;
   \       0x4A   0x19C7             ADDS     R7,R0,R7
    572                  if (total_read >= readsize) {
   \       0x4C   0x42B7             CMP      R7,R6
   \       0x4E   0xD3EB             BCC.N    ??at_read_2
    573                      break;
    574                  }
    575              }
    576              HAL_MutexUnlock(at.at_uart_recv_mutex);
   \                     ??at_read_3: (+1)
   \       0x50   0xF8D8 0x00B8      LDR      R0,[R8, #+184]
   \       0x54   0x....'....        BL       HAL_MutexUnlock
    577          
    578              if (ret != 0) {
   \       0x58   0x2C00             CMP      R4,#+0
   \       0x5A   0xD002             BEQ.N    ??at_read_4
    579                  return -1;
   \       0x5C   0xF04F 0x30FF      MOV      R0,#-1
   \       0x60   0xE000             B.N      ??at_read_1
    580              }
    581          
    582              return total_read;
   \                     ??at_read_4: (+1)
   \       0x62   0x4638             MOV      R0,R7
   \                     ??at_read_1: (+1)
   \       0x64   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    583          }
    584          
    585          #define RECV_BUFFER_SIZE 512

   \                                 In section .bss, align 4
    586          static char at_rx_buf[RECV_BUFFER_SIZE];
   \                     at_rx_buf:
   \        0x0                      DS8 512

   \                                 In section .text, align 2, keep-with-next
    587          int at_register_callback(const char *prefix, const char *postfix, char *recvbuf,
    588                                   int bufsize, at_recv_cb cb, void *arg)
    589          {
   \                     at_register_callback: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x461E             MOV      R6,R3
    590              oob_t *oob = NULL;
    591              int    i   = 0;
   \        0xC   0xF04F 0x0800      MOV      R8,#+0
    592          
    593              if (bufsize < 0 || bufsize >= RECV_BUFFER_SIZE || NULL == prefix) {
   \       0x10   0xF5B6 0x7F00      CMP      R6,#+512
   \       0x14   0xD225             BCS.N    ??at_register_callback_0
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD023             BEQ.N    ??at_register_callback_0
    594                  atpsr_err("%s invalid input \r\n", __func__);
    595                  return -1;
    596              }
    597          
    598              if (NULL != postfix && (NULL == recvbuf || 0 == bufsize)) {
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD003             BEQ.N    ??at_register_callback_1
   \       0x1E   0x2F00             CMP      R7,#+0
   \       0x20   0xD01F             BEQ.N    ??at_register_callback_0
   \       0x22   0x2E00             CMP      R6,#+0
   \       0x24   0xD01D             BEQ.N    ??at_register_callback_0
    599                  atpsr_err("%s invalid postfix input \r\n", __func__);
    600                  return -1;
    601              }
    602          
    603              if (at._oobs_num >= OOB_MAX) {
   \                     ??at_register_callback_1: (+1)
   \       0x26   0x....'....        LDR.W    R9,??DataTable20_1
   \       0x2A   0xF8D9 0x00B4      LDR      R0,[R9, #+180]
   \       0x2E   0x2805             CMP      R0,#+5
   \       0x30   0xDB02             BLT.N    ??at_register_callback_2
   \       0x32   0xE016             B.N      ??at_register_callback_0
    604                  atpsr_err("No place left in OOB.\r\n");
    605                  return -1;
    606              }
    607          
    608              /*check oob exist*/
    609              for (i = 0; i < at._oobs_num; i++) {
   \                     ??at_register_callback_3: (+1)
   \       0x34   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??at_register_callback_2: (+1)
   \       0x38   0xF8D9 0x00B4      LDR      R0,[R9, #+180]
   \       0x3C   0x4580             CMP      R8,R0
   \       0x3E   0xDA13             BGE.N    ??at_register_callback_4
    610                  if (NULL != at._oobs[i].prefix &&
    611                      strcmp(prefix, at._oobs[i].prefix) == 0) {
   \       0x40   0x211C             MOVS     R1,#+28
   \       0x42   0xFB01 0xF008      MUL      R0,R1,R8
   \       0x46   0x4448             ADD      R0,R9,R0
   \       0x48   0x6A80             LDR      R0,[R0, #+40]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD0F2             BEQ.N    ??at_register_callback_3
   \       0x4E   0xFB01 0xF108      MUL      R1,R1,R8
   \       0x52   0xEB09 0x0001      ADD      R0,R9,R1
   \       0x56   0x6A81             LDR      R1,[R0, #+40]
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x....'....        BL       strcmp
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD1E8             BNE.N    ??at_register_callback_3
    612                      atpsr_warning("oob prefix %s is already exist.\r\n", prefix);
    613                      return -1;
   \                     ??at_register_callback_0: (+1)
   \       0x62   0xF04F 0x30FF      MOV      R0,#-1
   \       0x66   0xE022             B.N      ??at_register_callback_5
    614                  }
    615              }
    616          
    617              oob = &(at._oobs[at._oobs_num++]);
   \                     ??at_register_callback_4: (+1)
   \       0x68   0xEBC0 0x01C0      RSB      R1,R0,R0, LSL #+3
   \       0x6C   0xEB09 0x0081      ADD      R0,R9,R1, LSL #+2
   \       0x70   0xF100 0x0828      ADD      R8,R0,#+40
   \       0x74   0xF8D9 0x00B4      LDR      R0,[R9, #+180]
   \       0x78   0x1C40             ADDS     R0,R0,#+1
   \       0x7A   0xF8C9 0x00B4      STR      R0,[R9, #+180]
    618          
    619              oob->oobinputdata = recvbuf;
   \       0x7E   0xF8C8 0x7008      STR      R7,[R8, #+8]
    620              if (oob->oobinputdata != NULL) {
   \       0x82   0x4638             MOV      R0,R7
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD003             BEQ.N    ??at_register_callback_6
    621                  memset(oob->oobinputdata, 0, bufsize);
   \       0x88   0x2200             MOVS     R2,#+0
   \       0x8A   0x4631             MOV      R1,R6
   \       0x8C   0x....'....        BL       __aeabi_memset
    622              }
   \                     ??at_register_callback_6: (+1)
   \       0x90   0x9909             LDR      R1,[SP, #+36]
   \       0x92   0x9808             LDR      R0,[SP, #+32]
    623              oob->maxlen  = bufsize;
   \       0x94   0xF8C8 0x6010      STR      R6,[R8, #+16]
    624              oob->prefix  = (char *)prefix;
   \       0x98   0xF8C8 0x4000      STR      R4,[R8, #+0]
    625              oob->postfix = (char *)postfix;
   \       0x9C   0xF8C8 0x5004      STR      R5,[R8, #+4]
    626              oob->cb      = cb;
   \       0xA0   0xF8C8 0x0014      STR      R0,[R8, #+20]
    627              oob->arg     = arg;
   \       0xA4   0xF8C8 0x1018      STR      R1,[R8, #+24]
    628              oob->reallen = 0;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xF8C8 0x000C      STR      R0,[R8, #+12]
    629          
    630              atpsr_debug("New oob registered (%s)", oob->prefix);
    631          
    632              return 0;
   \                     ??at_register_callback_5: (+1)
   \       0xAE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    633          }
    634          

   \                                 In section .text, align 2, keep-with-next
    635          static void at_scan_for_callback(char c, char *buf, int *index)
    636          {
   \                     at_scan_for_callback: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
    637              int     k;
    638              oob_t  *oob = NULL;
    639              int offset = *index;
   \        0xA   0xF8D6 0x8000      LDR      R8,[R6, #+0]
    640          
    641              if (!buf || offset < 0) {
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xF000 0x80B1      BEQ.W    ??at_scan_for_callback_0
   \       0x14   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x18   0xF100 0x80AD      BMI.W    ??at_scan_for_callback_0
    642                  return;
    643              }
    644          
    645              for (k = 0; k < at._oobs_num; k++) {
   \       0x1C   0xF04F 0x0900      MOV      R9,#+0
   \       0x20   0xE072             B.N      ??at_scan_for_callback_1
    646                  oob = &(at._oobs[k]);
    647                  if (oob->reallen > 0 ||
    648                      (offset >= strlen(oob->prefix) &&
    649                       memcmp(oob->prefix, buf + offset - strlen(oob->prefix),
    650                              strlen(oob->prefix)) == 0)) {
    651                      atpsr_debug("AT! %s\r\n", oob->prefix);
    652                      if (oob->postfix == NULL) {
    653                          oob->cb(oob->arg, NULL, 0);
    654                          memset(buf, 0, offset);
    655                          offset = 0;
    656                      } else {
    657                          if (oob->reallen == 0) {
    658                              int len = strlen(oob->prefix) - 1;
    659                              len = len > 0 ? len : 0;
    660                              memset(oob->oobinputdata, 0, oob->maxlen);
    661                              memcpy(oob->oobinputdata, oob->prefix, len);
    662                              oob->reallen += len;
    663                          }
    664          
    665                          if (oob->reallen < oob->maxlen) {
    666                                  oob->oobinputdata[oob->reallen] = c;
    667                                  oob->reallen++;
    668                                  if ((oob->reallen >=
    669                                       strlen(oob->prefix) + strlen(oob->postfix)) &&
    670                                      (strncmp(oob->oobinputdata + oob->reallen -
    671                                                 strlen(oob->postfix),
    672                                               oob->postfix,
    673                                               strlen(oob->postfix)) == 0)) {
    674                                      /*recv postfix*/
    675                                      oob->cb(oob->arg, oob->oobinputdata, oob->reallen);
    676                                      memset(oob->oobinputdata, 0, oob->reallen);
    677                                      oob->reallen = 0;
    678                                      memset(buf, 0, offset);
    679                                      offset = 0;
    680                                  }
    681                              } else {
    682                                  atpsr_err("invalid oob %s input , for oversize %s \r\n",
    683                                             oob->prefix, oob->oobinputdata);
    684                                  memset(oob->oobinputdata, 0, oob->reallen);
   \                     ??at_scan_for_callback_2: (+1)
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x4601             MOV      R1,R0
   \       0x26   0x68A0             LDR      R0,[R4, #+8]
   \       0x28   0x....'....        BL       __aeabi_memset
    685                                  oob->reallen = 0;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x60E0             STR      R0,[R4, #+12]
    686                                  memset(buf, 0, offset);
   \       0x30   0x4602             MOV      R2,R0
   \       0x32   0x4641             MOV      R1,R8
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x....'....        BL       __aeabi_memset
    687                                  offset = 0;
   \       0x3A   0xF04F 0x0800      MOV      R8,#+0
   \       0x3E   0xE056             B.N      ??at_scan_for_callback_3
    688                              }
   \                     ??at_scan_for_callback_4: (+1)
   \       0x40   0x68E0             LDR      R0,[R4, #+12]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD118             BNE.N    ??at_scan_for_callback_5
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x....'....        BL       strlen
   \       0x4C   0x4682             MOV      R10,R0
   \       0x4E   0xF1AA 0x0A01      SUB      R10,R10,#+1
   \       0x52   0xF1BA 0x0F01      CMP      R10,#+1
   \       0x56   0xDA01             BGE.N    ??at_scan_for_callback_6
   \       0x58   0xF04F 0x0A00      MOV      R10,#+0
   \                     ??at_scan_for_callback_6: (+1)
   \       0x5C   0x2200             MOVS     R2,#+0
   \       0x5E   0x6921             LDR      R1,[R4, #+16]
   \       0x60   0x68A0             LDR      R0,[R4, #+8]
   \       0x62   0x....'....        BL       __aeabi_memset
   \       0x66   0x4652             MOV      R2,R10
   \       0x68   0x6821             LDR      R1,[R4, #+0]
   \       0x6A   0x68A0             LDR      R0,[R4, #+8]
   \       0x6C   0x....'....        BL       __aeabi_memcpy
   \       0x70   0x68E0             LDR      R0,[R4, #+12]
   \       0x72   0x4482             ADD      R10,R10,R0
   \       0x74   0xF8C4 0xA00C      STR      R10,[R4, #+12]
   \                     ??at_scan_for_callback_5: (+1)
   \       0x78   0x68E0             LDR      R0,[R4, #+12]
   \       0x7A   0x6921             LDR      R1,[R4, #+16]
   \       0x7C   0x4288             CMP      R0,R1
   \       0x7E   0xD2D0             BCS.N    ??at_scan_for_callback_2
   \       0x80   0x68A0             LDR      R0,[R4, #+8]
   \       0x82   0x68E1             LDR      R1,[R4, #+12]
   \       0x84   0x5447             STRB     R7,[R0, R1]
   \       0x86   0x68E0             LDR      R0,[R4, #+12]
   \       0x88   0x1C40             ADDS     R0,R0,#+1
   \       0x8A   0x60E0             STR      R0,[R4, #+12]
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x....'....        BL       strlen
   \       0x92   0x4682             MOV      R10,R0
   \       0x94   0x6860             LDR      R0,[R4, #+4]
   \       0x96   0x....'....        BL       strlen
   \       0x9A   0x68E1             LDR      R1,[R4, #+12]
   \       0x9C   0x4482             ADD      R10,R0,R10
   \       0x9E   0x4551             CMP      R1,R10
   \       0xA0   0xD325             BCC.N    ??at_scan_for_callback_3
   \       0xA2   0x6860             LDR      R0,[R4, #+4]
   \       0xA4   0x....'....        BL       strlen
   \       0xA8   0x4682             MOV      R10,R0
   \       0xAA   0x6860             LDR      R0,[R4, #+4]
   \       0xAC   0x....'....        BL       strlen
   \       0xB0   0x4652             MOV      R2,R10
   \       0xB2   0x6861             LDR      R1,[R4, #+4]
   \       0xB4   0x68A3             LDR      R3,[R4, #+8]
   \       0xB6   0xF8D4 0xC00C      LDR      R12,[R4, #+12]
   \       0xBA   0x4463             ADD      R3,R3,R12
   \       0xBC   0x4240             RSBS     R0,R0,#+0
   \       0xBE   0x4418             ADD      R0,R3,R0
   \       0xC0   0x....'....        BL       strncmp
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD112             BNE.N    ??at_scan_for_callback_3
   \       0xC8   0x68E2             LDR      R2,[R4, #+12]
   \       0xCA   0x68A1             LDR      R1,[R4, #+8]
   \       0xCC   0x69A0             LDR      R0,[R4, #+24]
   \       0xCE   0x6963             LDR      R3,[R4, #+20]
   \       0xD0   0x4798             BLX      R3
   \       0xD2   0x2200             MOVS     R2,#+0
   \       0xD4   0x68E1             LDR      R1,[R4, #+12]
   \       0xD6   0x68A0             LDR      R0,[R4, #+8]
   \       0xD8   0x....'....        BL       __aeabi_memset
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0x60E0             STR      R0,[R4, #+12]
   \       0xE0   0x4602             MOV      R2,R0
   \       0xE2   0x4641             MOV      R1,R8
   \       0xE4   0x4628             MOV      R0,R5
   \       0xE6   0x....'....        BL       __aeabi_memset
   \       0xEA   0xF04F 0x0800      MOV      R8,#+0
    689          
    690                          /*oob data maybe more than buf size */
    691                          if (offset > (RECV_BUFFER_SIZE - 2)) {
   \                     ??at_scan_for_callback_3: (+1)
   \       0xEE   0xF240 0x10FF      MOVW     R0,#+511
   \       0xF2   0x4580             CMP      R8,R0
   \       0xF4   0xDB06             BLT.N    ??at_scan_for_callback_7
    692                              memset(buf, 0, offset);
   \       0xF6   0x2200             MOVS     R2,#+0
   \       0xF8   0x4641             MOV      R1,R8
   \       0xFA   0x4628             MOV      R0,R5
   \       0xFC   0x....'....        BL       __aeabi_memset
    693                              offset = 0;
   \      0x100   0xF04F 0x0800      MOV      R8,#+0
    694                          }
    695                      }
   \                     ??at_scan_for_callback_7: (+1)
   \      0x104   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??at_scan_for_callback_1: (+1)
   \      0x108   0x....             LDR.N    R0,??DataTable20_1
   \      0x10A   0xF8D0 0x10B4      LDR      R1,[R0, #+180]
   \      0x10E   0x4589             CMP      R9,R1
   \      0x110   0xDA2F             BGE.N    ??at_scan_for_callback_8
   \      0x112   0xEBC9 0x01C9      RSB      R1,R9,R9, LSL #+3
   \      0x116   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \      0x11A   0xF100 0x0428      ADD      R4,R0,#+40
   \      0x11E   0x68E0             LDR      R0,[R4, #+12]
   \      0x120   0x2800             CMP      R0,#+0
   \      0x122   0xD115             BNE.N    ??at_scan_for_callback_9
   \      0x124   0x6820             LDR      R0,[R4, #+0]
   \      0x126   0x....'....        BL       strlen
   \      0x12A   0x4580             CMP      R8,R0
   \      0x12C   0xD3EA             BCC.N    ??at_scan_for_callback_7
   \      0x12E   0x6820             LDR      R0,[R4, #+0]
   \      0x130   0x....'....        BL       strlen
   \      0x134   0x4682             MOV      R10,R0
   \      0x136   0x6820             LDR      R0,[R4, #+0]
   \      0x138   0x....'....        BL       strlen
   \      0x13C   0x4652             MOV      R2,R10
   \      0x13E   0xEB05 0x0108      ADD      R1,R5,R8
   \      0x142   0x4240             RSBS     R0,R0,#+0
   \      0x144   0x4401             ADD      R1,R1,R0
   \      0x146   0x6820             LDR      R0,[R4, #+0]
   \      0x148   0x....'....        BL       memcmp
   \      0x14C   0x2800             CMP      R0,#+0
   \      0x14E   0xD1D9             BNE.N    ??at_scan_for_callback_7
   \                     ??at_scan_for_callback_9: (+1)
   \      0x150   0x6860             LDR      R0,[R4, #+4]
   \      0x152   0x2800             CMP      R0,#+0
   \      0x154   0xF47F 0xAF74      BNE.W    ??at_scan_for_callback_4
   \      0x158   0x2200             MOVS     R2,#+0
   \      0x15A   0x4611             MOV      R1,R2
   \      0x15C   0x69A0             LDR      R0,[R4, #+24]
   \      0x15E   0x6963             LDR      R3,[R4, #+20]
   \      0x160   0x4798             BLX      R3
   \      0x162   0x2200             MOVS     R2,#+0
   \      0x164   0x4641             MOV      R1,R8
   \      0x166   0x4628             MOV      R0,R5
   \      0x168   0x....'....        BL       __aeabi_memset
   \      0x16C   0xF04F 0x0800      MOV      R8,#+0
   \      0x170   0xE7C8             B.N      ??at_scan_for_callback_7
    696                      continue;
    697                  }
    698              }
    699          
    700              *index = offset;
   \                     ??at_scan_for_callback_8: (+1)
   \      0x172   0xF8C6 0x8000      STR      R8,[R6, #+0]
    701              return;
   \                     ??at_scan_for_callback_0: (+1)
   \      0x176   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    702          }
    703          
    704          #if AT_SINGLE_TASK
    705          int at_yield(char *replybuf, int bufsize, const atcmd_config_t *atcmdconfig,
    706                       int timeout_ms)
    707          {
    708              int        offset                  = 0;
    709              int        ret                     = 0;
    710              int        rsp_prefix_len          = 0;
    711              int        rsp_success_postfix_len = 0;
    712              int        rsp_fail_postfix_len    = 0;
    713              int        at_reply_begin          = 0;
    714              int        at_reply_offset         = 0;
    715              char       c                       = 0;
    716              char      *buf                 = NULL;
    717              char      *rsp_prefix          = NULL;
    718              char      *rsp_success_postfix = NULL;
    719              char      *rsp_fail_postfix    = NULL;
    720          
    721              if (!inited) {
    722                  atpsr_err("AT parser has not inited!\r\n");
    723                  return -1;
    724              }
    725          
    726              if (replybuf != NULL && bufsize <= 0) {
    727                  atpsr_err("buffer size %d unmatched!\r\n", bufsize);
    728                  return -1;
    729              }
    730          
    731              buf = at_rx_buf;
    732              if (NULL == buf) {
    733                  atpsr_err("AT worker fail to malloc ,task exist \r\n");
    734                  return -1;
    735              }
    736          
    737              memset(buf, 0, RECV_BUFFER_SIZE);
    738          
    739              while (true) {
    740                  /* read from uart and store buf */
    741                  ret = at_getc(&c, timeout_ms);
    742                  if (ret != 0) {
    743                      atpsr_err("at yield timeout break loop");
    744                      break;
    745                  }
    746          
    747                  if (offset + 1 >= RECV_BUFFER_SIZE) {
    748                      atpsr_err("buffer full");
    749                      break;
    750                  }
    751                  buf[offset++] = c;
    752                  buf[offset]   = 0;
    753          
    754                  at_scan_for_callback(c, buf, &offset);
    755          
    756                  if (replybuf == NULL || bufsize <= 0) {
    757                      /* if no task, continue recv */
    758                      continue;
    759                  }
    760          
    761                  if (NULL != atcmdconfig && NULL != atcmdconfig->reply_prefix) {
    762                      rsp_prefix     = atcmdconfig->reply_prefix;
    763                      rsp_prefix_len = strlen(rsp_prefix);
    764                  } else {
    765                      rsp_prefix     = at._default_recv_prefix;
    766                      rsp_prefix_len = at._recv_prefix_len;
    767                  }
    768          
    769                  if (NULL != atcmdconfig && NULL != atcmdconfig->reply_success_postfix) {
    770                      rsp_success_postfix     = atcmdconfig->reply_success_postfix;
    771                      rsp_success_postfix_len = strlen(rsp_success_postfix);
    772                  } else {
    773                      rsp_success_postfix     = at._default_recv_success_postfix;
    774                      rsp_success_postfix_len = at._recv_success_postfix_len;
    775                  }
    776          
    777                  if (NULL != atcmdconfig && NULL != atcmdconfig->reply_fail_postfix) {
    778                      rsp_fail_postfix     = atcmdconfig->reply_fail_postfix;
    779                      rsp_fail_postfix_len = strlen(rsp_fail_postfix);
    780                  } else {
    781                      rsp_fail_postfix     = at._default_recv_fail_postfix;
    782                      rsp_fail_postfix_len = at._recv_fail_postfix_len;
    783                  }
    784          
    785                  if (offset >= rsp_prefix_len && at_reply_begin == 0 &&
    786                      (strncmp(buf + offset - rsp_prefix_len, rsp_prefix,
    787                               rsp_prefix_len) == 0)) {
    788                      at_reply_begin = 1;
    789                  }
    790          
    791                  if (at_reply_begin == 1) {
    792                      if (at_reply_offset < bufsize) {
    793                          replybuf[at_reply_offset] = c;
    794                          at_reply_offset++;
    795          
    796                          if ((at_reply_offset >= rsp_success_postfix_len &&
    797                               strncmp(
    798                                 replybuf + at_reply_offset - rsp_success_postfix_len,
    799                                 rsp_success_postfix, rsp_success_postfix_len) == 0) ||
    800                              (at_reply_offset >= rsp_fail_postfix_len &&
    801                               strncmp(replybuf + at_reply_offset - rsp_fail_postfix_len,
    802                                       rsp_fail_postfix, rsp_fail_postfix_len) == 0)) {
    803                              return 0;
    804                          }
    805                      } else {
    806                          memset(replybuf, 0, bufsize);
    807                          strcpy(replybuf, rsp_fail_postfix);
    808                          break;
    809                      }
    810                  }
    811          
    812              }
    813          
    814              return -1;
    815          }
    816          #else

   \                                 In section .text, align 4, keep-with-next
    817          static void* at_worker(void *arg)
    818          {
   \                     at_worker: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
    819              int        offset                  = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9001             STR      R0,[SP, #+4]
    820              int        ret                     = 0;
    821              int        at_task_empty           = 0;
    822              int        at_task_reponse_begin   = 0;
   \        0x8   0x4605             MOV      R5,R0
    823              int        memcpy_size             = 0;
    824              int        rsp_prefix_len          = 0;
   \        0xA   0x4606             MOV      R6,R0
    825              int        rsp_success_postfix_len = 0;
   \        0xC   0x4607             MOV      R7,R0
    826              int        rsp_fail_postfix_len    = 0;
   \        0xE   0x4680             MOV      R8,R0
    827              char       c                       = 0;
   \       0x10   0xF88D 0x0000      STRB     R0,[SP, #+0]
    828              at_task_t *tsk;
    829              char      *buf                 = NULL;
    830              char      *rsp_prefix          = NULL;
    831              char      *rsp_success_postfix = NULL;
    832              char      *rsp_fail_postfix    = NULL;
    833          
    834              atpsr_debug("at_work started.");
    835          
    836              buf = at_rx_buf;
   \       0x14   0x....'....        LDR.W    R9,??DataTable20_6
    837              if (NULL == buf) {
    838                  atpsr_err("AT worker fail to malloc ,task exist \r\n");
    839                  return NULL;
    840              }
    841          
    842              memset(buf, 0, RECV_BUFFER_SIZE);
   \       0x18   0x4602             MOV      R2,R0
   \       0x1A   0xF44F 0x7100      MOV      R1,#+512
   \       0x1E   0x4648             MOV      R0,R9
   \       0x20   0x....'....        BL       __aeabi_memset
    843              inited = 1;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x....             LDR.N    R1,??DataTable20_4
   \       0x28   0x7008             STRB     R0,[R1, #+0]
   \       0x2A   0x....'....        LDR.W    R10,??DataTable20_1
   \       0x2E   0xE0BC             B.N      ??at_worker_0
    844          
    845              while (true) {
    846                  ret = at_getc(&c, at._timeout);
    847                  if (ret != 0) {
    848                      continue;
    849                  }
    850          
    851                  if (offset + 1 >= RECV_BUFFER_SIZE) {
    852                      atpsr_err("Fatal error, no one is handling AT uart");
    853                      goto check_buffer;
    854                  }
    855                  buf[offset++] = c;
    856                  buf[offset]   = 0;
    857          
    858                  at_scan_for_callback(c, buf, &offset);
    859          
    860                  HAL_MutexLock(at.task_mutex);
    861                  at_task_empty = slist_empty(&at.task_l);
    862          
    863                  if (!at_task_empty) {
    864                      tsk = slist_first_entry(&at.task_l, at_task_t, next);
    865                  }
    866                  HAL_MutexUnlock(at.task_mutex);
    867          
    868                  /* if no task, continue recv */
    869                  if (at_task_empty) {
    870                      atpsr_debug("No task in queue");
    871                      goto check_buffer;
    872                  }
    873          
    874                  if (NULL != tsk->rsp_prefix && 0 != tsk->rsp_prefix_len) {
    875                      rsp_prefix     = tsk->rsp_prefix;
    876                      rsp_prefix_len = tsk->rsp_prefix_len;
    877                  } else {
    878                      rsp_prefix     = at._default_recv_prefix;
    879                      rsp_prefix_len = at._recv_prefix_len;
    880                  }
    881          
    882                  if (NULL != tsk->rsp_success_postfix &&
    883                      0 != tsk->rsp_success_postfix_len) {
    884                      rsp_success_postfix     = tsk->rsp_success_postfix;
    885                      rsp_success_postfix_len = tsk->rsp_success_postfix_len;
    886                  } else {
    887                      rsp_success_postfix     = at._default_recv_success_postfix;
    888                      rsp_success_postfix_len = at._recv_success_postfix_len;
    889                  }
    890          
    891                  if (NULL != tsk->rsp_fail_postfix && 0 != tsk->rsp_fail_postfix_len) {
    892                      rsp_fail_postfix     = tsk->rsp_fail_postfix;
    893                      rsp_fail_postfix_len = tsk->rsp_fail_postfix_len;
    894                  } else {
    895                      rsp_fail_postfix     = at._default_recv_fail_postfix;
    896                      rsp_fail_postfix_len = at._recv_fail_postfix_len;
    897                  }
    898          
    899                  if (offset >= rsp_prefix_len && at_task_reponse_begin == 0 &&
    900                      (strncmp(buf + offset - rsp_prefix_len, rsp_prefix,
    901                               rsp_prefix_len) == 0)) {
    902                      at_task_reponse_begin = 1;
    903                  }
    904          
    905                  if (at_task_reponse_begin == 1) {
    906                      if (tsk->rsp_offset < tsk->rsp_len) {
    907                          tsk->rsp[tsk->rsp_offset] = c;
    908                          tsk->rsp_offset++;
    909          
    910                          if ((tsk->rsp_offset >= rsp_success_postfix_len &&
    911                               strncmp(
    912                                 tsk->rsp + tsk->rsp_offset - rsp_success_postfix_len,
    913                                 rsp_success_postfix, rsp_success_postfix_len) == 0) ||
    914                              (tsk->rsp_offset >= rsp_fail_postfix_len &&
    915                               strncmp(tsk->rsp + tsk->rsp_offset - rsp_fail_postfix_len,
    916                                       rsp_fail_postfix, rsp_fail_postfix_len) == 0)) {
    917                              HAL_SemaphorePost(tsk->smpr);
    918                              at_task_reponse_begin = 0;
    919                              memset(buf, 0, offset);
    920                              offset = 0;
    921                          }
    922                      } else {
    923                          memset(tsk->rsp, 0, tsk->rsp_len);
   \                     ??at_worker_1: (+1)
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \       0x36   0x....'....        BL       __aeabi_memset
    924                          strcpy(tsk->rsp, rsp_fail_postfix);
   \       0x3A   0x4621             MOV      R1,R4
   \       0x3C   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \       0x40   0x....'....        BL       strcpy
    925                          HAL_SemaphorePost(tsk->smpr);
   \       0x44   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \       0x48   0x....'....        BL       HAL_SemaphorePost
    926                          at_task_reponse_begin = 0;
   \       0x4C   0x2500             MOVS     R5,#+0
    927                          memset(buf, 0, offset);
   \       0x4E   0x462A             MOV      R2,R5
   \       0x50   0x9901             LDR      R1,[SP, #+4]
   \       0x52   0x4648             MOV      R0,R9
   \       0x54   0x....'....        BL       __aeabi_memset
    928                          offset = 0;
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x9001             STR      R0,[SP, #+4]
   \       0x5C   0xE08A             B.N      ??at_worker_2
    929                      }
   \                     ??at_worker_3: (+1)
   \       0x5E   0xF04F 0x0B00      MOV      R11,#+0
   \                     ??at_worker_4: (+1)
   \       0x62   0xF8DA 0x00C0      LDR      R0,[R10, #+192]
   \       0x66   0x....'....        BL       HAL_MutexUnlock
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xF040 0x8082      BNE.W    ??at_worker_2
   \       0x70   0xF8DB 0x0010      LDR      R0,[R11, #+16]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD007             BEQ.N    ??at_worker_5
   \       0x78   0xF8DB 0x001C      LDR      R0,[R11, #+28]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD003             BEQ.N    ??at_worker_5
   \       0x80   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \       0x84   0x4606             MOV      R6,R0
   \       0x86   0xE003             B.N      ??at_worker_6
   \                     ??at_worker_5: (+1)
   \       0x88   0xF8DA 0x1008      LDR      R1,[R10, #+8]
   \       0x8C   0xF8DA 0x6018      LDR      R6,[R10, #+24]
   \                     ??at_worker_6: (+1)
   \       0x90   0xF8DB 0x0014      LDR      R0,[R11, #+20]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD009             BEQ.N    ??at_worker_7
   \       0x98   0xF8DB 0x0020      LDR      R0,[R11, #+32]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD005             BEQ.N    ??at_worker_7
   \       0xA0   0xF8DB 0x0014      LDR      R0,[R11, #+20]
   \       0xA4   0x9002             STR      R0,[SP, #+8]
   \       0xA6   0xF8DB 0x7020      LDR      R7,[R11, #+32]
   \       0xAA   0xE004             B.N      ??at_worker_8
   \                     ??at_worker_7: (+1)
   \       0xAC   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \       0xB0   0x9002             STR      R0,[SP, #+8]
   \       0xB2   0xF8DA 0x701C      LDR      R7,[R10, #+28]
   \                     ??at_worker_8: (+1)
   \       0xB6   0xF8DB 0x0018      LDR      R0,[R11, #+24]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD007             BEQ.N    ??at_worker_9
   \       0xBE   0xF8DB 0x0024      LDR      R0,[R11, #+36]
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD003             BEQ.N    ??at_worker_9
   \       0xC6   0xF8DB 0x4018      LDR      R4,[R11, #+24]
   \       0xCA   0x4680             MOV      R8,R0
   \       0xCC   0xE003             B.N      ??at_worker_10
   \                     ??at_worker_9: (+1)
   \       0xCE   0xF8DA 0x4010      LDR      R4,[R10, #+16]
   \       0xD2   0xF8DA 0x8020      LDR      R8,[R10, #+32]
   \                     ??at_worker_10: (+1)
   \       0xD6   0x9801             LDR      R0,[SP, #+4]
   \       0xD8   0x42B0             CMP      R0,R6
   \       0xDA   0xDB0A             BLT.N    ??at_worker_11
   \       0xDC   0x2D00             CMP      R5,#+0
   \       0xDE   0xD108             BNE.N    ??at_worker_11
   \       0xE0   0x4632             MOV      R2,R6
   \       0xE2   0x4448             ADD      R0,R9,R0
   \       0xE4   0x4273             RSBS     R3,R6,#+0
   \       0xE6   0x4418             ADD      R0,R0,R3
   \       0xE8   0x....'....        BL       strncmp
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD100             BNE.N    ??at_worker_11
   \       0xF0   0x2501             MOVS     R5,#+1
   \                     ??at_worker_11: (+1)
   \       0xF2   0x2D01             CMP      R5,#+1
   \       0xF4   0xD13E             BNE.N    ??at_worker_2
   \       0xF6   0xF8DB 0x0028      LDR      R0,[R11, #+40]
   \       0xFA   0xF8DB 0x102C      LDR      R1,[R11, #+44]
   \       0xFE   0x4288             CMP      R0,R1
   \      0x100   0xD296             BCS.N    ??at_worker_1
   \      0x102   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x106   0xF8DB 0x100C      LDR      R1,[R11, #+12]
   \      0x10A   0xF8DB 0x2028      LDR      R2,[R11, #+40]
   \      0x10E   0x5488             STRB     R0,[R1, R2]
   \      0x110   0xF8DB 0x0028      LDR      R0,[R11, #+40]
   \      0x114   0x1C40             ADDS     R0,R0,#+1
   \      0x116   0xF8CB 0x0028      STR      R0,[R11, #+40]
   \      0x11A   0x42B8             CMP      R0,R7
   \      0x11C   0xD30C             BCC.N    ??at_worker_12
   \      0x11E   0x463A             MOV      R2,R7
   \      0x120   0x9902             LDR      R1,[SP, #+8]
   \      0x122   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \      0x126   0xF8DB 0x3028      LDR      R3,[R11, #+40]
   \      0x12A   0x4418             ADD      R0,R0,R3
   \      0x12C   0x427B             RSBS     R3,R7,#+0
   \      0x12E   0x4418             ADD      R0,R0,R3
   \      0x130   0x....'....        BL       strncmp
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD011             BEQ.N    ??at_worker_13
   \                     ??at_worker_12: (+1)
   \      0x138   0xF8DB 0x0028      LDR      R0,[R11, #+40]
   \      0x13C   0x4540             CMP      R0,R8
   \      0x13E   0xD319             BCC.N    ??at_worker_2
   \      0x140   0x4642             MOV      R2,R8
   \      0x142   0x4621             MOV      R1,R4
   \      0x144   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \      0x148   0xF8DB 0x3028      LDR      R3,[R11, #+40]
   \      0x14C   0x4418             ADD      R0,R0,R3
   \      0x14E   0xF1C8 0x0300      RSB      R3,R8,#+0
   \      0x152   0x4418             ADD      R0,R0,R3
   \      0x154   0x....'....        BL       strncmp
   \      0x158   0x2800             CMP      R0,#+0
   \      0x15A   0xD10B             BNE.N    ??at_worker_2
   \                     ??at_worker_13: (+1)
   \      0x15C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0x160   0x....'....        BL       HAL_SemaphorePost
   \      0x164   0x2500             MOVS     R5,#+0
   \      0x166   0x462A             MOV      R2,R5
   \      0x168   0x9901             LDR      R1,[SP, #+4]
   \      0x16A   0x4648             MOV      R0,R9
   \      0x16C   0x....'....        BL       __aeabi_memset
   \      0x170   0x4628             MOV      R0,R5
   \      0x172   0x9001             STR      R0,[SP, #+4]
    930                  }
    931              check_buffer:
    932                  /* in case buffer is full */
    933                  if (offset > (RECV_BUFFER_SIZE - 2)) {
   \                     ??at_worker_2: (+1)
   \      0x174   0x9801             LDR      R0,[SP, #+4]
   \      0x176   0xF240 0x11FF      MOVW     R1,#+511
   \      0x17A   0x4288             CMP      R0,R1
   \      0x17C   0xDB15             BLT.N    ??at_worker_0
    934                      memcpy_size = rsp_prefix_len > rsp_success_postfix_len
    935                                      ? rsp_prefix_len
    936                                      : rsp_success_postfix_len;
   \      0x17E   0x4634             MOV      R4,R6
   \      0x180   0x42BE             CMP      R6,R7
   \      0x182   0xDA00             BGE.N    ??at_worker_14
   \      0x184   0x463C             MOV      R4,R7
    937                      memcpy_size = memcpy_size > rsp_fail_postfix_len
    938                                      ? memcpy_size
    939                                      : rsp_fail_postfix_len;
   \                     ??at_worker_14: (+1)
   \      0x186   0x4544             CMP      R4,R8
   \      0x188   0xDA00             BGE.N    ??at_worker_15
   \      0x18A   0x4644             MOV      R4,R8
    940                      memcpy(buf, buf + offset - memcpy_size, memcpy_size);
   \                     ??at_worker_15: (+1)
   \      0x18C   0x4622             MOV      R2,R4
   \      0x18E   0x4448             ADD      R0,R9,R0
   \      0x190   0x4261             RSBS     R1,R4,#+0
   \      0x192   0x4401             ADD      R1,R0,R1
   \      0x194   0x4648             MOV      R0,R9
   \      0x196   0x....'....        BL       __aeabi_memcpy
    941                      memset(buf + memcpy_size, 0, offset - memcpy_size);
   \      0x19A   0x2200             MOVS     R2,#+0
   \      0x19C   0x9901             LDR      R1,[SP, #+4]
   \      0x19E   0x1B09             SUBS     R1,R1,R4
   \      0x1A0   0xEB09 0x0004      ADD      R0,R9,R4
   \      0x1A4   0x....'....        BL       __aeabi_memset
    942                      offset = memcpy_size;
   \      0x1A8   0x9401             STR      R4,[SP, #+4]
    943                  }
   \                     ??at_worker_0: (+1)
   \      0x1AA   0xF8DA 0x1004      LDR      R1,[R10, #+4]
   \      0x1AE   0x4668             MOV      R0,SP
   \      0x1B0   0x....'....        BL       at_getc
   \      0x1B4   0x2800             CMP      R0,#+0
   \      0x1B6   0xD1F8             BNE.N    ??at_worker_0
   \      0x1B8   0x9801             LDR      R0,[SP, #+4]
   \      0x1BA   0x1C40             ADDS     R0,R0,#+1
   \      0x1BC   0xF5B0 0x7F00      CMP      R0,#+512
   \      0x1C0   0xDAD8             BGE.N    ??at_worker_2
   \      0x1C2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x1C6   0x9901             LDR      R1,[SP, #+4]
   \      0x1C8   0xF809 0x0001      STRB     R0,[R9, R1]
   \      0x1CC   0x9801             LDR      R0,[SP, #+4]
   \      0x1CE   0x1C40             ADDS     R0,R0,#+1
   \      0x1D0   0x9001             STR      R0,[SP, #+4]
   \      0x1D2   0x2000             MOVS     R0,#+0
   \      0x1D4   0x9901             LDR      R1,[SP, #+4]
   \      0x1D6   0xF809 0x0001      STRB     R0,[R9, R1]
   \      0x1DA   0xAA01             ADD      R2,SP,#+4
   \      0x1DC   0x4649             MOV      R1,R9
   \      0x1DE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x1E2   0x....'....        BL       at_scan_for_callback
   \      0x1E6   0xF8DA 0x00C0      LDR      R0,[R10, #+192]
   \      0x1EA   0x....'....        BL       HAL_MutexLock
   \      0x1EE   0xF10A 0x00C4      ADD      R0,R10,#+196
   \      0x1F2   0x....'....        BL       slist_empty
   \      0x1F6   0x0004             MOVS     R4,R0
   \      0x1F8   0xF47F 0xAF33      BNE.W    ??at_worker_4
   \      0x1FC   0xF8DA 0x00C4      LDR      R0,[R10, #+196]
   \      0x200   0x2800             CMP      R0,#+0
   \      0x202   0xF43F 0xAF2C      BEQ.W    ??at_worker_3
   \      0x206   0x4683             MOV      R11,R0
   \      0x208   0xE72B             B.N      ??at_worker_4
    944              }
    945          
    946              return NULL;
                     ^
Warning[Pe111]: statement is unreachable
    947          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x0D 0x00          DC8      "\r",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x....'....        DC32     at_uart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x....'....        DC32     at

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \        0x0   0x....'....        DC32     inited

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \        0x0   0x....'....        DC32     at_rx_buf

   \                                 In section .rodata, align 4
   \        0x0   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x4F 0x4B          DC8 "OK\015\012"
   \              0x0D 0x0A    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x45 0x52          DC8 "ERROR\015\012"
   \              0x52 0x4F    
   \              0x52 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 2
   \        0x0   0x0D 0x00          DC8 "\015"

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x61 0x74          DC8 "at_worker"
   \              0x5F 0x77    
   \              0x6F 0x72    
   \              0x6B 0x65    
   \              0x72 0x00    
   \        0xA   0x00 0x00          DC8 0, 0
    948          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   at_deinit_task_mutex
         0   -> HAL_MutexDestroy
       0   at_deinit_uart_recv_mutex
         0   -> HAL_MutexDestroy
      32   at_getc
        32   -> HAL_MutexLock
        32   -> HAL_MutexUnlock
        32   -> at_recvfrom_lower
       8   at_init_task_mutex
         8   -> HAL_MutexCreate
       8   at_init_uart
         8   -> HAL_AT_Uart_Init
         8   -> at_uart_configure
       8   at_init_uart_recv_mutex
         8   -> HAL_MutexCreate
      56   at_parser_init
        56   -> HAL_ThreadCreate
        56   -> __aeabi_memclr4
        56   -> __aeabi_memset4
        56   -> at_deinit_task_mutex
        56   -> at_deinit_uart_recv_mutex
        56   -> at_init_task_mutex
        56   -> at_init_uart
        56   -> at_init_uart_recv_mutex
        56   -> at_set_recv_delimiter
        56   -> at_set_send_delimiter
        56   -> at_set_timeout
        56   -> at_worker_uart_send_mutex_deinit
        56   -> at_worker_uart_send_mutex_init
        56   -> slist_init
      32   at_read
        32   -> HAL_MutexLock
        32   -> HAL_MutexUnlock
        32   -> at_recvfrom_lower
      16   at_recvfrom_lower
        16   -> HAL_AT_Uart_Recv
      32   at_register_callback
        32   -> __aeabi_memset
        32   -> strcmp
      32   at_scan_for_callback
        32   -- Indirect call
        32   -> __aeabi_memcpy
        32   -> __aeabi_memset
        32   -> memcmp
        32   -> strlen
        32   -> strncmp
      24   at_send_no_reply
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> at_sendto_lower
        24   -> strlen
      48   at_send_wait_reply
        48   -> HAL_Malloc
        48   -> HAL_MutexLock
        48   -> HAL_MutexUnlock
        48   -> HAL_SemaphoreCreate
        48   -> HAL_SemaphoreWait
        48   -> HAL_SleepMs
        48   -> __aeabi_memset4
        48   -> at_sendto_lower
        48   -> at_worker_task_add
        48   -> at_worker_task_del
        48   -> strlen
       0   at_sendto_lower
         0   -> HAL_AT_Uart_Send
      16   at_set_recv_delimiter
        16   -> strlen
       8   at_set_send_delimiter
         8   -> strlen
       0   at_set_timeout
       0   at_uart_configure
      48   at_worker
        48   -> HAL_MutexLock
        48   -> HAL_MutexUnlock
        48   -> HAL_SemaphorePost
        48   -> __aeabi_memcpy
        48   -> __aeabi_memset
        48   -> at_getc
        48   -> at_scan_for_callback
        48   -> slist_empty
        48   -> strcpy
        48   -> strncmp
      16   at_worker_task_add
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> slist_add_tail
      16   at_worker_task_del
        16   -> HAL_Free
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> HAL_SemaphoreDestroy
        16   -> slist_del
       0   at_worker_uart_send_mutex_deinit
         0   -> HAL_MutexDestroy
       8   at_worker_uart_send_mutex_init
         8   -> HAL_MutexCreate
       0   slist_add
       0   slist_add_tail
         0   -> slist_add
       0   slist_del
       0   slist_empty
       0   slist_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ?_0
       8  ?_1
       8  ?_2
       2  ?_3
      12  ?_4
      20  ?_5
     200  at
      18  at_deinit_task_mutex
      18  at_deinit_uart_recv_mutex
     106  at_getc
      28  at_init_task_mutex
      38  at_init_uart
      28  at_init_uart_recv_mutex
     228  at_parser_init
     104  at_read
      12  at_recvfrom_lower
     178  at_register_callback
     512  at_rx_buf
     378  at_scan_for_callback
     120  at_send_no_reply
     314  at_send_wait_reply
       4  at_sendto_lower
      40  at_set_recv_delimiter
      16  at_set_send_delimiter
       8  at_set_timeout
      20  at_uart
      28  at_uart_configure
     522  at_worker
      46  at_worker_task_add
      62  at_worker_task_del
      18  at_worker_uart_send_mutex_deinit
      28  at_worker_uart_send_mutex_init
       1  inited
       8  slist_add
      12  slist_add_tail
      20  slist_del
      14  slist_empty
       6  slist_init

 
   733 bytes in section .bss
    54 bytes in section .rodata
 2 438 bytes in section .text
 
 2 438 bytes of CODE  memory
    54 bytes of CONST memory
   733 bytes of DATA  memory

Errors: none
Warnings: 2
