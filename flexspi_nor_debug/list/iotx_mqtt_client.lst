###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         26/Jun/2019  16:21:54
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\gzkc_smart_nbiot\csdk\eng\mqtt\iotx_mqtt_client.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\2\EW8A38.tmp
#        (C:\Development\gzkc_smart_nbiot\csdk\eng\mqtt\iotx_mqtt_client.c -D
#        DEBUG -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1
#        -D CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE
#        -D "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list -lA
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list --diag_suppress
#        Pa082,Pa050 -o C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\gzkc_smart_nbiot/source\app_preinclude.h -I
#        C:\Development\gzkc_smart_nbiot/board\ -I
#        C:\Development\gzkc_smart_nbiot/source\ -I
#        C:\Development\gzkc_smart_nbiot/CMSIS\ -I
#        C:\Development\gzkc_smart_nbiot/amazon-freertos/freertos/portable\ -I
#        C:\Development\gzkc_smart_nbiot/amazon-freertos/include\ -I
#        C:\Development\gzkc_smart_nbiot/component/lists\ -I
#        C:\Development\gzkc_smart_nbiot/component/serial_manager\ -I
#        C:\Development\gzkc_smart_nbiot/component/uart\ -I
#        C:\Development\gzkc_smart_nbiot/component/kv\ -I
#        C:\Development\gzkc_smart_nbiot/component/kv/include\ -I
#        C:\Development\gzkc_smart_nbiot/device\ -I
#        C:\Development\gzkc_smart_nbiot/doc\ -I
#        C:\Development\gzkc_smart_nbiot/drivers\ -I
#        C:\Development\gzkc_smart_nbiot/src\ -I
#        C:\Development\gzkc_smart_nbiot/startup\ -I
#        C:\Development\gzkc_smart_nbiot/utilities\ -I
#        C:\Development\gzkc_smart_nbiot/xip\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\atm\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_model\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_sign\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\infra\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\mqtt\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\external_libs\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_cloud\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\CoAPPacket\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\server\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\os\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\awss_reset\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\include\mbedtls\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\include\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list\iotx_mqtt_client.lst
#    Object file  =  
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\obj\iotx_mqtt_client.o
#
###############################################################################

C:\Development\gzkc_smart_nbiot\csdk\eng\mqtt\iotx_mqtt_client.c
      1          /*
      2           * Copyright (C) 2015-2018 Alibaba Group Holding Limited
      3           */
      4          #include "mqtt_internal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __dlist_add(dlist_t *, dlist_t *, dlist_t *)
   \                     __dlist_add: (+1)
   \        0x0   0x6042             STR      R2,[R0, #+4]
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0x6048             STR      R0,[R1, #+4]
   \        0x6   0x6010             STR      R0,[R2, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void dlist_add_tail(dlist_t *, dlist_t *)
   \                     dlist_add_tail: (+1)
   \        0x0   0x460A             MOV      R2,R1
   \        0x2   0x6811             LDR      R1,[R2, #+0]
   \        0x4   0x....             B.N      __dlist_add

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void dlist_del(dlist_t *)
   \                     dlist_del: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x6840             LDR      R0,[R0, #+4]
   \        0x4   0x6048             STR      R0,[R1, #+4]
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void INIT_AOS_DLIST_HEAD(dlist_t *)
   \                     INIT_AOS_DLIST_HEAD: (+1)
   \        0x0   0x6040             STR      R0,[R0, #+4]
   \        0x2   0x6000             STR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int __dlist_entry_number(dlist_t *)
   \                     __dlist_entry_number: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xE001             B.N      ??__dlist_entry_number_0
   \                     ??__dlist_entry_number_1: (+1)
   \        0x8   0x461A             MOV      R2,R3
   \        0xA   0x1C40             ADDS     R0,R0,#+1
   \                     ??__dlist_entry_number_0: (+1)
   \        0xC   0x6853             LDR      R3,[R2, #+4]
   \        0xE   0x428B             CMP      R3,R1
   \       0x10   0xD1FA             BNE.N    ??__dlist_entry_number_1
   \       0x12   0x4770             BX       LR               ;; return
      5          
      6          #ifdef LOG_REPORT_TO_CLOUD
      7              #include "iotx_log_report.h"
      8          #endif

   \                                 In section .bss, align 4
      9          static int _in_yield_cb;
   \                     _in_yield_cb:
   \        0x0                      DS8 4
     10          
     11          #ifndef PLATFORM_HAS_DYNMEM
     12          iotx_mc_client_t g_iotx_mc_client[IOTX_MC_CLIENT_MAX_COUNT] = {0};
     13          #endif
     14          

   \                                 In section .text, align 2, keep-with-next
     15          static void iotx_mc_release(iotx_mc_client_t *pclient)
     16          {
     17          #ifdef PLATFORM_HAS_DYNMEM
     18              mqtt_free(pclient);
   \                     iotx_mc_release: (+1)
   \        0x0   0x....'....        B.W      HAL_Free
     19          #else
     20              memset(pclient, 0, sizeof(iotx_mc_client_t));
     21          #endif
     22          }
     23          
     24          #if !WITH_MQTT_ONLY_QOS0

   \                                 In section .text, align 2, keep-with-next
     25          static void iotx_mc_pub_wait_list_init(iotx_mc_client_t *pClient)
     26          {
     27          #ifdef PLATFORM_HAS_DYNMEM
     28              INIT_LIST_HEAD(&pClient->list_pub_wait_ack);
   \                     iotx_mc_pub_wait_list_init: (+1)
   \        0x0   0x30C0             ADDS     R0,R0,#+192
   \        0x2   0x....             B.N      INIT_AOS_DLIST_HEAD
     29          #else
     30              memset(pClient->list_pub_wait_ack, 0, sizeof(iotx_mc_pub_info_t) * IOTX_MC_PUBWAIT_LIST_MAX_LEN);
     31          #endif
     32          }
     33          

   \                                 In section .text, align 2, keep-with-next
     34          static void iotx_mc_pub_wait_list_deinit(iotx_mc_client_t *pClient)
     35          {
   \                     iotx_mc_pub_wait_list_deinit: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
     36          #ifdef PLATFORM_HAS_DYNMEM
     37              iotx_mc_pub_info_t *node = NULL, *next_node = NULL;
     38              list_for_each_entry_safe(node, next_node, &pClient->list_pub_wait_ack, linked_list, iotx_mc_pub_info_t) {
   \        0x4   0xF8D4 0x00C4      LDR      R0,[R4, #+196]
   \        0x8   0xF1A0 0x0510      SUB      R5,R0,#+16
   \        0xC   0x6968             LDR      R0,[R5, #+20]
   \        0xE   0xF1A0 0x0610      SUB      R6,R0,#+16
   \       0x12   0xE008             B.N      ??iotx_mc_pub_wait_list_deinit_0
     39                  list_del(&node->linked_list);
   \                     ??iotx_mc_pub_wait_list_deinit_1: (+1)
   \       0x14   0x....'....        BL       dlist_del
     40                  mqtt_free(node);
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       HAL_Free
     41              }
   \       0x1E   0x4635             MOV      R5,R6
   \       0x20   0x6970             LDR      R0,[R6, #+20]
   \       0x22   0xF1A0 0x0610      SUB      R6,R0,#+16
   \                     ??iotx_mc_pub_wait_list_deinit_0: (+1)
   \       0x26   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x2A   0xF104 0x01C0      ADD      R1,R4,#+192
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD1F0             BNE.N    ??iotx_mc_pub_wait_list_deinit_1
     42          #else
     43              memset(pClient->list_pub_wait_ack, 0, sizeof(iotx_mc_pub_info_t) * IOTX_MC_PUBWAIT_LIST_MAX_LEN);
     44          #endif
     45          }
   \       0x32   0xBD70             POP      {R4-R6,PC}       ;; return
     46          #endif
     47          /* set MQTT connection parameter */

   \                                 In section .text, align 2, keep-with-next
     48          static int iotx_mc_set_connect_params(iotx_mc_client_t *pClient, MQTTPacket_connectData *pConnectParams)
     49          {
   \                     iotx_mc_set_connect_params: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
     50              if (NULL == pClient || NULL == pConnectParams) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??iotx_mc_set_connect_params_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD102             BNE.N    ??iotx_mc_set_connect_params_1
     51                  return NULL_VALUE_ERROR;
   \                     ??iotx_mc_set_connect_params_0: (+1)
   \        0xE   0xF06F 0x0001      MVN      R0,#+1
   \       0x12   0xBD70             POP      {R4-R6,PC}
     52              }
     53          
     54              memcpy(pClient->connect_data.struct_id, pConnectParams->struct_id, 4);
   \                     ??iotx_mc_set_connect_params_1: (+1)
   \       0x14   0x2204             MOVS     R2,#+4
   \       0x16   0xF104 0x0068      ADD      R0,R4,#+104
   \       0x1A   0x....'....        BL       __aeabi_memcpy4
     55              pClient->connect_data.struct_version = pConnectParams->struct_version;
   \       0x1E   0x6868             LDR      R0,[R5, #+4]
   \       0x20   0x66E0             STR      R0,[R4, #+108]
     56              pClient->connect_data.MQTTVersion = pConnectParams->MQTTVersion;
   \       0x22   0x7A28             LDRB     R0,[R5, #+8]
   \       0x24   0xF884 0x0070      STRB     R0,[R4, #+112]
     57              pClient->connect_data.clientID = pConnectParams->clientID;
   \       0x28   0xF104 0x0074      ADD      R0,R4,#+116
   \       0x2C   0xF105 0x010C      ADD      R1,R5,#+12
   \       0x30   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x34   0xE880 0x004C      STM      R0,{R2,R3,R6}
     58              pClient->connect_data.cleansession = pConnectParams->cleansession;
   \       0x38   0x7EA8             LDRB     R0,[R5, #+26]
   \       0x3A   0xF884 0x0082      STRB     R0,[R4, #+130]
     59              pClient->connect_data.willFlag = pConnectParams->willFlag;
   \       0x3E   0x7EE8             LDRB     R0,[R5, #+27]
   \       0x40   0xF884 0x0083      STRB     R0,[R4, #+131]
     60              pClient->connect_data.username = pConnectParams->username;
   \       0x44   0xF104 0x00A8      ADD      R0,R4,#+168
   \       0x48   0xF105 0x0140      ADD      R1,R5,#+64
   \       0x4C   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x50   0xE880 0x004C      STM      R0,{R2,R3,R6}
     61              pClient->connect_data.password = pConnectParams->password;
   \       0x54   0xF104 0x00B4      ADD      R0,R4,#+180
   \       0x58   0xF105 0x014C      ADD      R1,R5,#+76
   \       0x5C   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x60   0xE880 0x004C      STM      R0,{R2,R3,R6}
     62              memcpy(pClient->connect_data.will.struct_id, pConnectParams->will.struct_id, 4);
   \       0x64   0x2204             MOVS     R2,#+4
   \       0x66   0xF105 0x011C      ADD      R1,R5,#+28
   \       0x6A   0xF104 0x0084      ADD      R0,R4,#+132
   \       0x6E   0x....'....        BL       __aeabi_memcpy4
     63              pClient->connect_data.will.struct_version = pConnectParams->will.struct_version;
   \       0x72   0x6A28             LDR      R0,[R5, #+32]
   \       0x74   0xF8C4 0x0088      STR      R0,[R4, #+136]
     64              pClient->connect_data.will.topicName = pConnectParams->will.topicName;
   \       0x78   0xF104 0x008C      ADD      R0,R4,#+140
   \       0x7C   0xF105 0x0124      ADD      R1,R5,#+36
   \       0x80   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x84   0xE880 0x004C      STM      R0,{R2,R3,R6}
     65              pClient->connect_data.will.message = pConnectParams->will.message;
   \       0x88   0xF104 0x0098      ADD      R0,R4,#+152
   \       0x8C   0xF105 0x0130      ADD      R1,R5,#+48
   \       0x90   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x94   0xE880 0x004C      STM      R0,{R2,R3,R6}
     66              pClient->connect_data.will.qos = pConnectParams->will.qos;
   \       0x98   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x9C   0xF884 0x00A5      STRB     R0,[R4, #+165]
     67              pClient->connect_data.will.retained = pConnectParams->will.retained;
   \       0xA0   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0xA4   0xF884 0x00A4      STRB     R0,[R4, #+164]
     68          
     69              if (pConnectParams->keepAliveInterval < CONFIG_MQTT_KEEPALIVE_INTERVAL_MIN) {
   \       0xA8   0x8B28             LDRH     R0,[R5, #+24]
   \       0xAA   0x281E             CMP      R0,#+30
   \       0xAC   0xDA03             BGE.N    ??iotx_mc_set_connect_params_2
     70                  mqtt_warning("Input heartbeat interval(%d ms) < Allowed minimum(%d ms)",
     71                               (pConnectParams->keepAliveInterval * 1000),
     72                               (CONFIG_MQTT_KEEPALIVE_INTERVAL_MIN * 1000)
     73                              );
     74                  mqtt_warning("Reset heartbeat interval => %d Millisecond",
     75                               (CONFIG_MQTT_KEEPALIVE_INTERVAL * 1000)
     76                              );
     77                  pClient->connect_data.keepAliveInterval = CONFIG_MQTT_KEEPALIVE_INTERVAL;
   \       0xAE   0x203C             MOVS     R0,#+60
   \       0xB0   0xF8A4 0x0080      STRH     R0,[R4, #+128]
   \       0xB4   0xE009             B.N      ??iotx_mc_set_connect_params_3
     78              } else if (pConnectParams->keepAliveInterval > CONFIG_MQTT_KEEPALIVE_INTERVAL_MAX) {
   \                     ??iotx_mc_set_connect_params_2: (+1)
   \       0xB6   0xF240 0x41B1      MOVW     R1,#+1201
   \       0xBA   0x4288             CMP      R0,R1
   \       0xBC   0xDB03             BLT.N    ??iotx_mc_set_connect_params_4
     79                  mqtt_warning("Input heartbeat interval(%d ms) > Allowed maximum(%d ms)",
     80                               (pConnectParams->keepAliveInterval * 1000),
     81                               (CONFIG_MQTT_KEEPALIVE_INTERVAL_MAX * 1000)
     82                              );
     83                  mqtt_warning("Reset heartbeat interval => %d Millisecond",
     84                               (CONFIG_MQTT_KEEPALIVE_INTERVAL * 1000)
     85                              );
     86                  pClient->connect_data.keepAliveInterval = CONFIG_MQTT_KEEPALIVE_INTERVAL;
   \       0xBE   0x203C             MOVS     R0,#+60
   \       0xC0   0xF8A4 0x0080      STRH     R0,[R4, #+128]
   \       0xC4   0xE001             B.N      ??iotx_mc_set_connect_params_3
     87              } else {
     88                  pClient->connect_data.keepAliveInterval = pConnectParams->keepAliveInterval;
   \                     ??iotx_mc_set_connect_params_4: (+1)
   \       0xC6   0xF8A4 0x0080      STRH     R0,[R4, #+128]
     89              }
     90          
     91              return SUCCESS_RETURN;
   \                     ??iotx_mc_set_connect_params_3: (+1)
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0xBD70             POP      {R4-R6,PC}       ;; return
     92          }
     93          
     94          /* set state of MQTT client */

   \                                 In section .text, align 2, keep-with-next
     95          static void iotx_mc_set_client_state(iotx_mc_client_t *pClient, iotx_mc_state_t newState)
     96          {
   \                     iotx_mc_set_client_state: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
     97              HAL_MutexLock(pClient->lock_generic);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x....'....        BL       HAL_MutexLock
     98              pClient->client_state = newState;
   \        0xC   0xF884 0x505C      STRB     R5,[R4, #+92]
     99              HAL_MutexUnlock(pClient->lock_generic);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x16   0x....'....        B.W      HAL_MutexUnlock
    100          }
    101          

   \                                 In section .text, align 2, keep-with-next
    102          static iotx_mc_state_t iotx_mc_get_client_state(iotx_mc_client_t *pClient)
    103          {
   \                     iotx_mc_get_client_state: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    104              iotx_mc_state_t state;
    105              HAL_MutexLock(pClient->lock_generic);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x....'....        BL       HAL_MutexLock
    106              state = pClient->client_state;
   \        0xA   0xF894 0x505C      LDRB     R5,[R4, #+92]
    107              HAL_MutexUnlock(pClient->lock_generic);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       HAL_MutexUnlock
    108          
    109              return state;
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    110          }
    111          
    112          /* Initialize MQTT client */

   \                                 In section .text, align 2, keep-with-next
    113          static int iotx_mc_init(iotx_mc_client_t *pClient, iotx_mqtt_param_t *pInitParams)
    114          {
   \                     iotx_mc_init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB096             SUB      SP,SP,#+88
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
    115              int rc = FAIL_RETURN;
   \        0x8   0xF04F 0x34FF      MOV      R4,#-1
    116              iotx_mc_state_t mc_state = IOTX_MC_STATE_INVALID;
   \        0xC   0x2700             MOVS     R7,#+0
    117              MQTTPacket_connectData connectdata = MQTTPacket_connectData_initializer;
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x....'....        LDR.W    R1,??DataTable5
   \       0x14   0x2258             MOVS     R2,#+88
   \       0x16   0x....'....        BL       __aeabi_memcpy4
    118          
    119              if (pClient == NULL || pInitParams == NULL || pInitParams->write_buf_size == 0 || pInitParams->read_buf_size == 0) {
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD007             BEQ.N    ??iotx_mc_init_0
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD005             BEQ.N    ??iotx_mc_init_0
   \       0x22   0x6A70             LDR      R0,[R6, #+36]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD002             BEQ.N    ??iotx_mc_init_0
   \       0x28   0x6AB0             LDR      R0,[R6, #+40]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD102             BNE.N    ??iotx_mc_init_1
    120                  return NULL_VALUE_ERROR;
   \                     ??iotx_mc_init_0: (+1)
   \       0x2E   0xF06F 0x0001      MVN      R0,#+1
   \       0x32   0xE0B4             B.N      ??iotx_mc_init_2
    121              }
    122          
    123              pClient->lock_generic = HAL_MutexCreate();
   \                     ??iotx_mc_init_1: (+1)
   \       0x34   0x....'....        BL       HAL_MutexCreate
   \       0x38   0x6028             STR      R0,[R5, #+0]
    124              if (!pClient->lock_generic) {
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD101             BNE.N    ??iotx_mc_init_3
    125                  return FAIL_RETURN;
   \       0x3E   0x4620             MOV      R0,R4
   \       0x40   0xE0AD             B.N      ??iotx_mc_init_2
    126              }
    127          
    128              pClient->lock_list_pub = HAL_MutexCreate();
   \                     ??iotx_mc_init_3: (+1)
   \       0x42   0x....'....        BL       HAL_MutexCreate
   \       0x46   0xF8C5 0x00D0      STR      R0,[R5, #+208]
    129              if (!pClient->lock_list_pub) {
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD06E             BEQ.N    ??iotx_mc_init_4
    130                  goto RETURN;
    131              }
    132          
    133              pClient->lock_yield = HAL_MutexCreate();
   \       0x4E   0x....'....        BL       HAL_MutexCreate
   \       0x52   0xF8C5 0x00DC      STR      R0,[R5, #+220]
    134              if (!pClient->lock_yield) {
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD068             BEQ.N    ??iotx_mc_init_4
    135                  goto RETURN;
    136              }
    137          
    138              pClient->lock_write_buf = HAL_MutexCreate();
   \       0x5A   0x....'....        BL       HAL_MutexCreate
   \       0x5E   0xF8C5 0x00D4      STR      R0,[R5, #+212]
    139              if (!pClient->lock_write_buf) {
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD062             BEQ.N    ??iotx_mc_init_4
    140                  goto RETURN;
    141              }
    142          
    143              pClient->lock_read_buf = HAL_MutexCreate();
   \       0x66   0x....'....        BL       HAL_MutexCreate
   \       0x6A   0xF8C5 0x00D8      STR      R0,[R5, #+216]
    144              if (!pClient->lock_read_buf) {
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD05C             BEQ.N    ??iotx_mc_init_4
    145                  goto RETURN;
    146              }
    147          
    148              connectdata.MQTTVersion = IOTX_MC_MQTT_VERSION;
   \       0x72   0x2004             MOVS     R0,#+4
   \       0x74   0xF88D 0x0008      STRB     R0,[SP, #+8]
    149              connectdata.keepAliveInterval = pInitParams->keepalive_interval_ms / 1000;
   \       0x78   0x6A30             LDR      R0,[R6, #+32]
   \       0x7A   0xF44F 0x717A      MOV      R1,#+1000
   \       0x7E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x82   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    150          
    151          
    152              connectdata.clientID.cstring = (char *)pInitParams->client_id;
   \       0x86   0x68B0             LDR      R0,[R6, #+8]
   \       0x88   0x9003             STR      R0,[SP, #+12]
    153              connectdata.username.cstring = (char *)pInitParams->username;
   \       0x8A   0x68F0             LDR      R0,[R6, #+12]
   \       0x8C   0x9010             STR      R0,[SP, #+64]
    154              connectdata.password.cstring = (char *)pInitParams->password;
   \       0x8E   0x6930             LDR      R0,[R6, #+16]
   \       0x90   0x9013             STR      R0,[SP, #+76]
    155              connectdata.cleansession = pInitParams->clean_session;
   \       0x92   0x7E30             LDRB     R0,[R6, #+24]
   \       0x94   0xF88D 0x001A      STRB     R0,[SP, #+26]
    156          
    157              if (pInitParams->request_timeout_ms < CONFIG_MQTT_REQ_TIMEOUT_MIN
    158                  || pInitParams->request_timeout_ms > CONFIG_MQTT_REQ_TIMEOUT_MAX) {
   \       0x98   0x69F0             LDR      R0,[R6, #+28]
   \       0x9A   0xF5A0 0x70FA      SUB      R0,R0,#+500
   \       0x9E   0xF241 0x1195      MOVW     R1,#+4501
   \       0xA2   0x4288             CMP      R0,R1
   \       0xA4   0xD303             BCC.N    ??iotx_mc_init_5
    159          
    160                  pClient->request_timeout_ms = CONFIG_MQTT_REQUEST_TIMEOUT;
   \       0xA6   0xF44F 0x60FA      MOV      R0,#+2000
   \       0xAA   0x60A8             STR      R0,[R5, #+8]
   \       0xAC   0xE001             B.N      ??iotx_mc_init_6
    161              } else {
    162                  pClient->request_timeout_ms = pInitParams->request_timeout_ms;
   \                     ??iotx_mc_init_5: (+1)
   \       0xAE   0x69F0             LDR      R0,[R6, #+28]
   \       0xB0   0x60A8             STR      R0,[R5, #+8]
    163              }
    164          
    165          #ifdef PLATFORM_HAS_DYNMEM
    166          #if !( WITH_MQTT_DYN_BUF)
    167              pClient->buf_send = mqtt_malloc(pInitParams->write_buf_size);
    168              if (pClient->buf_send == NULL) {
    169                  goto RETURN;
    170              }
    171              pClient->buf_size_send = pInitParams->write_buf_size;
    172          
    173              pClient->buf_read = mqtt_malloc(pInitParams->read_buf_size);
    174              if (pClient->buf_read == NULL) {
    175                  goto RETURN;
    176              }
    177              pClient->buf_size_read = pInitParams->read_buf_size;
    178          #else
    179              pClient->buf_size_send_max = pInitParams->write_buf_size;
   \                     ??iotx_mc_init_6: (+1)
   \       0xB2   0x6A70             LDR      R0,[R6, #+36]
   \       0xB4   0x6168             STR      R0,[R5, #+20]
    180              pClient->buf_size_read_max = pInitParams->read_buf_size;
   \       0xB6   0x6AB0             LDR      R0,[R6, #+40]
   \       0xB8   0x61A8             STR      R0,[R5, #+24]
    181          #endif
    182          #else
    183              pClient->buf_size_send = IOTX_MC_TX_MAX_LEN;
    184              pClient->buf_size_read = IOTX_MC_RX_MAX_LEN;
    185          #endif
    186          
    187              pClient->keepalive_probes = 0;
   \       0xBA   0x4638             MOV      R0,R7
   \       0xBC   0xF885 0x0020      STRB     R0,[R5, #+32]
    188          
    189              pClient->handle_event.h_fp = pInitParams->handle_event.h_fp;
   \       0xC0   0x6AF0             LDR      R0,[R6, #+44]
   \       0xC2   0xF8C5 0x00E0      STR      R0,[R5, #+224]
    190              pClient->handle_event.pcontext = pInitParams->handle_event.pcontext;
   \       0xC6   0x6B30             LDR      R0,[R6, #+48]
   \       0xC8   0xF8C5 0x00E4      STR      R0,[R5, #+228]
    191          
    192              /* Initialize reconnect parameter */
    193              pClient->reconnect_param.reconnect_time_interval_ms = IOTX_MC_RECONNECT_INTERVAL_MIN_MS;
   \       0xCC   0xF44F 0x707A      MOV      R0,#+1000
   \       0xD0   0x6668             STR      R0,[R5, #+100]
    194          #if !WITH_MQTT_ONLY_QOS0
    195              iotx_mc_pub_wait_list_init(pClient);
   \       0xD2   0x4628             MOV      R0,R5
   \       0xD4   0x....'....        BL       iotx_mc_pub_wait_list_init
    196          #endif
    197          
    198          #ifdef PLATFORM_HAS_DYNMEM
    199              INIT_LIST_HEAD(&pClient->list_sub_handle);
   \       0xD8   0xF105 0x002C      ADD      R0,R5,#+44
   \       0xDC   0x....'....        BL       INIT_AOS_DLIST_HEAD
    200              INIT_LIST_HEAD(&pClient->list_sub_sync_ack);
   \       0xE0   0xF105 0x00C8      ADD      R0,R5,#+200
   \       0xE4   0x....'....        BL       INIT_AOS_DLIST_HEAD
    201          #endif
    202              /* Initialize MQTT connect parameter */
    203              rc = iotx_mc_set_connect_params(pClient, &connectdata);
   \       0xE8   0x4669             MOV      R1,SP
   \       0xEA   0x4628             MOV      R0,R5
   \       0xEC   0x....'....        BL       iotx_mc_set_connect_params
   \       0xF0   0x0004             MOVS     R4,R0
    204              if (SUCCESS_RETURN != rc) {
   \       0xF2   0xD11B             BNE.N    ??iotx_mc_init_4
    205                  mc_state = IOTX_MC_STATE_INVALID;
    206                  goto RETURN;
    207              }
    208          
    209              iotx_time_init(&pClient->next_ping_time);
   \       0xF4   0xF105 0x0058      ADD      R0,R5,#+88
   \       0xF8   0x....'....        BL       iotx_time_init
    210              iotx_time_init(&pClient->reconnect_param.reconnect_next_time);
   \       0xFC   0xF105 0x0060      ADD      R0,R5,#+96
   \      0x100   0x....'....        BL       iotx_time_init
    211          
    212              memset(&pClient->ipstack, 0, sizeof(utils_network_t));
   \      0x104   0x463A             MOV      R2,R7
   \      0x106   0x2124             MOVS     R1,#+36
   \      0x108   0xF105 0x0034      ADD      R0,R5,#+52
   \      0x10C   0x....'....        BL       __aeabi_memset4
    213          
    214          #ifdef SUPPORT_TLS
    215              {
    216                  extern const char *iotx_ca_crt;
    217                  pInitParams->pub_key = iotx_ca_crt;
   \      0x110   0x....'....        LDR.W    R0,??DataTable5_1
   \      0x114   0x6800             LDR      R0,[R0, #+0]
   \      0x116   0x6170             STR      R0,[R6, #+20]
    218              }
    219          #endif
    220          
    221              rc = iotx_net_init(&pClient->ipstack, pInitParams->host, pInitParams->port, pInitParams->pub_key);
   \      0x118   0x4603             MOV      R3,R0
   \      0x11A   0x8832             LDRH     R2,[R6, #+0]
   \      0x11C   0x6871             LDR      R1,[R6, #+4]
   \      0x11E   0xF105 0x0034      ADD      R0,R5,#+52
   \      0x122   0x....'....        BL       iotx_net_init
   \      0x126   0x0004             MOVS     R4,R0
    222          
    223              if (SUCCESS_RETURN != rc) {
   \      0x128   0xD100             BNE.N    ??iotx_mc_init_4
    224                  mc_state = IOTX_MC_STATE_INVALID;
    225                  goto RETURN;
    226              }
    227          
    228              mc_state = IOTX_MC_STATE_INITIALIZED;
   \      0x12A   0x2701             MOVS     R7,#+1
    229              rc = SUCCESS_RETURN;
    230              mqtt_info("MQTT init success!");
    231          
    232          RETURN :
    233              iotx_mc_set_client_state(pClient, mc_state);
   \                     ??iotx_mc_init_4: (+1)
   \      0x12C   0x4639             MOV      R1,R7
   \      0x12E   0x4628             MOV      R0,R5
   \      0x130   0x....'....        BL       iotx_mc_set_client_state
    234              if (rc != SUCCESS_RETURN) {
   \      0x134   0x2C00             CMP      R4,#+0
   \      0x136   0xD031             BEQ.N    ??iotx_mc_init_7
    235          #ifdef PLATFORM_HAS_DYNMEM
    236                  if (pClient->buf_send != NULL) {
   \      0x138   0x6A68             LDR      R0,[R5, #+36]
   \      0x13A   0x2800             CMP      R0,#+0
   \      0x13C   0xD003             BEQ.N    ??iotx_mc_init_8
    237                      mqtt_free(pClient->buf_send);
   \      0x13E   0x....'....        BL       HAL_Free
   \      0x142   0x2000             MOVS     R0,#+0
   \      0x144   0x6268             STR      R0,[R5, #+36]
    238                      pClient->buf_send = NULL;
    239                  }
    240                  if (pClient->buf_read != NULL) {
   \                     ??iotx_mc_init_8: (+1)
   \      0x146   0x6AA8             LDR      R0,[R5, #+40]
   \      0x148   0x2800             CMP      R0,#+0
   \      0x14A   0xD003             BEQ.N    ??iotx_mc_init_9
    241                      mqtt_free(pClient->buf_read);
   \      0x14C   0x....'....        BL       HAL_Free
   \      0x150   0x2000             MOVS     R0,#+0
   \      0x152   0x62A8             STR      R0,[R5, #+40]
    242                      pClient->buf_read = NULL;
    243                  }
    244          #endif
    245                  if (pClient->lock_list_pub) {
   \                     ??iotx_mc_init_9: (+1)
   \      0x154   0xF8D5 0x00D0      LDR      R0,[R5, #+208]
   \      0x158   0x2800             CMP      R0,#+0
   \      0x15A   0xD004             BEQ.N    ??iotx_mc_init_10
    246                      HAL_MutexDestroy(pClient->lock_list_pub);
   \      0x15C   0x....'....        BL       HAL_MutexDestroy
    247                      pClient->lock_list_pub = NULL;
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0xF8C5 0x00D0      STR      R0,[R5, #+208]
    248                  }
    249                  if (pClient->lock_write_buf) {
   \                     ??iotx_mc_init_10: (+1)
   \      0x166   0xF8D5 0x00D4      LDR      R0,[R5, #+212]
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD004             BEQ.N    ??iotx_mc_init_11
    250                      HAL_MutexDestroy(pClient->lock_write_buf);
   \      0x16E   0x....'....        BL       HAL_MutexDestroy
    251                      pClient->lock_write_buf = NULL;
   \      0x172   0x2000             MOVS     R0,#+0
   \      0x174   0xF8C5 0x00D4      STR      R0,[R5, #+212]
    252                  }
    253                  if (pClient->lock_read_buf) {
   \                     ??iotx_mc_init_11: (+1)
   \      0x178   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \      0x17C   0x2800             CMP      R0,#+0
   \      0x17E   0xD004             BEQ.N    ??iotx_mc_init_12
    254                      HAL_MutexDestroy(pClient->lock_read_buf);
   \      0x180   0x....'....        BL       HAL_MutexDestroy
    255                      pClient->lock_read_buf = NULL;
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0xF8C5 0x00D8      STR      R0,[R5, #+216]
    256                  }
    257                  if (pClient->lock_yield) {
   \                     ??iotx_mc_init_12: (+1)
   \      0x18A   0xF8D5 0x00DC      LDR      R0,[R5, #+220]
   \      0x18E   0x2800             CMP      R0,#+0
   \      0x190   0xD004             BEQ.N    ??iotx_mc_init_7
    258                      HAL_MutexDestroy(pClient->lock_yield);
   \      0x192   0x....'....        BL       HAL_MutexDestroy
    259                      pClient->lock_yield = NULL;
   \      0x196   0x2000             MOVS     R0,#+0
   \      0x198   0xF8C5 0x00DC      STR      R0,[R5, #+220]
    260                  }
    261              }
    262          
    263              return rc;
   \                     ??iotx_mc_init_7: (+1)
   \      0x19C   0x4620             MOV      R0,R4
   \                     ??iotx_mc_init_2: (+1)
   \      0x19E   0xB017             ADD      SP,SP,#+92
   \      0x1A0   0xBDF0             POP      {R4-R7,PC}       ;; return
    264          }

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x4D 0x51          DC8 77, 81, 84, 67
   \              0x54 0x43    
   \        0x4   0x0000'0000        DC32 0
   \        0x8   0x04 0x00          DC8 4, 0, 0, 0
   \              0x00 0x00    
   \        0xC   0x0000'0000        DC32 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   \       0x18   0x001E             DC16 30
   \       0x1A   0x01 0x00          DC8 1, 0, 77, 81, 84, 87
   \              0x4D 0x51    
   \              0x54 0x57    
   \       0x20   0x0000'0000        DC32 0, 0H, 0, 0H, 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \       0x3C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x40   0x0000'0000        DC32 0H, 0, 0H, 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
    265          
    266          #ifdef PLATFORM_HAS_DYNMEM
    267              #if  WITH_MQTT_DYN_BUF
    268                  extern int MQTTPacket_len(int rem_len);
    269                  extern int MQTTSerialize_connectLength(MQTTPacket_connectData *options);
    270              #endif
    271          #endif
    272          

   \                                 In section .text, align 2, keep-with-next
    273          static int _get_connect_length(MQTTPacket_connectData *options)
    274          {
   \                     _get_connect_length: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    275          #ifdef PLATFORM_HAS_DYNMEM
    276          #if  WITH_MQTT_DYN_BUF
    277              return MQTTPacket_len(MQTTSerialize_connectLength(options));
   \        0x2   0x....'....        BL       MQTTSerialize_connectLength
   \        0x6   0xE8BD 0x4002      POP      {R1,LR}
   \        0xA   0x....'....        B.W      MQTTPacket_len
    278          #else
    279              return 0;
    280          #endif
    281          #else
    282              return 0;
    283          #endif
    284          }
    285          

   \                                 In section .text, align 2, keep-with-next
    286          static int _reset_send_buffer(iotx_mc_client_t *c)
    287          {
   \                     _reset_send_buffer: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    288          #ifdef PLATFORM_HAS_DYNMEM
    289          #if  WITH_MQTT_DYN_BUF
    290              if (c == NULL || c->buf_send == NULL) {
   \        0x4   0xD002             BEQ.N    ??_reset_send_buffer_0
   \        0x6   0x6A60             LDR      R0,[R4, #+36]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD102             BNE.N    ??_reset_send_buffer_1
    291                  return FAIL_RETURN;
   \                     ??_reset_send_buffer_0: (+1)
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
   \       0x10   0xBD10             POP      {R4,PC}
    292              }
    293          
    294              mqtt_free(c->buf_send);
   \                     ??_reset_send_buffer_1: (+1)
   \       0x12   0x....'....        BL       HAL_Free
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x6260             STR      R0,[R4, #+36]
    295              c->buf_send = NULL;
    296              c->buf_size_send = 0;
   \       0x1A   0x6120             STR      R0,[R4, #+16]
    297              return 0;
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
    298          #else
    299              return 0;
    300          #endif
    301          #else
    302              return 0;
    303          #endif
    304          }
    305          

   \                                 In section .text, align 2, keep-with-next
    306          static int _reset_recv_buffer(iotx_mc_client_t *c)
    307          {
   \                     _reset_recv_buffer: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    308          #ifdef PLATFORM_HAS_DYNMEM
    309          #if  WITH_MQTT_DYN_BUF
    310              if (c == NULL || c->buf_read == NULL) {
   \        0x4   0xD002             BEQ.N    ??_reset_recv_buffer_0
   \        0x6   0x6AA0             LDR      R0,[R4, #+40]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD102             BNE.N    ??_reset_recv_buffer_1
    311                  return FAIL_RETURN;
   \                     ??_reset_recv_buffer_0: (+1)
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
   \       0x10   0xBD10             POP      {R4,PC}
    312              }
    313          
    314              mqtt_free(c->buf_read);
   \                     ??_reset_recv_buffer_1: (+1)
   \       0x12   0x....'....        BL       HAL_Free
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x62A0             STR      R0,[R4, #+40]
    315              c->buf_read = NULL;
    316              c->buf_size_read = 0;
   \       0x1A   0x61E0             STR      R0,[R4, #+28]
    317              return 0;
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
    318          #else
    319              return 0;
    320          #endif
    321          #else
    322              return 0;
    323          #endif
    324          }
    325          

   \                                 In section .text, align 2, keep-with-next
    326          static int _alloc_send_buffer(iotx_mc_client_t *c, int len)
    327          {
   \                     _alloc_send_buffer: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    328          #ifdef PLATFORM_HAS_DYNMEM
    329          #if  WITH_MQTT_DYN_BUF
    330              int tmp_len;
    331          
    332              if (c == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??_alloc_send_buffer_0
    333                  return FAIL_RETURN;
   \        0xA   0xF04F 0x30FF      MOV      R0,#-1
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
    334              }
    335          
    336              tmp_len = MQTT_DYNBUF_SEND_MARGIN + len;
   \                     ??_alloc_send_buffer_0: (+1)
   \       0x10   0x3540             ADDS     R5,R5,#+64
    337              if (tmp_len > c->buf_size_send_max) {
   \       0x12   0x6960             LDR      R0,[R4, #+20]
   \       0x14   0x42A8             CMP      R0,R5
   \       0x16   0xD200             BCS.N    ??_alloc_send_buffer_1
    338                  tmp_len = c->buf_size_send_max;
   \       0x18   0x4605             MOV      R5,R0
    339              }
    340              if (c->buf_send != NULL) {
   \                     ??_alloc_send_buffer_1: (+1)
   \       0x1A   0x6A60             LDR      R0,[R4, #+36]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD003             BEQ.N    ??_alloc_send_buffer_2
    341                  mqtt_warning("c->buf_send is not null,free it first!");
    342                  mqtt_free(c->buf_send);
   \       0x20   0x....'....        BL       HAL_Free
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6260             STR      R0,[R4, #+36]
    343              }
    344              c->buf_send = mqtt_malloc(tmp_len);
   \                     ??_alloc_send_buffer_2: (+1)
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       HAL_Malloc
   \       0x2E   0x6260             STR      R0,[R4, #+36]
    345              if (c->buf_send == NULL) {
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD102             BNE.N    ??_alloc_send_buffer_3
    346                  return ERROR_MALLOC;
   \       0x34   0x....'....        LDR.W    R0,??DataTable5_2  ;; 0xfffffc0a
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}
    347              }
    348              memset(c->buf_send, 0, tmp_len);
   \                     ??_alloc_send_buffer_3: (+1)
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0x4629             MOV      R1,R5
   \       0x3E   0x....'....        BL       __aeabi_memset
    349              c->buf_size_send = tmp_len;
   \       0x42   0x6125             STR      R5,[R4, #+16]
    350              return SUCCESS_RETURN;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    351          #else
    352              return 0;
    353          #endif
    354          #else
    355              return 0;
    356          #endif
    357          }
    358          

   \                                 In section .text, align 2, keep-with-next
    359          static int _alloc_recv_buffer(iotx_mc_client_t *c, int len)
    360          {
   \                     _alloc_recv_buffer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
    361          #ifdef PLATFORM_HAS_DYNMEM
    362          #if  WITH_MQTT_DYN_BUF
    363              int tmp_len;
    364          
    365              if (c == NULL) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD102             BNE.N    ??_alloc_recv_buffer_0
    366                  return FAIL_RETURN;
   \        0xA   0xF04F 0x30FF      MOV      R0,#-1
   \        0xE   0xBD70             POP      {R4-R6,PC}
    367              }
    368          
    369              tmp_len = MQTT_DYNBUF_RECV_MARGIN + len;
   \                     ??_alloc_recv_buffer_0: (+1)
   \       0x10   0x3608             ADDS     R6,R6,#+8
    370              if (tmp_len > c->buf_size_read_max) {
   \       0x12   0x69A8             LDR      R0,[R5, #+24]
   \       0x14   0x42B0             CMP      R0,R6
   \       0x16   0xD200             BCS.N    ??_alloc_recv_buffer_1
    371                  tmp_len = c->buf_size_read_max;
   \       0x18   0x4606             MOV      R6,R0
    372              }
    373              if (c->buf_read != NULL) { /* do realloc */
   \                     ??_alloc_recv_buffer_1: (+1)
   \       0x1A   0x6AA8             LDR      R0,[R5, #+40]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0xD016             BEQ.N    ??_alloc_recv_buffer_2
    374                  char *temp = mqtt_malloc(tmp_len);
   \       0x22   0x....'....        BL       HAL_Malloc
   \       0x26   0x0004             MOVS     R4,R0
    375                  if (temp == NULL) {
   \       0x28   0xD017             BEQ.N    ??_alloc_recv_buffer_3
    376                      mqtt_err("realloc err");
    377                      return ERROR_MALLOC;
    378                  }
    379                  memset(temp, 0, tmp_len);
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x4631             MOV      R1,R6
   \       0x2E   0x....'....        BL       __aeabi_memset
    380                  memcpy(temp, c->buf_read, c->buf_size_read < tmp_len ? c->buf_size_read : tmp_len);
   \       0x32   0x69EA             LDR      R2,[R5, #+28]
   \       0x34   0x42B2             CMP      R2,R6
   \       0x36   0xD900             BLS.N    ??_alloc_recv_buffer_4
   \       0x38   0x4632             MOV      R2,R6
   \                     ??_alloc_recv_buffer_4: (+1)
   \       0x3A   0x6AA9             LDR      R1,[R5, #+40]
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x....'....        BL       __aeabi_memcpy
    381                  mqtt_free(c->buf_read);
   \       0x42   0x6AA8             LDR      R0,[R5, #+40]
   \       0x44   0x....'....        BL       HAL_Free
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x62A8             STR      R0,[R5, #+40]
    382                  c->buf_read = temp;
   \       0x4C   0x62AC             STR      R4,[R5, #+40]
   \       0x4E   0xE00B             B.N      ??_alloc_recv_buffer_5
    383              } else {
    384                  c->buf_read = mqtt_malloc(tmp_len);
   \                     ??_alloc_recv_buffer_2: (+1)
   \       0x50   0x....'....        BL       HAL_Malloc
   \       0x54   0x62A8             STR      R0,[R5, #+40]
    385                  if (c->buf_read == NULL) {
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD102             BNE.N    ??_alloc_recv_buffer_6
    386                      mqtt_err("calloc err");
    387                      return ERROR_MALLOC;
   \                     ??_alloc_recv_buffer_3: (+1)
   \       0x5A   0x....'....        LDR.W    R0,??DataTable5_2  ;; 0xfffffc0a
   \       0x5E   0xBD70             POP      {R4-R6,PC}
    388                  }
    389                  memset(c->buf_read, 0, tmp_len);
   \                     ??_alloc_recv_buffer_6: (+1)
   \       0x60   0x2200             MOVS     R2,#+0
   \       0x62   0x4631             MOV      R1,R6
   \       0x64   0x....'....        BL       __aeabi_memset
    390              }
    391              c->buf_size_read = tmp_len;
   \                     ??_alloc_recv_buffer_5: (+1)
   \       0x68   0x61EE             STR      R6,[R5, #+28]
    392              return SUCCESS_RETURN;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xBD70             POP      {R4-R6,PC}       ;; return
    393          #else
    394              return 0;
    395          #endif
    396          #else
    397              return 0;
    398          #endif
    399          }
    400          

   \                                 In section .text, align 2, keep-with-next
    401          static int iotx_mc_send_packet(iotx_mc_client_t *c, char *buf, int length, iotx_time_t *time)
    402          {
   \                     iotx_mc_send_packet: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x461D             MOV      R5,R3
    403              int rc = FAIL_RETURN;
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
    404              int sent = 0;
   \       0x10   0xF04F 0x0800      MOV      R8,#+0
    405              unsigned int left_t = 0;
    406          
    407              if (!c || !buf || !time) {
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD021             BEQ.N    ??iotx_mc_send_packet_0
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD01F             BEQ.N    ??iotx_mc_send_packet_0
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD01D             BEQ.N    ??iotx_mc_send_packet_0
    408                  return rc;
    409              }
    410          
    411              while (sent < length && !utils_time_is_expired(time)) {
   \                     ??iotx_mc_send_packet_1: (+1)
   \       0x20   0x45B8             CMP      R8,R7
   \       0x22   0xDA1D             BGE.N    ??iotx_mc_send_packet_2
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x....'....        BL       utils_time_is_expired
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD118             BNE.N    ??iotx_mc_send_packet_2
    412                  left_t = iotx_time_left(time);
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x....'....        BL       iotx_time_left
    413                  left_t = (left_t == 0) ? 1 : left_t;
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD100             BNE.N    ??iotx_mc_send_packet_3
   \       0x38   0x2001             MOVS     R0,#+1
    414                  rc = c->ipstack.write(&c->ipstack, &buf[sent], length - sent, left_t);
   \                     ??iotx_mc_send_packet_3: (+1)
   \       0x3A   0x4603             MOV      R3,R0
   \       0x3C   0xEBA7 0x0208      SUB      R2,R7,R8
   \       0x40   0xEB04 0x0108      ADD      R1,R4,R8
   \       0x44   0xF106 0x0034      ADD      R0,R6,#+52
   \       0x48   0xF8D6 0xC04C      LDR      R12,[R6, #+76]
   \       0x4C   0x47E0             BLX      R12
    415                  if (rc < 0) { /* there was an error writing the data */
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD406             BMI.N    ??iotx_mc_send_packet_2
    416                      break;
    417                  }
    418                  sent += rc;
   \       0x52   0x4440             ADD      R0,R0,R8
   \       0x54   0x4680             MOV      R8,R0
   \       0x56   0xE7E3             B.N      ??iotx_mc_send_packet_1
    419              }
    420          
    421              if (sent == length) {
    422                  rc = SUCCESS_RETURN;
    423              } else {
    424                  rc = MQTT_NETWORK_ERROR;
   \                     ??iotx_mc_send_packet_4: (+1)
   \       0x58   0xF06F 0x000D      MVN      R0,#+13
    425              }
    426              return rc;
   \                     ??iotx_mc_send_packet_0: (+1)
   \       0x5C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??iotx_mc_send_packet_2: (+1)
   \       0x60   0x45B8             CMP      R8,R7
   \       0x62   0xD1F9             BNE.N    ??iotx_mc_send_packet_4
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xE7F9             B.N      ??iotx_mc_send_packet_0
    427          }
    428          

   \                                 In section .text, align 2, keep-with-next
    429          int MQTTConnect(iotx_mc_client_t *pClient)
    430          {
   \                     MQTTConnect: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    431              MQTTPacket_connectData *pConnectParams;
    432              iotx_time_t connectTimer;
    433              int len = 0;
    434          
    435              if (!pClient) {
   \        0x4   0xD102             BNE.N    ??MQTTConnect_0
    436                  return FAIL_RETURN;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
    437              }
    438          
    439              pConnectParams = &pClient->connect_data;
   \                     ??MQTTConnect_0: (+1)
   \        0xC   0xF104 0x0568      ADD      R5,R4,#+104
    440              HAL_MutexLock(pClient->lock_write_buf);
   \       0x10   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x14   0x....'....        BL       HAL_MutexLock
    441          
    442              len = _get_connect_length(pConnectParams);
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       _get_connect_length
   \       0x1E   0x4601             MOV      R1,R0
    443          
    444              if (_alloc_send_buffer(pClient, len) != SUCCESS_RETURN) {
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x....'....        BL       _alloc_send_buffer
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD006             BEQ.N    ??MQTTConnect_1
    445                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x2A   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x2E   0x....'....        BL       HAL_MutexUnlock
    446                  return FAIL_RETURN;
   \       0x32   0xF04F 0x30FF      MOV      R0,#-1
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
    447              }
    448          
    449              if ((len = MQTTSerialize_connect((unsigned char *)pClient->buf_send, pClient->buf_size_send, pConnectParams)) <= 0) {
   \                     ??MQTTConnect_1: (+1)
   \       0x38   0x462A             MOV      R2,R5
   \       0x3A   0x6921             LDR      R1,[R4, #+16]
   \       0x3C   0x6A60             LDR      R0,[R4, #+36]
   \       0x3E   0x....'....        BL       MQTTSerialize_connect
   \       0x42   0x4605             MOV      R5,R0
   \       0x44   0x2D01             CMP      R5,#+1
   \       0x46   0xDA09             BGE.N    ??MQTTConnect_2
    450                  mqtt_err("Serialize connect packet failed, len = %d", len);
    451                  _reset_send_buffer(pClient);
   \       0x48   0x4620             MOV      R0,R4
   \       0x4A   0x....'....        BL       _reset_send_buffer
    452                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x4E   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x52   0x....'....        BL       HAL_MutexUnlock
    453                  return MQTT_CONNECT_PACKET_ERROR;
   \       0x56   0xF06F 0x001D      MVN      R0,#+29
   \       0x5A   0xBD32             POP      {R1,R4,R5,PC}
    454              }
    455          
    456              /* send the connect packet */
    457              iotx_time_init(&connectTimer);
   \                     ??MQTTConnect_2: (+1)
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       iotx_time_init
    458              utils_time_countdown_ms(&connectTimer, pClient->request_timeout_ms);
   \       0x62   0x68A1             LDR      R1,[R4, #+8]
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x....'....        BL       utils_time_countdown_ms
    459              if ((iotx_mc_send_packet(pClient, pClient->buf_send, len, &connectTimer)) != SUCCESS_RETURN) {
   \       0x6A   0x466B             MOV      R3,SP
   \       0x6C   0x462A             MOV      R2,R5
   \       0x6E   0x6A61             LDR      R1,[R4, #+36]
   \       0x70   0x4620             MOV      R0,R4
   \       0x72   0x....'....        BL       iotx_mc_send_packet
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0xD008             BEQ.N    ??MQTTConnect_3
    460                  mqtt_err("send connect packet failed");
    461                  _reset_send_buffer(pClient);
   \       0x7C   0x....'....        BL       _reset_send_buffer
    462                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x80   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x84   0x....'....        BL       HAL_MutexUnlock
    463                  return MQTT_NETWORK_ERROR;
   \       0x88   0xF06F 0x000D      MVN      R0,#+13
   \       0x8C   0xBD32             POP      {R1,R4,R5,PC}
    464              }
    465              _reset_send_buffer(pClient);
   \                     ??MQTTConnect_3: (+1)
   \       0x8E   0x....'....        BL       _reset_send_buffer
    466              HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x92   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x96   0x....'....        BL       HAL_MutexUnlock
    467              return SUCCESS_RETURN;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    468          }
    469          

   \                                 In section .text, align 2, keep-with-next
    470          static int iotx_mc_decode_packet(iotx_mc_client_t *c, int *value, int timeout)
    471          {
   \                     iotx_mc_decode_packet: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4614             MOV      R4,R2
    472              char i;
    473              int multiplier = 1;
   \        0xA   0x2701             MOVS     R7,#+1
    474              int len = 0;
   \        0xC   0xF04F 0x0800      MOV      R8,#+0
    475              const int MAX_NO_OF_REMAINING_LENGTH_BYTES = 4;
    476          
    477              if (!c || !value) {
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD02B             BEQ.N    ??iotx_mc_decode_packet_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD029             BEQ.N    ??iotx_mc_decode_packet_0
    478                  return FAIL_RETURN;
    479              }
    480          
    481              *value = 0;
   \       0x18   0x4640             MOV      R0,R8
   \       0x1A   0x6028             STR      R0,[R5, #+0]
    482              do {
    483                  int rc = MQTTPACKET_READ_ERROR;
    484          
    485                  if (++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
   \                     ??iotx_mc_decode_packet_1: (+1)
   \       0x1C   0xF108 0x0801      ADD      R8,R8,#+1
   \       0x20   0xF1B8 0x0F05      CMP      R8,#+5
   \       0x24   0xDA22             BGE.N    ??iotx_mc_decode_packet_0
    486                      return MQTTPACKET_READ_ERROR; /* bad data */
    487                  }
    488          
    489                  rc = c->ipstack.read(&c->ipstack, &i, 1, timeout == 0 ? 1 : timeout);
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD101             BNE.N    ??iotx_mc_decode_packet_2
   \       0x2A   0x2301             MOVS     R3,#+1
   \       0x2C   0xE000             B.N      ??iotx_mc_decode_packet_3
   \                     ??iotx_mc_decode_packet_2: (+1)
   \       0x2E   0x4623             MOV      R3,R4
   \                     ??iotx_mc_decode_packet_3: (+1)
   \       0x30   0x2201             MOVS     R2,#+1
   \       0x32   0x4669             MOV      R1,SP
   \       0x34   0xF106 0x0034      ADD      R0,R6,#+52
   \       0x38   0xF8D6 0xC048      LDR      R12,[R6, #+72]
   \       0x3C   0x47E0             BLX      R12
    490                  if (rc == 0) {
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD014             BEQ.N    ??iotx_mc_decode_packet_0
    491                      return FAIL_RETURN;
    492                  } else if (rc != 1) {
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD10F             BNE.N    ??iotx_mc_decode_packet_4
    493                      return MQTT_NETWORK_ERROR;
    494                  }
    495          
    496                  *value += (i & 127) * multiplier;
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x4C   0xF001 0x017F      AND      R1,R1,#0x7F
   \       0x50   0xFB07 0x0001      MLA      R0,R7,R1,R0
   \       0x54   0x6028             STR      R0,[R5, #+0]
    497                  multiplier *= 128;
   \       0x56   0x01FF             LSLS     R7,R7,#+7
    498              } while ((i & 128) != 0);
   \       0x58   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x5C   0x0600             LSLS     R0,R0,#+24
   \       0x5E   0xD4DD             BMI.N    ??iotx_mc_decode_packet_1
    499          
    500              return len;
   \       0x60   0x4640             MOV      R0,R8
   \                     ??iotx_mc_decode_packet_5: (+1)
   \       0x62   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   \                     ??iotx_mc_decode_packet_4: (+1)
   \       0x66   0xF06F 0x000D      MVN      R0,#+13
   \       0x6A   0xE7FA             B.N      ??iotx_mc_decode_packet_5
   \                     ??iotx_mc_decode_packet_0: (+1)
   \       0x6C   0xF04F 0x30FF      MOV      R0,#-1
   \       0x70   0xE7F7             B.N      ??iotx_mc_decode_packet_5
    501          }
    502          

   \                                 In section .text, align 2, keep-with-next
    503          static int _handle_event(iotx_mqtt_event_handle_pt handle, iotx_mc_client_t *c, iotx_mqtt_event_msg_pt msg)
    504          {
   \                     _handle_event: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0003             MOVS     R3,R0
    505              if (handle == NULL || handle->h_fp == NULL) {
   \        0x4   0xD002             BEQ.N    ??_handle_event_0
   \        0x6   0x6818             LDR      R0,[R3, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD102             BNE.N    ??_handle_event_1
    506                  return FAIL_RETURN;
   \                     ??_handle_event_0: (+1)
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
   \       0x10   0xBD10             POP      {R4,PC}
    507              }
    508          
    509              _in_yield_cb = 1;
   \                     ??_handle_event_1: (+1)
   \       0x12   0x....             LDR.N    R4,??DataTable5_3
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x6020             STR      R0,[R4, #+0]
    510              handle->h_fp(handle->pcontext, c, msg);
   \       0x18   0x6858             LDR      R0,[R3, #+4]
   \       0x1A   0x681B             LDR      R3,[R3, #+0]
   \       0x1C   0x4798             BLX      R3
    511              _in_yield_cb = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6020             STR      R0,[R4, #+0]
    512              return 0;
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
    513          }
    514          

   \                                 In section .text, align 2, keep-with-next
    515          static int iotx_mc_read_packet(iotx_mc_client_t *c, iotx_time_t *timer, unsigned int *packet_type)
    516          {
   \                     iotx_mc_read_packet: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
    517              MQTTHeader header = {0};
    518              int len = 0;
    519              int rem_len = 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9000             STR      R0,[SP, #+0]
    520              int rc = 0;
    521              unsigned int left_t = 0;
    522          
    523              if (!c || !timer || !packet_type) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD003             BEQ.N    ??iotx_mc_read_packet_0
   \       0x12   0x2E00             CMP      R6,#+0
   \       0x14   0xD001             BEQ.N    ??iotx_mc_read_packet_0
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD102             BNE.N    ??iotx_mc_read_packet_1
    524                  return FAIL_RETURN;
   \                     ??iotx_mc_read_packet_0: (+1)
   \       0x1A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1E   0xE0DF             B.N      ??iotx_mc_read_packet_2
    525              }
    526              HAL_MutexLock(c->lock_read_buf);
   \                     ??iotx_mc_read_packet_1: (+1)
   \       0x20   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x24   0x....'....        BL       HAL_MutexLock
    527              rc = _alloc_recv_buffer(c, 0);
    528              if (rc < 0) {
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       _alloc_recv_buffer
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xF100 0x80BB      BMI.W    ??iotx_mc_read_packet_3
    529                  HAL_MutexUnlock(c->lock_read_buf);
    530                  return FAIL_RETURN;
    531              }
    532              /* 1. read the header byte.  This has the packet type in it */
    533              left_t = iotx_time_left(timer);
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0x....'....        BL       iotx_time_left
   \       0x3C   0x0003             MOVS     R3,R0
    534              left_t = (left_t == 0) ? 1 : left_t;
   \       0x3E   0xD100             BNE.N    ??iotx_mc_read_packet_4
   \       0x40   0x2301             MOVS     R3,#+1
    535              rc = c->ipstack.read(&c->ipstack, c->buf_read, 1, left_t);
   \                     ??iotx_mc_read_packet_4: (+1)
   \       0x42   0x2201             MOVS     R2,#+1
   \       0x44   0x6AA1             LDR      R1,[R4, #+40]
   \       0x46   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x4A   0x6CA7             LDR      R7,[R4, #+72]
   \       0x4C   0x47B8             BLX      R7
    536              if (0 == rc) { /* timeout */
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD107             BNE.N    ??iotx_mc_read_packet_5
    537                  *packet_type = MQTT_CPT_RESERVED;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x6028             STR      R0,[R5, #+0]
    538                  HAL_MutexUnlock(c->lock_read_buf);
   \       0x56   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x5A   0x....'....        BL       HAL_MutexUnlock
    539                  return SUCCESS_RETURN;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xE0BE             B.N      ??iotx_mc_read_packet_2
    540              } else if (1 != rc) {
   \                     ??iotx_mc_read_packet_5: (+1)
   \       0x62   0x2801             CMP      R0,#+1
   \       0x64   0xF040 0x8099      BNE.W    ??iotx_mc_read_packet_6
    541                  mqtt_err("mqtt read error, rc=%d", rc);
    542                  HAL_MutexUnlock(c->lock_read_buf);
    543                  return MQTT_NETWORK_ERROR;
    544              }
    545          
    546              len = 1;
    547          
    548              /* 2. read the remaining length.  This is variable in itself */
    549              left_t = iotx_time_left(timer);
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0x....'....        BL       iotx_time_left
    550              left_t = (left_t == 0) ? 1 : left_t;
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD100             BNE.N    ??iotx_mc_read_packet_7
   \       0x72   0x2001             MOVS     R0,#+1
    551              if ((rc = iotx_mc_decode_packet(c, &rem_len, left_t)) < 0) {
   \                     ??iotx_mc_read_packet_7: (+1)
   \       0x74   0x4602             MOV      R2,R0
   \       0x76   0x4669             MOV      R1,SP
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0x....'....        BL       iotx_mc_decode_packet
   \       0x7E   0x0007             MOVS     R7,R0
   \       0x80   0xD505             BPL.N    ??iotx_mc_read_packet_8
    552                  mqtt_err("decodePacket error,rc = %d", rc);
    553                  HAL_MutexUnlock(c->lock_read_buf);
   \       0x82   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x86   0x....'....        BL       HAL_MutexUnlock
    554                  return rc;
   \       0x8A   0x4638             MOV      R0,R7
   \       0x8C   0xE0A8             B.N      ??iotx_mc_read_packet_2
    555              }
    556          
    557              len += MQTTPacket_encode((unsigned char *)c->buf_read + 1,
    558                                       rem_len); /* put the original remaining length back into the buffer */
   \                     ??iotx_mc_read_packet_8: (+1)
   \       0x8E   0x9900             LDR      R1,[SP, #+0]
   \       0x90   0x6AA0             LDR      R0,[R4, #+40]
   \       0x92   0x1C40             ADDS     R0,R0,#+1
   \       0x94   0x....'....        BL       MQTTPacket_encode
   \       0x98   0x4607             MOV      R7,R0
   \       0x9A   0x1C7F             ADDS     R7,R7,#+1
    559          
    560              rc = _alloc_recv_buffer(c, rem_len + len);
    561              if (rc < 0) {
   \       0x9C   0x9900             LDR      R1,[SP, #+0]
   \       0x9E   0x1879             ADDS     R1,R7,R1
   \       0xA0   0x4620             MOV      R0,R4
   \       0xA2   0x....'....        BL       _alloc_recv_buffer
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xF100 0x8080      BMI.W    ??iotx_mc_read_packet_3
    562                  HAL_MutexUnlock(c->lock_read_buf);
    563                  return FAIL_RETURN;
    564              }
    565          
    566              /* Check if the received data length exceeds mqtt read buffer length */
    567              if ((rem_len > 0) && ((rem_len + len) > c->buf_size_read)) {
   \       0xAC   0x9800             LDR      R0,[SP, #+0]
   \       0xAE   0x2801             CMP      R0,#+1
   \       0xB0   0xDB60             BLT.N    ??iotx_mc_read_packet_9
   \       0xB2   0x69E0             LDR      R0,[R4, #+28]
   \       0xB4   0x9900             LDR      R1,[SP, #+0]
   \       0xB6   0x1879             ADDS     R1,R7,R1
   \       0xB8   0x4288             CMP      R0,R1
   \       0xBA   0xD25B             BCS.N    ??iotx_mc_read_packet_9
    568                  int needReadLen;
    569                  int remainDataLen;
    570          #ifdef PLATFORM_HAS_DYNMEM
    571                  char *remainDataBuf;
    572          #else
    573                  char remainDataBuf[IOTX_MC_RX_MAX_LEN] = {0};
    574          #endif
    575                  mqtt_err("mqtt read buffer is too short, mqttReadBufLen : %u, remainDataLen : %d", c->buf_size_read, rem_len);
    576                  needReadLen = c->buf_size_read - len;
   \       0xBC   0x4680             MOV      R8,R0
   \       0xBE   0xEBA8 0x0807      SUB      R8,R8,R7
    577                  left_t = iotx_time_left(timer);
   \       0xC2   0x4630             MOV      R0,R6
   \       0xC4   0x....'....        BL       iotx_time_left
    578                  left_t = (left_t == 0) ? 1 : left_t;
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD100             BNE.N    ??iotx_mc_read_packet_10
   \       0xCC   0x2001             MOVS     R0,#+1
    579                  rc = c->ipstack.read(&c->ipstack, c->buf_read + len, needReadLen, left_t);
   \                     ??iotx_mc_read_packet_10: (+1)
   \       0xCE   0x4603             MOV      R3,R0
   \       0xD0   0x4642             MOV      R2,R8
   \       0xD2   0x6AA0             LDR      R0,[R4, #+40]
   \       0xD4   0x19C1             ADDS     R1,R0,R7
   \       0xD6   0xF104 0x0034      ADD      R0,R4,#+52
   \       0xDA   0x6CA7             LDR      R7,[R4, #+72]
   \       0xDC   0x47B8             BLX      R7
    580                  if (rc < 0) {
   \       0xDE   0x2800             CMP      R0,#+0
   \       0xE0   0xD45B             BMI.N    ??iotx_mc_read_packet_6
    581                      mqtt_err("mqtt read error");
    582                      HAL_MutexUnlock(c->lock_read_buf);
    583                      return MQTT_NETWORK_ERROR;
    584                  } else if (rc != needReadLen) {
   \       0xE2   0x4540             CMP      R0,R8
   \       0xE4   0xD162             BNE.N    ??iotx_mc_read_packet_3
    585                      mqtt_warning("mqtt read timeout");
    586                      HAL_MutexUnlock(c->lock_read_buf);
    587                      return FAIL_RETURN;
    588                  }
    589          
    590                  /* drop data whitch over the length of mqtt buffer */
    591                  remainDataLen = rem_len - needReadLen;
   \       0xE6   0x9800             LDR      R0,[SP, #+0]
   \       0xE8   0xEBA0 0x0808      SUB      R8,R0,R8
    592          #ifdef PLATFORM_HAS_DYNMEM
    593                  remainDataBuf = mqtt_malloc(remainDataLen + 1);
   \       0xEC   0xF108 0x0001      ADD      R0,R8,#+1
   \       0xF0   0x....'....        BL       HAL_Malloc
   \       0xF4   0x0007             MOVS     R7,R0
    594                  if (!remainDataBuf) {
   \       0xF6   0xD059             BEQ.N    ??iotx_mc_read_packet_3
    595                      mqtt_err("allocate remain buffer failed");
    596                      HAL_MutexUnlock(c->lock_read_buf);
    597                      return FAIL_RETURN;
    598                  }
    599          #else
    600                  if (remainDataLen >= IOTX_MC_RX_MAX_LEN) {
    601                      mqtt_err("IOTX_MC_RX_MAX_LEN too short, remainDataLen: %d, IOTX_MC_RX_MAX_LEN: %d", remainDataLen, IOTX_MC_RX_MAX_LEN);
    602                      HAL_MutexUnlock(c->lock_read_buf);
    603                      return FAIL_RETURN;
    604                  }
    605          #endif
    606          
    607                  left_t = iotx_time_left(timer);
   \       0xF8   0x4630             MOV      R0,R6
   \       0xFA   0x....'....        BL       iotx_time_left
    608                  left_t = (left_t == 0) ? 1 : left_t;
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD100             BNE.N    ??iotx_mc_read_packet_11
   \      0x102   0x2001             MOVS     R0,#+1
    609                  rc = c->ipstack.read(&c->ipstack, remainDataBuf, remainDataLen, left_t);
   \                     ??iotx_mc_read_packet_11: (+1)
   \      0x104   0x4603             MOV      R3,R0
   \      0x106   0x4642             MOV      R2,R8
   \      0x108   0x4639             MOV      R1,R7
   \      0x10A   0xF104 0x0034      ADD      R0,R4,#+52
   \      0x10E   0x6CA6             LDR      R6,[R4, #+72]
   \      0x110   0x47B0             BLX      R6
    610                  if (rc < 0) {
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0xD509             BPL.N    ??iotx_mc_read_packet_12
    611                      mqtt_err("mqtt read error");
    612          #ifdef PLATFORM_HAS_DYNMEM
    613                      mqtt_free(remainDataBuf);
   \      0x116   0x4638             MOV      R0,R7
   \      0x118   0x....'....        BL       HAL_Free
    614                      remainDataBuf = NULL;
    615          #endif
    616                      HAL_MutexUnlock(c->lock_read_buf);
   \      0x11C   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x120   0x....'....        BL       HAL_MutexUnlock
    617                      return MQTT_NETWORK_ERROR;
   \      0x124   0xF06F 0x000D      MVN      R0,#+13
   \      0x128   0xE05A             B.N      ??iotx_mc_read_packet_2
    618                  } else if (rc != remainDataLen) {
   \                     ??iotx_mc_read_packet_12: (+1)
   \      0x12A   0x4540             CMP      R0,R8
   \      0x12C   0x4638             MOV      R0,R7
   \      0x12E   0xD008             BEQ.N    ??iotx_mc_read_packet_13
    619                      mqtt_warning("mqtt read timeout");
    620          #ifdef PLATFORM_HAS_DYNMEM
    621                      mqtt_free(remainDataBuf);
   \      0x130   0x....'....        BL       HAL_Free
    622                      remainDataBuf = NULL;
    623          #endif
    624                      HAL_MutexUnlock(c->lock_read_buf);
   \      0x134   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x138   0x....'....        BL       HAL_MutexUnlock
    625                      return FAIL_RETURN;
   \      0x13C   0xF04F 0x30FF      MOV      R0,#-1
   \      0x140   0xE04E             B.N      ??iotx_mc_read_packet_2
    626                  }
    627          
    628          #ifdef PLATFORM_HAS_DYNMEM
    629                  mqtt_free(remainDataBuf);
   \                     ??iotx_mc_read_packet_13: (+1)
   \      0x142   0x....'....        BL       HAL_Free
    630                  remainDataBuf = NULL;
    631          #endif
    632                  HAL_MutexUnlock(c->lock_read_buf);
   \      0x146   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x14A   0x....'....        BL       HAL_MutexUnlock
    633                  *packet_type = MQTT_CPT_RESERVED;
   \      0x14E   0x2000             MOVS     R0,#+0
   \      0x150   0x6028             STR      R0,[R5, #+0]
    634                  if (NULL != c->handle_event.h_fp) {
   \      0x152   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \      0x156   0x2800             CMP      R0,#+0
   \      0x158   0xD00A             BEQ.N    ??iotx_mc_read_packet_14
    635                      iotx_mqtt_event_msg_t msg;
    636          
    637                      msg.event_type = IOTX_MQTT_EVENT_BUFFER_OVERFLOW;
   \      0x15A   0x200D             MOVS     R0,#+13
   \      0x15C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    638                      msg.msg = "mqtt read buffer is too short";
   \      0x160   0x....             LDR.N    R0,??DataTable5_4
   \      0x162   0x9002             STR      R0,[SP, #+8]
    639                      _handle_event(&c->handle_event, c, &msg);
   \      0x164   0xAA01             ADD      R2,SP,#+4
   \      0x166   0x4621             MOV      R1,R4
   \      0x168   0xF104 0x00E0      ADD      R0,R4,#+224
   \      0x16C   0x....'....        BL       _handle_event
    640                  }
    641          
    642                  return SUCCESS_RETURN;
   \                     ??iotx_mc_read_packet_14: (+1)
   \      0x170   0x2000             MOVS     R0,#+0
   \      0x172   0xE035             B.N      ??iotx_mc_read_packet_2
    643          
    644              }
    645          
    646              /* 3. read the rest of the buffer using a callback to supply the rest of the data */
    647              left_t = iotx_time_left(timer);
   \                     ??iotx_mc_read_packet_9: (+1)
   \      0x174   0x4630             MOV      R0,R6
   \      0x176   0x....'....        BL       iotx_time_left
    648              left_t = (left_t == 0) ? 1 : left_t;
   \      0x17A   0x2800             CMP      R0,#+0
   \      0x17C   0xD100             BNE.N    ??iotx_mc_read_packet_15
   \      0x17E   0x2001             MOVS     R0,#+1
    649          
    650              rc = c->ipstack.read(&c->ipstack, c->buf_read + len, rem_len, left_t);
   \                     ??iotx_mc_read_packet_15: (+1)
   \      0x180   0x4603             MOV      R3,R0
   \      0x182   0x9A00             LDR      R2,[SP, #+0]
   \      0x184   0x6AA0             LDR      R0,[R4, #+40]
   \      0x186   0x19C1             ADDS     R1,R0,R7
   \      0x188   0xF104 0x0034      ADD      R0,R4,#+52
   \      0x18C   0x6CA6             LDR      R6,[R4, #+72]
   \      0x18E   0x47B0             BLX      R6
    651              if (rem_len > 0) {
   \      0x190   0x9900             LDR      R1,[SP, #+0]
   \      0x192   0x2901             CMP      R1,#+1
   \      0x194   0xDB11             BLT.N    ??iotx_mc_read_packet_16
    652                  if (rc < 0) {
   \      0x196   0x2800             CMP      R0,#+0
   \      0x198   0xD506             BPL.N    ??iotx_mc_read_packet_17
    653                      mqtt_err("mqtt read error");
    654                      HAL_MutexUnlock(c->lock_read_buf);
   \                     ??iotx_mc_read_packet_6: (+1)
   \      0x19A   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x19E   0x....'....        BL       HAL_MutexUnlock
    655                      return MQTT_NETWORK_ERROR;
   \      0x1A2   0xF06F 0x000D      MVN      R0,#+13
   \      0x1A6   0xE01B             B.N      ??iotx_mc_read_packet_2
    656                  } else if (rc != rem_len) {
   \                     ??iotx_mc_read_packet_17: (+1)
   \      0x1A8   0x4288             CMP      R0,R1
   \      0x1AA   0xD006             BEQ.N    ??iotx_mc_read_packet_16
    657                      mqtt_warning("mqtt read timeout");
    658                      HAL_MutexUnlock(c->lock_read_buf);
   \                     ??iotx_mc_read_packet_3: (+1)
   \      0x1AC   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x1B0   0x....'....        BL       HAL_MutexUnlock
    659                      return FAIL_RETURN;
   \      0x1B4   0xF04F 0x30FF      MOV      R0,#-1
   \      0x1B8   0xE012             B.N      ??iotx_mc_read_packet_2
    660                  }
    661              }
    662          
    663              header.byte = c->buf_read[0];
    664              *packet_type = MQTT_HEADER_GET_TYPE(header.byte);
   \                     ??iotx_mc_read_packet_16: (+1)
   \      0x1BA   0x6AA0             LDR      R0,[R4, #+40]
   \      0x1BC   0x7800             LDRB     R0,[R0, #+0]
   \      0x1BE   0x0900             LSRS     R0,R0,#+4
   \      0x1C0   0x6028             STR      R0,[R5, #+0]
    665              if ((len + rem_len) < c->buf_size_read) {
   \      0x1C2   0x9800             LDR      R0,[SP, #+0]
   \      0x1C4   0x19C0             ADDS     R0,R0,R7
   \      0x1C6   0x69E1             LDR      R1,[R4, #+28]
   \      0x1C8   0x4288             CMP      R0,R1
   \      0x1CA   0xD204             BCS.N    ??iotx_mc_read_packet_18
    666                  c->buf_read[len + rem_len] = '\0';
   \      0x1CC   0x2100             MOVS     R1,#+0
   \      0x1CE   0x6AA2             LDR      R2,[R4, #+40]
   \      0x1D0   0x9800             LDR      R0,[SP, #+0]
   \      0x1D2   0x19C7             ADDS     R7,R0,R7
   \      0x1D4   0x55D1             STRB     R1,[R2, R7]
    667              }
    668              HAL_MutexUnlock(c->lock_read_buf);
   \                     ??iotx_mc_read_packet_18: (+1)
   \      0x1D6   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x1DA   0x....'....        BL       HAL_MutexUnlock
    669              return SUCCESS_RETURN;
   \      0x1DE   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_read_packet_2: (+1)
   \      0x1E0   0xB004             ADD      SP,SP,#+16
   \      0x1E2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    670          }
    671          

   \                                 In section .text, align 4, keep-with-next
    672          static int iotx_mc_handle_recv_CONNACK(iotx_mc_client_t *c)
    673          {
   \                     iotx_mc_handle_recv_CONNACK: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    674              int rc = SUCCESS_RETURN;
   \        0x2   0x2400             MOVS     R4,#+0
    675              unsigned char connack_rc = 255;
   \        0x4   0x21FF             MOVS     R1,#+255
   \        0x6   0xF88D 0x1000      STRB     R1,[SP, #+0]
    676              char sessionPresent = 0;
   \        0xA   0x4621             MOV      R1,R4
   \        0xC   0xF88D 0x1001      STRB     R1,[SP, #+1]
    677          
    678              if (!c) {
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??iotx_mc_handle_recv_CONNACK_1
    679                  return FAIL_RETURN;
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xBD16             POP      {R1,R2,R4,PC}
    680              }
    681          
    682              if (MQTTDeserialize_connack((unsigned char *)&sessionPresent, &connack_rc, (unsigned char *)c->buf_read,
    683                                          c->buf_size_read) != 1) {
   \                     ??iotx_mc_handle_recv_CONNACK_1: (+1)
   \       0x1A   0x69C3             LDR      R3,[R0, #+28]
   \       0x1C   0x6A82             LDR      R2,[R0, #+40]
   \       0x1E   0x4669             MOV      R1,SP
   \       0x20   0xF10D 0x0001      ADD      R0,SP,#+1
   \       0x24   0x....'....        BL       MQTTDeserialize_connack
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD002             BEQ.N    ??iotx_mc_handle_recv_CONNACK_2
    684                  mqtt_err("connect ack is error");
    685                  return MQTT_CONNECT_ACK_PACKET_ERROR;
   \       0x2C   0xF06F 0x001C      MVN      R0,#+28
   \       0x30   0xBD16             POP      {R1,R2,R4,PC}
    686              }
    687          
    688              switch (connack_rc) {
   \                     ??iotx_mc_handle_recv_CONNACK_2: (+1)
   \       0x32   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x36   0x2805             CMP      R0,#+5
   \       0x38   0xD813             BHI.N    ??iotx_mc_handle_recv_CONNACK_3
   \       0x3A   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??iotx_mc_handle_recv_CONNACK_0:
   \       0x3E   0x14 0x03          DC8      0x14,0x3,0x6,0x9
   \              0x06 0x09    
   \       0x42   0x0C 0x0F          DC8      0xC,0xF
    689                  case IOTX_MC_CONNECTION_ACCEPTED:
    690                      rc = SUCCESS_RETURN;
    691                      break;
    692                  case IOTX_MC_CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION:
    693                      rc = MQTT_CONANCK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_4: (+1)
   \       0x44   0xF06F 0x0425      MVN      R4,#+37
    694                      break;
   \       0x48   0xE00D             B.N      ??iotx_mc_handle_recv_CONNACK_5
    695                  case IOTX_MC_CONNECTION_REFUSED_IDENTIFIER_REJECTED:
    696                      rc = MQTT_CONNACK_IDENTIFIER_REJECTED_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_6: (+1)
   \       0x4A   0xF06F 0x0424      MVN      R4,#+36
    697                      break;
   \       0x4E   0xE00A             B.N      ??iotx_mc_handle_recv_CONNACK_5
    698                  case IOTX_MC_CONNECTION_REFUSED_SERVER_UNAVAILABLE:
    699                      rc = MQTT_CONNACK_SERVER_UNAVAILABLE_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_7: (+1)
   \       0x50   0xF06F 0x0423      MVN      R4,#+35
    700                      break;
   \       0x54   0xE007             B.N      ??iotx_mc_handle_recv_CONNACK_5
    701                  case IOTX_MC_CONNECTION_REFUSED_BAD_USERDATA:
    702                      rc = MQTT_CONNACK_BAD_USERDATA_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_8: (+1)
   \       0x56   0xF06F 0x0422      MVN      R4,#+34
    703                      break;
   \       0x5A   0xE004             B.N      ??iotx_mc_handle_recv_CONNACK_5
    704                  case IOTX_MC_CONNECTION_REFUSED_NOT_AUTHORIZED:
    705                      rc = MQTT_CONNACK_NOT_AUTHORIZED_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_9: (+1)
   \       0x5C   0xF06F 0x0421      MVN      R4,#+33
    706                      break;
   \       0x60   0xE001             B.N      ??iotx_mc_handle_recv_CONNACK_5
    707                  default:
    708                      rc = MQTT_CONNACK_UNKNOWN_ERROR;
   \                     ??iotx_mc_handle_recv_CONNACK_3: (+1)
   \       0x62   0xF06F 0x0426      MVN      R4,#+38
    709                      break;
    710              }
    711          
    712              return rc;
   \                     ??iotx_mc_handle_recv_CONNACK_5: (+1)
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    713          }
    714          

   \                                 In section .text, align 2, keep-with-next
    715          static int iotx_mc_wait_CONNACK(iotx_mc_client_t *c)
    716          {
   \                     iotx_mc_wait_CONNACK: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
    717          #define WAIT_CONNACK_MAX (10)
    718              unsigned char wait_connack = 0;
   \        0x4   0x2600             MOVS     R6,#+0
    719              unsigned int packetType = 0;
   \        0x6   0x4630             MOV      R0,R6
   \        0x8   0x9001             STR      R0,[SP, #+4]
    720              int rc = 0;
    721              iotx_time_t timer;
    722          
    723              if (!c) {
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD102             BNE.N    ??iotx_mc_wait_CONNACK_0
    724                  return FAIL_RETURN;
   \        0xE   0xF04F 0x30FF      MOV      R0,#-1
   \       0x12   0xBD76             POP      {R1,R2,R4-R6,PC}
    725              }
    726          
    727              iotx_time_init(&timer);
   \                     ??iotx_mc_wait_CONNACK_0: (+1)
   \       0x14   0x4668             MOV      R0,SP
   \       0x16   0x....'....        BL       iotx_time_init
    728              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x1A   0x68A9             LDR      R1,[R5, #+8]
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x....'....        BL       utils_time_countdown_ms
    729          
    730              do {
    731                  /* read the socket, see what work is due */
    732          
    733                  rc = iotx_mc_read_packet(c, &timer, &packetType);
   \                     ??iotx_mc_wait_CONNACK_1: (+1)
   \       0x22   0xAA01             ADD      R2,SP,#+4
   \       0x24   0x4669             MOV      R1,SP
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x....'....        BL       iotx_mc_read_packet
   \       0x2C   0x0004             MOVS     R4,R0
    734                  if (rc != SUCCESS_RETURN) {
   \       0x2E   0xD118             BNE.N    ??iotx_mc_wait_CONNACK_2
    735                      mqtt_err("readPacket error,result = %d", rc);
    736                      HAL_MutexLock(c->lock_read_buf);
    737                      _reset_recv_buffer(c);
    738                      HAL_MutexUnlock(c->lock_read_buf);
    739                      return rc;
    740                  }
    741          
    742                  if (++wait_connack > WAIT_CONNACK_MAX) {
   \       0x30   0x1C76             ADDS     R6,R6,#+1
   \       0x32   0x4630             MOV      R0,R6
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x280B             CMP      R0,#+11
   \       0x38   0xDA20             BGE.N    ??iotx_mc_wait_CONNACK_3
    743                      mqtt_err("wait connack timeout");
    744                      HAL_MutexLock(c->lock_read_buf);
    745                      _reset_recv_buffer(c);
    746                      HAL_MutexUnlock(c->lock_read_buf);
    747                      return MQTT_NETWORK_ERROR;
    748                  }
    749              } while (packetType != CONNACK);
   \       0x3A   0x9801             LDR      R0,[SP, #+4]
   \       0x3C   0x2802             CMP      R0,#+2
   \       0x3E   0xD1F0             BNE.N    ??iotx_mc_wait_CONNACK_1
    750              HAL_MutexLock(c->lock_read_buf);
   \       0x40   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x44   0x....'....        BL       HAL_MutexLock
    751          
    752              rc = iotx_mc_handle_recv_CONNACK(c);
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x....'....        BL       iotx_mc_handle_recv_CONNACK
   \       0x4E   0x4604             MOV      R4,R0
    753              _reset_recv_buffer(c);
   \       0x50   0x4628             MOV      R0,R5
   \       0x52   0x....'....        BL       _reset_recv_buffer
    754              HAL_MutexUnlock(c->lock_read_buf);
   \       0x56   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x5A   0x....'....        BL       HAL_MutexUnlock
    755          
    756              if (SUCCESS_RETURN != rc) {
    757                  mqtt_err("recvConnackProc error,result = %d", rc);
    758              }
    759          
    760              return rc;
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??iotx_mc_wait_CONNACK_2: (+1)
   \       0x62   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x66   0x....'....        BL       HAL_MutexLock
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x....'....        BL       _reset_recv_buffer
   \       0x70   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x74   0x....'....        BL       HAL_MutexUnlock
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??iotx_mc_wait_CONNACK_3: (+1)
   \       0x7C   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x80   0x....'....        BL       HAL_MutexLock
   \       0x84   0x4628             MOV      R0,R5
   \       0x86   0x....'....        BL       _reset_recv_buffer
   \       0x8A   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x8E   0x....'....        BL       HAL_MutexUnlock
   \       0x92   0xF06F 0x000D      MVN      R0,#+13
   \       0x96   0xBD76             POP      {R1,R2,R4-R6,PC}
    761          }
    762          

   \                                 In section .text, align 2, keep-with-next
    763          static int _mqtt_connect(void *client)
    764          {
   \                     _mqtt_connect: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
    765          #define RETRY_TIME_LIMIT    (8+1)
    766          #define RETRY_INTV_PERIOD   (2000)
    767              int rc = FAIL_RETURN;
    768              int try_count = 1;
   \        0x4   0x2601             MOVS     R6,#+1
    769              iotx_mc_client_t *pClient = (iotx_mc_client_t *)client;
    770              int userKeepAliveInterval = 0;
    771          
    772              if (NULL == pClient) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD102             BNE.N    ??_mqtt_connect_0
    773                  return NULL_VALUE_ERROR;
   \        0xA   0xF06F 0x0001      MVN      R0,#+1
   \        0xE   0xBDF2             POP      {R1,R4-R7,PC}
    774              }
    775              userKeepAliveInterval = pClient->connect_data.keepAliveInterval;
   \                     ??_mqtt_connect_0: (+1)
   \       0x10   0xF8B5 0x7080      LDRH     R7,[R5, #+128]
    776              pClient->connect_data.keepAliveInterval = CONFIG_MQTT_KEEPALIVE_INTERVAL_MAX;
   \       0x14   0xF44F 0x6096      MOV      R0,#+1200
   \       0x18   0xF8A5 0x0080      STRH     R0,[R5, #+128]
    777              mqtt_info("connect params: MQTTVersion=%d, clientID=%s, keepAliveInterval=%d, username=%s",
    778                        pClient->connect_data.MQTTVersion,
    779                        pClient->connect_data.clientID.cstring,
    780                        pClient->connect_data.keepAliveInterval,
    781                        pClient->connect_data.username.cstring);
    782          
    783              /* Establish TCP or TLS connection */
    784              do {
    785                  rc = MQTTConnect(pClient);
   \                     ??_mqtt_connect_1: (+1)
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x....'....        BL       MQTTConnect
   \       0x22   0x0004             MOVS     R4,R0
    786                  pClient->connect_data.keepAliveInterval = userKeepAliveInterval;
   \       0x24   0xF8A5 0x7080      STRH     R7,[R5, #+128]
    787          
    788                  if (rc != SUCCESS_RETURN) {
   \       0x28   0xD11C             BNE.N    ??_mqtt_connect_2
    789                      pClient->ipstack.disconnect(&pClient->ipstack);
    790                      mqtt_err("send connect packet failed, rc = %d", rc);
    791                      return rc;
    792                  }
    793          
    794                  rc = iotx_mc_wait_CONNACK(pClient);
   \       0x2A   0x4628             MOV      R0,R5
   \       0x2C   0x....'....        BL       iotx_mc_wait_CONNACK
    795          
    796                  if (rc <= MQTT_CONNACK_NOT_AUTHORIZED_ERROR && rc >= MQTT_CONANCK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR) {
   \       0x30   0xF100 0x0126      ADD      R1,R0,#+38
   \       0x34   0x2905             CMP      R1,#+5
   \       0x36   0xD31B             BCC.N    ??_mqtt_connect_3
    797                      mqtt_err("received reject ACK from MQTT server! rc = %d", rc);
    798                      pClient->ipstack.disconnect(&pClient->ipstack);
    799                      return MQTT_CONNECT_ERROR;
    800                  }
    801          
    802                  if (SUCCESS_RETURN != rc) {
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD00E             BEQ.N    ??_mqtt_connect_4
    803                      mqtt_err("wait connect ACK timeout! rc = %d", rc);
    804                      mqtt_warning("tried [%d/%d] times CONN, waiting for %d ms...", try_count, RETRY_TIME_LIMIT - 1, RETRY_INTV_PERIOD);
    805          
    806                      HAL_SleepMs(RETRY_INTV_PERIOD);
   \       0x3C   0xF44F 0x60FA      MOV      R0,#+2000
   \       0x40   0x....'....        BL       HAL_SleepMs
    807          
    808                      pClient->ipstack.disconnect(&pClient->ipstack);
   \       0x44   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x48   0x6D29             LDR      R1,[R5, #+80]
   \       0x4A   0x4788             BLX      R1
    809                      pClient->ipstack.connect(&pClient->ipstack);
   \       0x4C   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x50   0x6D69             LDR      R1,[R5, #+84]
   \       0x52   0x4788             BLX      R1
    810                      continue;
    811                  } else {
    812                      break;
    813                  }
    814          
    815              } while (++try_count < RETRY_TIME_LIMIT);
   \       0x54   0x1C76             ADDS     R6,R6,#+1
   \       0x56   0x2E09             CMP      R6,#+9
   \       0x58   0xDBE0             BLT.N    ??_mqtt_connect_1
    816          
    817              if (try_count == RETRY_TIME_LIMIT) {
   \                     ??_mqtt_connect_4: (+1)
   \       0x5A   0x2E09             CMP      R6,#+9
   \       0x5C   0xD10F             BNE.N    ??_mqtt_connect_5
    818                  return MQTT_CONNECT_ERROR;
   \       0x5E   0xF06F 0x0020      MVN      R0,#+32
   \       0x62   0xBDF2             POP      {R1,R4-R7,PC}
    819              }
   \                     ??_mqtt_connect_2: (+1)
   \       0x64   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x68   0x6D29             LDR      R1,[R5, #+80]
   \       0x6A   0x4788             BLX      R1
   \       0x6C   0x4620             MOV      R0,R4
   \       0x6E   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??_mqtt_connect_3: (+1)
   \       0x70   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x74   0x6D29             LDR      R1,[R5, #+80]
   \       0x76   0x4788             BLX      R1
   \       0x78   0xF06F 0x0020      MVN      R0,#+32
   \       0x7C   0xBDF2             POP      {R1,R4-R7,PC}
    820              pClient->keepalive_probes = 0;
   \                     ??_mqtt_connect_5: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xF885 0x0020      STRB     R0,[R5, #+32]
    821              iotx_mc_set_client_state(pClient, IOTX_MC_STATE_CONNECTED);
   \       0x84   0x2102             MOVS     R1,#+2
   \       0x86   0x4628             MOV      R0,R5
   \       0x88   0x....'....        BL       iotx_mc_set_client_state
    822          
    823              utils_time_countdown_ms(&pClient->next_ping_time, pClient->connect_data.keepAliveInterval * 1000);
   \       0x8C   0xF8B5 0x1080      LDRH     R1,[R5, #+128]
   \       0x90   0xF44F 0x707A      MOV      R0,#+1000
   \       0x94   0x4341             MULS     R1,R0,R1
   \       0x96   0xF105 0x0058      ADD      R0,R5,#+88
   \       0x9A   0x....'....        BL       utils_time_countdown_ms
    824          
    825              mqtt_info("mqtt connect success!");
    826              return SUCCESS_RETURN;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    827          }
    828          
    829          #if !WITH_MQTT_ONLY_QOS0

   \                                 In section .text, align 2, keep-with-next
    830          static int iotx_mc_push_pubInfo_to(iotx_mc_client_t *c, int len, unsigned short msgId, iotx_mc_pub_info_t **node)
    831          {
   \                     iotx_mc_push_pubInfo_to: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x461D             MOV      R5,R3
    832          #ifdef PLATFORM_HAS_DYNMEM
    833              int list_number;
    834              iotx_mc_pub_info_t *repubInfo;
    835          #else
    836              int idx;
    837          #endif
    838          
    839              if (!c || !node) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD001             BEQ.N    ??iotx_mc_push_pubInfo_to_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD102             BNE.N    ??iotx_mc_push_pubInfo_to_1
    840                  mqtt_err("the param of c is error!");
    841                  return FAIL_RETURN;
   \                     ??iotx_mc_push_pubInfo_to_0: (+1)
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xE034             B.N      ??iotx_mc_push_pubInfo_to_2
    842              }
    843          
    844              if ((len < 0) || (len > c->buf_size_send)) {
   \                     ??iotx_mc_push_pubInfo_to_1: (+1)
   \       0x1A   0x2F00             CMP      R7,#+0
   \       0x1C   0xD402             BMI.N    ??iotx_mc_push_pubInfo_to_3
   \       0x1E   0x6930             LDR      R0,[R6, #+16]
   \       0x20   0x42B8             CMP      R0,R7
   \       0x22   0xD202             BCS.N    ??iotx_mc_push_pubInfo_to_4
    845                  mqtt_err("the param of len is error!");
    846          #ifndef PLATFORM_HAS_DYNMEM
    847                  if (len >= c->buf_size_send) {
    848                      mqtt_err("IOTX_MC_TX_MAX_LEN is too short, len: %d, IOTX_MC_TX_MAX_LEN: %d", len, IOTX_MC_TX_MAX_LEN);
    849                  }
    850          #endif
    851                  return FAIL_RETURN;
   \                     ??iotx_mc_push_pubInfo_to_3: (+1)
   \       0x24   0xF04F 0x30FF      MOV      R0,#-1
   \       0x28   0xE02C             B.N      ??iotx_mc_push_pubInfo_to_2
    852              }
    853          
    854          #ifdef PLATFORM_HAS_DYNMEM
    855              list_number = list_entry_number(&c->list_pub_wait_ack);
    856          
    857              if (list_number >= IOTX_MC_REPUB_NUM_MAX) {
   \                     ??iotx_mc_push_pubInfo_to_4: (+1)
   \       0x2A   0xF106 0x00C0      ADD      R0,R6,#+192
   \       0x2E   0x....'....        BL       __dlist_entry_number
   \       0x32   0x2814             CMP      R0,#+20
   \       0x34   0xDB02             BLT.N    ??iotx_mc_push_pubInfo_to_5
    858                  mqtt_err("more than %u elements in republish list. List overflow!", list_number);
    859                  return FAIL_RETURN;
   \       0x36   0xF04F 0x30FF      MOV      R0,#-1
   \       0x3A   0xE023             B.N      ??iotx_mc_push_pubInfo_to_2
    860              }
    861          
    862              repubInfo = (iotx_mc_pub_info_t *)mqtt_malloc(sizeof(iotx_mc_pub_info_t) + len);
   \                     ??iotx_mc_push_pubInfo_to_5: (+1)
   \       0x3C   0xF107 0x0018      ADD      R0,R7,#+24
   \       0x40   0x....'....        BL       HAL_Malloc
   \       0x44   0x0004             MOVS     R4,R0
    863              if (NULL == repubInfo) {
   \       0x46   0xD102             BNE.N    ??iotx_mc_push_pubInfo_to_6
    864                  mqtt_err("run iotx_memory_malloc is error!");
    865                  return FAIL_RETURN;
   \       0x48   0xF04F 0x30FF      MOV      R0,#-1
   \       0x4C   0xE01A             B.N      ??iotx_mc_push_pubInfo_to_2
    866              }
    867          
    868              repubInfo->node_state = IOTX_MC_NODE_STATE_NORMANL;
   \                     ??iotx_mc_push_pubInfo_to_6: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x7120             STRB     R0,[R4, #+4]
    869              repubInfo->msg_id = msgId;
   \       0x52   0xF8A4 0x8006      STRH     R8,[R4, #+6]
    870              repubInfo->len = len;
   \       0x56   0x60A7             STR      R7,[R4, #+8]
    871              iotx_time_start(&repubInfo->pub_start_time);
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x....'....        BL       iotx_time_start
    872              repubInfo->buf = (unsigned char *)repubInfo + sizeof(iotx_mc_pub_info_t);
   \       0x5E   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x62   0x60E0             STR      R0,[R4, #+12]
    873          
    874              memcpy(repubInfo->buf, c->buf_send, len);
   \       0x64   0x463A             MOV      R2,R7
   \       0x66   0x6A71             LDR      R1,[R6, #+36]
   \       0x68   0x....'....        BL       __aeabi_memcpy
    875              INIT_LIST_HEAD(&repubInfo->linked_list);
   \       0x6C   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x70   0x....'....        BL       INIT_AOS_DLIST_HEAD
    876          
    877              list_add_tail(&repubInfo->linked_list, &c->list_pub_wait_ack);
   \       0x74   0xF106 0x01C0      ADD      R1,R6,#+192
   \       0x78   0xF104 0x0010      ADD      R0,R4,#+16
   \       0x7C   0x....'....        BL       dlist_add_tail
    878          
    879              *node = repubInfo;
   \       0x80   0x602C             STR      R4,[R5, #+0]
    880              return SUCCESS_RETURN;
   \       0x82   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_push_pubInfo_to_2: (+1)
   \       0x84   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    881          #else
    882              for (idx = 0; idx < IOTX_MC_PUBWAIT_LIST_MAX_LEN; idx++) {
    883                  if (c->list_pub_wait_ack[idx].used == 0) {
    884                      c->list_pub_wait_ack[idx].node_state = IOTX_MC_NODE_STATE_NORMANL;
    885                      c->list_pub_wait_ack[idx].msg_id = msgId;
    886                      c->list_pub_wait_ack[idx].len = len;
    887                      iotx_time_start(&c->list_pub_wait_ack[idx].pub_start_time);
    888                      memcpy(c->list_pub_wait_ack[idx].buf, c->buf_send, len);
    889                      c->list_pub_wait_ack[idx].used = 1;
    890                      *node = &c->list_pub_wait_ack[idx];
    891                      return SUCCESS_RETURN;
    892                  }
    893              }
    894          
    895              mqtt_err("IOTX_MC_PUBWAIT_LIST_MAX_LEN is too short");
    896          
    897              return FAIL_RETURN;
    898          #endif
    899          }
    900          

   \                                 In section .text, align 2, keep-with-next
    901          static int iotx_mc_mask_pubInfo_from(iotx_mc_client_t *c, uint16_t msgId)
    902          {
   \                     iotx_mc_mask_pubInfo_from: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    903          #ifdef PLATFORM_HAS_DYNMEM
    904              iotx_mc_pub_info_t *node = NULL;
    905          
    906              if (!c) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??iotx_mc_mask_pubInfo_from_0
    907                  return FAIL_RETURN;
   \        0xA   0xF04F 0x30FF      MOV      R0,#-1
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
    908              }
    909          
    910              HAL_MutexLock(c->lock_list_pub);
   \                     ??iotx_mc_mask_pubInfo_from_0: (+1)
   \       0x10   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x14   0x....'....        BL       HAL_MutexLock
    911              list_for_each_entry(node, &c->list_pub_wait_ack, linked_list, iotx_mc_pub_info_t) {
   \       0x18   0xF8D4 0x00C4      LDR      R0,[R4, #+196]
   \       0x1C   0x3810             SUBS     R0,R0,#+16
   \       0x1E   0xE007             B.N      ??iotx_mc_mask_pubInfo_from_1
    912                  if (node->msg_id == msgId) {
   \                     ??iotx_mc_mask_pubInfo_from_2: (+1)
   \       0x20   0x88C1             LDRH     R1,[R0, #+6]
   \       0x22   0x462A             MOV      R2,R5
   \       0x24   0x4291             CMP      R1,R2
   \       0x26   0xD101             BNE.N    ??iotx_mc_mask_pubInfo_from_3
    913                      node->node_state = IOTX_MC_NODE_STATE_INVALID; /* mark as invalid node */
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x7101             STRB     R1,[R0, #+4]
    914                  }
    915              }
   \                     ??iotx_mc_mask_pubInfo_from_3: (+1)
   \       0x2C   0x6940             LDR      R0,[R0, #+20]
   \       0x2E   0x3810             SUBS     R0,R0,#+16
   \                     ??iotx_mc_mask_pubInfo_from_1: (+1)
   \       0x30   0xF100 0x0110      ADD      R1,R0,#+16
   \       0x34   0xF104 0x02C0      ADD      R2,R4,#+192
   \       0x38   0x4291             CMP      R1,R2
   \       0x3A   0xD1F1             BNE.N    ??iotx_mc_mask_pubInfo_from_2
    916              HAL_MutexUnlock(c->lock_list_pub);
   \       0x3C   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x40   0x....'....        BL       HAL_MutexUnlock
    917          #else
    918              int idx;
    919          
    920              for (idx = 0; idx < IOTX_MC_PUBWAIT_LIST_MAX_LEN; idx++) {
    921                  if (c->list_pub_wait_ack[idx].used &&
    922                      c->list_pub_wait_ack[idx].msg_id == msgId) {
    923                      c->list_pub_wait_ack[idx].node_state = IOTX_MC_NODE_STATE_INVALID; /* mark as invalid node */
    924                  }
    925              }
    926          #endif
    927              return SUCCESS_RETURN;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    928          }
    929          

   \                                 In section .text, align 2, keep-with-next
    930          static int MQTTRePublish(iotx_mc_client_t *c, char *buf, int len)
    931          {
   \                     MQTTRePublish: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    932              iotx_time_t timer;
    933              iotx_time_init(&timer);
   \        0x8   0x4668             MOV      R0,SP
   \        0xA   0x....'....        BL       iotx_time_init
    934              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \        0xE   0x68A1             LDR      R1,[R4, #+8]
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x....'....        BL       utils_time_countdown_ms
    935          
    936              HAL_MutexLock(c->lock_write_buf);
   \       0x16   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x1A   0x....'....        BL       HAL_MutexLock
    937          
    938              if (iotx_mc_send_packet(c, buf, len, &timer) != SUCCESS_RETURN) {
   \       0x1E   0x466B             MOV      R3,SP
   \       0x20   0x4632             MOV      R2,R6
   \       0x22   0x4629             MOV      R1,R5
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       iotx_mc_send_packet
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x30   0xD004             BEQ.N    ??MQTTRePublish_0
    939                  HAL_MutexUnlock(c->lock_write_buf);
   \       0x32   0x....'....        BL       HAL_MutexUnlock
    940                  return MQTT_NETWORK_ERROR;
   \       0x36   0xF06F 0x000D      MVN      R0,#+13
   \       0x3A   0xBD76             POP      {R1,R2,R4-R6,PC}
    941              }
    942          
    943              HAL_MutexUnlock(c->lock_write_buf);
   \                     ??MQTTRePublish_0: (+1)
   \       0x3C   0x....'....        BL       HAL_MutexUnlock
    944              return SUCCESS_RETURN;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    945          }
    946          

   \                                 In section .text, align 2, keep-with-next
    947          static int MQTTPubInfoProc(iotx_mc_client_t *pClient)
    948          {
   \                     MQTTPubInfoProc: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    949              int rc = 0;
    950              iotx_mc_state_t state = IOTX_MC_STATE_INVALID;
    951          #ifdef PLATFORM_HAS_DYNMEM
    952              iotx_mc_pub_info_t *node = NULL, *next_node = NULL;
    953          #else
    954              int idx;
    955          #endif
    956          
    957              if (!pClient) {
   \        0x4   0xD102             BNE.N    ??MQTTPubInfoProc_0
    958                  return FAIL_RETURN;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBDF2             POP      {R1,R4-R7,PC}
    959              }
    960          
    961              HAL_MutexLock(pClient->lock_list_pub);
   \                     ??MQTTPubInfoProc_0: (+1)
   \        0xC   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x10   0x....'....        BL       HAL_MutexLock
    962          #ifdef PLATFORM_HAS_DYNMEM
    963              list_for_each_entry_safe(node, next_node, &pClient->list_pub_wait_ack, linked_list, iotx_mc_pub_info_t) {
   \       0x14   0xF8D4 0x00C4      LDR      R0,[R4, #+196]
   \       0x18   0xF1A0 0x0510      SUB      R5,R0,#+16
   \       0x1C   0x6968             LDR      R0,[R5, #+20]
   \       0x1E   0xF1A0 0x0610      SUB      R6,R0,#+16
   \       0x22   0xE00A             B.N      ??MQTTPubInfoProc_1
    964                  /* remove invalid node */
    965                  if (IOTX_MC_NODE_STATE_INVALID == node->node_state) {
    966                      list_del(&node->linked_list);
   \                     ??MQTTPubInfoProc_2: (+1)
   \       0x24   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x28   0x....'....        BL       dlist_del
    967                      mqtt_free(node);
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x....'....        BL       HAL_Free
    968                      continue;
    969                  }
   \                     ??MQTTPubInfoProc_3: (+1)
   \       0x32   0x4635             MOV      R5,R6
   \       0x34   0x6970             LDR      R0,[R6, #+20]
   \       0x36   0xF1A0 0x0610      SUB      R6,R0,#+16
   \                     ??MQTTPubInfoProc_1: (+1)
   \       0x3A   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x3E   0xF104 0x01C0      ADD      R1,R4,#+192
   \       0x42   0x4288             CMP      R0,R1
   \       0x44   0xD01E             BEQ.N    ??MQTTPubInfoProc_4
   \       0x46   0x7928             LDRB     R0,[R5, #+4]
   \       0x48   0x2801             CMP      R0,#+1
   \       0x4A   0xD0EB             BEQ.N    ??MQTTPubInfoProc_2
    970          
    971                  state = iotx_mc_get_client_state(pClient);
    972                  if (state != IOTX_MC_STATE_CONNECTED) {
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x....'....        BL       iotx_mc_get_client_state
   \       0x52   0x2802             CMP      R0,#+2
   \       0x54   0xD1ED             BNE.N    ??MQTTPubInfoProc_3
    973                      continue;
    974                  }
    975          
    976                  /* check the request if timeout or not */
    977                  if (utils_time_spend(&node->pub_start_time) <= (pClient->request_timeout_ms * 2)) {
   \       0x56   0x4628             MOV      R0,R5
   \       0x58   0x....'....        BL       utils_time_spend
   \       0x5C   0x68A1             LDR      R1,[R4, #+8]
   \       0x5E   0x0049             LSLS     R1,R1,#+1
   \       0x60   0x4281             CMP      R1,R0
   \       0x62   0xD2E6             BCS.N    ??MQTTPubInfoProc_3
    978                      continue;
    979                  }
    980          
    981                  /* If wait ACK timeout, republish */
    982                  rc = MQTTRePublish(pClient, (char *)node->buf, node->len);
   \       0x64   0x68AA             LDR      R2,[R5, #+8]
   \       0x66   0x68E9             LDR      R1,[R5, #+12]
   \       0x68   0x4620             MOV      R0,R4
   \       0x6A   0x....'....        BL       MQTTRePublish
   \       0x6E   0x4607             MOV      R7,R0
    983                  iotx_time_start(&node->pub_start_time);
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x....'....        BL       iotx_time_start
    984          
    985                  if (MQTT_NETWORK_ERROR == rc) {
   \       0x76   0xF117 0x0F0E      CMN      R7,#+14
   \       0x7A   0xD1DA             BNE.N    ??MQTTPubInfoProc_3
    986                      iotx_mc_set_client_state(pClient, IOTX_MC_STATE_DISCONNECTED);
   \       0x7C   0x2103             MOVS     R1,#+3
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0x....'....        BL       iotx_mc_set_client_state
    987                      break;
    988                  }
    989              }
    990          #else
    991              for (idx = 0; idx < IOTX_MC_PUBWAIT_LIST_MAX_LEN; idx++) {
    992                  if (pClient->list_pub_wait_ack[idx].used == 0) {
    993                      continue;
    994                  }
    995          
    996                  if (IOTX_MC_NODE_STATE_INVALID == pClient->list_pub_wait_ack[idx].node_state) {
    997                      memset(&pClient->list_pub_wait_ack[idx], 0, sizeof(iotx_mc_pub_info_t));
    998                      continue;
    999                  }
   1000          
   1001                  state = iotx_mc_get_client_state(pClient);
   1002                  if (state != IOTX_MC_STATE_CONNECTED) {
   1003                      continue;
   1004                  }
   1005          
   1006                  /* check the request if timeout or not */
   1007                  if (utils_time_spend(&pClient->list_pub_wait_ack[idx].pub_start_time) <= (pClient->request_timeout_ms * 2)) {
   1008                      continue;
   1009                  }
   1010          
   1011                  /* If wait ACK timeout, republish */
   1012                  rc = MQTTRePublish(pClient, (char *)pClient->list_pub_wait_ack[idx].buf, pClient->list_pub_wait_ack[idx].len);
   1013                  iotx_time_start(&pClient->list_pub_wait_ack[idx].pub_start_time);
   1014          
   1015                  if (MQTT_NETWORK_ERROR == rc) {
   1016                      iotx_mc_set_client_state(pClient, IOTX_MC_STATE_DISCONNECTED);
   1017                      break;
   1018                  }
   1019              }
   1020          #endif
   1021              HAL_MutexUnlock(pClient->lock_list_pub);
   \                     ??MQTTPubInfoProc_4: (+1)
   \       0x84   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x88   0x....'....        BL       HAL_MutexUnlock
   1022          
   1023              return SUCCESS_RETURN;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1024          }
   1025          
   1026          /* handle PUBACK packet received from remote MQTT broker */

   \                                 In section .text, align 2, keep-with-next
   1027          static int iotx_mc_handle_recv_PUBACK(iotx_mc_client_t *c)
   1028          {
   \                     iotx_mc_handle_recv_PUBACK: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1029              unsigned short mypacketid;
   1030              unsigned char dup = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   1031              unsigned char type = 0;
   \        0x6   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1032          
   1033              if (!c) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??iotx_mc_handle_recv_PUBACK_0
   1034                  return FAIL_RETURN;
   \        0xE   0xF04F 0x30FF      MOV      R0,#-1
   \       0x12   0xE024             B.N      ??iotx_mc_handle_recv_PUBACK_1
   1035              }
   1036          
   1037              if (MQTTDeserialize_ack(&type, &dup, &mypacketid, (unsigned char *)c->buf_read, c->buf_size_read) != 1) {
   \                     ??iotx_mc_handle_recv_PUBACK_0: (+1)
   \       0x14   0x69E0             LDR      R0,[R4, #+28]
   \       0x16   0x9000             STR      R0,[SP, #+0]
   \       0x18   0x6AA3             LDR      R3,[R4, #+40]
   \       0x1A   0xF10D 0x0206      ADD      R2,SP,#+6
   \       0x1E   0xF10D 0x0105      ADD      R1,SP,#+5
   \       0x22   0xA801             ADD      R0,SP,#+4
   \       0x24   0x....'....        BL       MQTTDeserialize_ack
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD002             BEQ.N    ??iotx_mc_handle_recv_PUBACK_2
   1038                  return MQTT_PUBLISH_ACK_PACKET_ERROR;
   \       0x2C   0xF06F 0x0012      MVN      R0,#+18
   \       0x30   0xE015             B.N      ??iotx_mc_handle_recv_PUBACK_1
   1039              }
   1040          
   1041              (void)iotx_mc_mask_pubInfo_from(c, mypacketid);
   \                     ??iotx_mc_handle_recv_PUBACK_2: (+1)
   \       0x32   0xF8BD 0x1006      LDRH     R1,[SP, #+6]
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0x....'....        BL       iotx_mc_mask_pubInfo_from
   1042          
   1043              /* call callback function to notify that PUBLISH is successful */
   1044              if (NULL != c->handle_event.h_fp) {
   \       0x3C   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD00B             BEQ.N    ??iotx_mc_handle_recv_PUBACK_3
   1045                  iotx_mqtt_event_msg_t msg;
   1046                  msg.event_type = IOTX_MQTT_EVENT_PUBLISH_SUCCESS;
   \       0x44   0x2009             MOVS     R0,#+9
   \       0x46   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1047                  msg.msg = (void *)(uintptr_t)mypacketid;
   \       0x4A   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \       0x4E   0x9003             STR      R0,[SP, #+12]
   1048                  _handle_event(&c->handle_event, c, &msg);
   \       0x50   0xAA02             ADD      R2,SP,#+8
   \       0x52   0x4621             MOV      R1,R4
   \       0x54   0xF104 0x00E0      ADD      R0,R4,#+224
   \       0x58   0x....'....        BL       _handle_event
   1049              }
   1050          
   1051              return SUCCESS_RETURN;
   \                     ??iotx_mc_handle_recv_PUBACK_3: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_handle_recv_PUBACK_1: (+1)
   \       0x5E   0xB004             ADD      SP,SP,#+16
   \       0x60   0xBD10             POP      {R4,PC}          ;; return
   1052          }
   1053          #endif
   1054          

   \                                 In section .text, align 2, keep-with-next
   1055          static void _iotx_mqtt_event_handle_sub(void *pcontext, void *pclient, iotx_mqtt_event_msg_pt msg)
   1056          {
   \                     _iotx_mqtt_event_handle_sub: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
   1057              iotx_mc_client_t *client;
   1058              uintptr_t packet_id;
   1059          #ifdef PLATFORM_HAS_DYNMEM
   1060              mqtt_sub_sync_node_t *node = NULL;
   1061              mqtt_sub_sync_node_t *next = NULL;
   1062          #else
   1063              int idx;
   1064          #endif
   1065          
   1066              if (pclient == NULL || msg == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD01E             BEQ.N    ??_iotx_mqtt_event_handle_sub_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD01C             BEQ.N    ??_iotx_mqtt_event_handle_sub_0
   1067                  return;
   1068              }
   1069          
   1070              client = (iotx_mc_client_t *)pclient;
   1071              packet_id = (uintptr_t) msg->msg;
   \        0xE   0x686E             LDR      R6,[R5, #+4]
   1072          
   1073              mqtt_debug("packet_id = %lu, event_type=%d", packet_id, msg->event_type);
   1074          
   1075              HAL_MutexLock(client->lock_generic);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x....'....        BL       HAL_MutexLock
   1076          #ifdef PLATFORM_HAS_DYNMEM
   1077              list_for_each_entry_safe(node, next, &client->list_sub_sync_ack, linked_list, mqtt_sub_sync_node_t) {
   \       0x16   0xF8D4 0x00CC      LDR      R0,[R4, #+204]
   \       0x1A   0x380C             SUBS     R0,R0,#+12
   \       0x1C   0x6901             LDR      R1,[R0, #+16]
   \       0x1E   0x390C             SUBS     R1,R1,#+12
   \       0x20   0xF104 0x03C8      ADD      R3,R4,#+200
   \       0x24   0xE007             B.N      ??_iotx_mqtt_event_handle_sub_1
   1078                  if (node->packet_id == packet_id) {
   \                     ??_iotx_mqtt_event_handle_sub_2: (+1)
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x42B2             CMP      R2,R6
   \       0x2A   0xD101             BNE.N    ??_iotx_mqtt_event_handle_sub_3
   1079                      node->ack_type = msg->event_type;
   \       0x2C   0x782A             LDRB     R2,[R5, #+0]
   \       0x2E   0x7102             STRB     R2,[R0, #+4]
   1080                  }
   1081              }
   \                     ??_iotx_mqtt_event_handle_sub_3: (+1)
   \       0x30   0x4608             MOV      R0,R1
   \       0x32   0x6909             LDR      R1,[R1, #+16]
   \       0x34   0x390C             SUBS     R1,R1,#+12
   \                     ??_iotx_mqtt_event_handle_sub_1: (+1)
   \       0x36   0xF100 0x020C      ADD      R2,R0,#+12
   \       0x3A   0x429A             CMP      R2,R3
   \       0x3C   0xD1F3             BNE.N    ??_iotx_mqtt_event_handle_sub_2
   1082          #else
   1083              for (idx = 0; idx < IOTX_MC_SUBSYNC_LIST_MAX_LEN; idx++) {
   1084                  if (client->list_sub_sync_ack[idx].used &&
   1085                      client->list_sub_sync_ack[idx].packet_id == packet_id) {
   1086                      client->list_sub_sync_ack[idx].ack_type = msg->event_type;
   1087                  }
   1088              }
   1089          #endif
   1090              HAL_MutexUnlock(client->lock_generic);
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x44   0x....'....        B.W      HAL_MutexUnlock
   \                     ??_iotx_mqtt_event_handle_sub_0: (+1)
   \       0x48   0xBD70             POP      {R4-R6,PC}       ;; return
   1091          }
   1092          

   \                                 In section .text, align 2, keep-with-next
   1093          static int iotx_mc_handle_recv_SUBACK(iotx_mc_client_t *c)
   1094          {
   \                     iotx_mc_handle_recv_SUBACK: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB08B             SUB      SP,SP,#+44
   \        0x4   0x4604             MOV      R4,R0
   1095              unsigned short mypacketid;
   1096              iotx_mqtt_event_msg_t msg;
   1097              int i = 0, count = 0, fail_flag = -1, j = 0;
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0x4638             MOV      R0,R7
   \        0xA   0x9002             STR      R0,[SP, #+8]
   \        0xC   0xF04F 0x35FF      MOV      R5,#-1
   \       0x10   0x4606             MOV      R6,R0
   1098              int grantedQoS[MUTLI_SUBSCIRBE_MAX];
   1099              int rc;
   1100          
   1101              if (!c) {
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD101             BNE.N    ??iotx_mc_handle_recv_SUBACK_0
   1102                  return FAIL_RETURN;
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0xE035             B.N      ??iotx_mc_handle_recv_SUBACK_1
   1103              }
   1104          
   1105              rc = MQTTDeserialize_suback(&mypacketid, MUTLI_SUBSCIRBE_MAX, &count, grantedQoS, (unsigned char *)c->buf_read,
   1106                                          c->buf_size_read);
   1107          
   1108              if (rc < 0) {
   \                     ??iotx_mc_handle_recv_SUBACK_0: (+1)
   \       0x1A   0x69E0             LDR      R0,[R4, #+28]
   \       0x1C   0x9001             STR      R0,[SP, #+4]
   \       0x1E   0x6AA0             LDR      R0,[R4, #+40]
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0xAB06             ADD      R3,SP,#+24
   \       0x24   0xAA02             ADD      R2,SP,#+8
   \       0x26   0x2105             MOVS     R1,#+5
   \       0x28   0xA803             ADD      R0,SP,#+12
   \       0x2A   0x....'....        BL       MQTTDeserialize_suback
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD503             BPL.N    ??iotx_mc_handle_recv_SUBACK_2
   1109                  mqtt_err("Sub ack packet error, rc = MQTTDeserialize_suback() = %d", rc);
   1110                  return MQTT_SUBSCRIBE_ACK_PACKET_ERROR;
   \       0x32   0xF06F 0x0018      MVN      R0,#+24
   \       0x36   0xE026             B.N      ??iotx_mc_handle_recv_SUBACK_1
   1111              }
   1112          
   1113              mqtt_debug("%20s : %d", "Return Value", rc);
   1114              mqtt_debug("%20s : %d", "Packet ID", mypacketid);
   1115              mqtt_debug("%20s : %d", "Count", count);
   1116              for (i = 0; i < count; ++i) {
   \                     ??iotx_mc_handle_recv_SUBACK_3: (+1)
   \       0x38   0x1C7F             ADDS     R7,R7,#+1
   \                     ??iotx_mc_handle_recv_SUBACK_2: (+1)
   \       0x3A   0x9802             LDR      R0,[SP, #+8]
   \       0x3C   0x4287             CMP      R7,R0
   \       0x3E   0xDBFB             BLT.N    ??iotx_mc_handle_recv_SUBACK_3
   1117                  mqtt_debug("%16s[%02d] : %d", "Granted QoS", i, grantedQoS[i]);
   1118              }
   1119          
   1120              for (j = 0; j <  count; j++) {
   \                     ??iotx_mc_handle_recv_SUBACK_4: (+1)
   \       0x40   0x9802             LDR      R0,[SP, #+8]
   \       0x42   0x4286             CMP      R6,R0
   \       0x44   0xDA21             BGE.N    ??iotx_mc_handle_recv_SUBACK_5
   1121                  fail_flag = 0;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x4605             MOV      R5,R0
   1122                  /* In negative case, grantedQoS will be 0xFFFF FF80, which means -128 */
   1123                  if ((uint8_t)grantedQoS[j] == 0x80) {
   \       0x4A   0xA806             ADD      R0,SP,#+24
   \       0x4C   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0x2880             CMP      R0,#+128
   \       0x54   0xD101             BNE.N    ??iotx_mc_handle_recv_SUBACK_6
   1124                      fail_flag = 1;
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0x4605             MOV      R5,R0
   1125                      mqtt_err("MQTT SUBSCRIBE failed, ack code is 0x80");
   1126                  }
   1127              }
   \                     ??iotx_mc_handle_recv_SUBACK_6: (+1)
   \       0x5A   0x1C76             ADDS     R6,R6,#+1
   \       0x5C   0xE7F0             B.N      ??iotx_mc_handle_recv_SUBACK_4
   1128          
   1129              /* call callback function to notify that SUBSCRIBE is successful */
   1130              msg.msg = (void *)(uintptr_t)mypacketid;
   1131              if (fail_flag == 1) {
   1132                  msg.event_type = IOTX_MQTT_EVENT_SUBCRIBE_NACK;
   1133              } else {
   1134                  msg.event_type = IOTX_MQTT_EVENT_SUBCRIBE_SUCCESS;
   \                     ??iotx_mc_handle_recv_SUBACK_7: (+1)
   \       0x5E   0x2003             MOVS     R0,#+3
   \       0x60   0xF88D 0x0010      STRB     R0,[SP, #+16]
   1135              }
   1136          
   1137              _iotx_mqtt_event_handle_sub(c->handle_event.pcontext, c, &msg);
   \                     ??iotx_mc_handle_recv_SUBACK_8: (+1)
   \       0x64   0xAA04             ADD      R2,SP,#+16
   \       0x66   0x4621             MOV      R1,R4
   \       0x68   0xF8D4 0x00E4      LDR      R0,[R4, #+228]
   \       0x6C   0x....'....        BL       _iotx_mqtt_event_handle_sub
   1138          
   1139              if (NULL != c->handle_event.h_fp) {
   \       0x70   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD005             BEQ.N    ??iotx_mc_handle_recv_SUBACK_9
   1140                  _handle_event(&c->handle_event, c, &msg);
   \       0x78   0xAA04             ADD      R2,SP,#+16
   \       0x7A   0x4621             MOV      R1,R4
   \       0x7C   0xF104 0x00E0      ADD      R0,R4,#+224
   \       0x80   0x....'....        BL       _handle_event
   1141              }
   1142          
   1143              return SUCCESS_RETURN;
   \                     ??iotx_mc_handle_recv_SUBACK_9: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_handle_recv_SUBACK_1: (+1)
   \       0x86   0xB00B             ADD      SP,SP,#+44
   \       0x88   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??iotx_mc_handle_recv_SUBACK_5: (+1)
   \       0x8A   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \       0x8E   0x9005             STR      R0,[SP, #+20]
   \       0x90   0x2D01             CMP      R5,#+1
   \       0x92   0xD1E4             BNE.N    ??iotx_mc_handle_recv_SUBACK_7
   \       0x94   0x2005             MOVS     R0,#+5
   \       0x96   0xF88D 0x0010      STRB     R0,[SP, #+16]
   \       0x9A   0xE7E3             B.N      ??iotx_mc_handle_recv_SUBACK_8
   1144          }
   1145          
   1146          #if WITH_MQTT_ZIP_TOPIC
   1147          #define MQTT_ZIP_PATH_DEFAULT_LEN (32)
   1148          
   1149          static int iotx_mc_get_zip_topic(const char *path, int len, char outbuf[], int outlen)
   1150          {
   1151              unsigned char comp_data[MQTT_ZIP_PATH_DEFAULT_LEN] = {0};
   1152              if (!path || !len || !outbuf || !outlen) {
   1153                  return -1;
   1154              }
   1155          
   1156              utils_sha256((unsigned char *)path, (size_t)len, comp_data);
   1157          
   1158              memcpy(outbuf, comp_data, outlen > MQTT_ZIP_PATH_DEFAULT_LEN ? MQTT_ZIP_PATH_DEFAULT_LEN : outlen);
   1159              return 0;
   1160          }
   1161          #endif
   1162          

   \                                 In section .text, align 2, keep-with-next
   1163          static char iotx_mc_is_topic_matched(char *topicFilter, MQTTString *topicName)
   1164          {
   \                     iotx_mc_is_topic_matched: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x460A             MOV      R2,R1
   1165              char *curf;
   1166              char *curn;
   1167              char *curn_end;
   1168          
   1169              if (!topicFilter || !topicName) {
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD001             BEQ.N    ??iotx_mc_is_topic_matched_0
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0xD101             BNE.N    ??iotx_mc_is_topic_matched_1
   1170                  return 0;
   \                     ??iotx_mc_is_topic_matched_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE02E             B.N      ??iotx_mc_is_topic_matched_2
   1171              }
   1172          
   1173              curf = topicFilter;
   1174              curn = topicName->lenstring.data;
   \                     ??iotx_mc_is_topic_matched_1: (+1)
   \       0x10   0x6891             LDR      R1,[R2, #+8]
   1175              curn_end = curn + topicName->lenstring.len;
   \       0x12   0x6852             LDR      R2,[R2, #+4]
   \       0x14   0x188B             ADDS     R3,R1,R2
   \       0x16   0xE004             B.N      ??iotx_mc_is_topic_matched_3
   1176          
   1177              while (*curf && curn < curn_end) {
   1178                  if (*curn == '/' && *curf != '/') {
   1179                      break;
   1180                  }
   1181          
   1182                  if (*curf != '+' && *curf != '#' && *curf != *curn) {
   1183                      break;
   1184                  }
   1185          
   1186                  if (*curf == '+') {
   1187                      /* skip until we meet the next separator, or end of string */
   1188                      char *nextpos = curn + 1;
   1189                      while (nextpos < curn_end && *nextpos != '/') {
   1190                          nextpos = ++curn + 1;
   1191                      }
   1192                  } else if (*curf == '#') {
   \                     ??iotx_mc_is_topic_matched_4: (+1)
   \       0x18   0x2A23             CMP      R2,#+35
   \       0x1A   0xD100             BNE.N    ??iotx_mc_is_topic_matched_5
   1193                      curn = curn_end - 1;    /* skip until end of string */
   \       0x1C   0x1E59             SUBS     R1,R3,#+1
   1194                  }
   1195                  curf++;
   \                     ??iotx_mc_is_topic_matched_5: (+1)
   \       0x1E   0x1C40             ADDS     R0,R0,#+1
   1196                  curn++;
   \       0x20   0x1C49             ADDS     R1,R1,#+1
   \                     ??iotx_mc_is_topic_matched_3: (+1)
   \       0x22   0x7802             LDRB     R2,[R0, #+0]
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0xD01A             BEQ.N    ??iotx_mc_is_topic_matched_6
   \       0x28   0x4299             CMP      R1,R3
   \       0x2A   0xD218             BCS.N    ??iotx_mc_is_topic_matched_6
   \       0x2C   0x780A             LDRB     R2,[R1, #+0]
   \       0x2E   0x2A2F             CMP      R2,#+47
   \       0x30   0xD102             BNE.N    ??iotx_mc_is_topic_matched_7
   \       0x32   0x7802             LDRB     R2,[R0, #+0]
   \       0x34   0x2A2F             CMP      R2,#+47
   \       0x36   0xD112             BNE.N    ??iotx_mc_is_topic_matched_6
   \                     ??iotx_mc_is_topic_matched_7: (+1)
   \       0x38   0x7802             LDRB     R2,[R0, #+0]
   \       0x3A   0x2A2B             CMP      R2,#+43
   \       0x3C   0xD004             BEQ.N    ??iotx_mc_is_topic_matched_8
   \       0x3E   0x2A23             CMP      R2,#+35
   \       0x40   0xD002             BEQ.N    ??iotx_mc_is_topic_matched_8
   \       0x42   0x780C             LDRB     R4,[R1, #+0]
   \       0x44   0x42A2             CMP      R2,R4
   \       0x46   0xD10A             BNE.N    ??iotx_mc_is_topic_matched_6
   \                     ??iotx_mc_is_topic_matched_8: (+1)
   \       0x48   0x2A2B             CMP      R2,#+43
   \       0x4A   0xD1E5             BNE.N    ??iotx_mc_is_topic_matched_4
   \       0x4C   0x1C4A             ADDS     R2,R1,#+1
   \                     ??iotx_mc_is_topic_matched_9: (+1)
   \       0x4E   0x429A             CMP      R2,R3
   \       0x50   0xD2E5             BCS.N    ??iotx_mc_is_topic_matched_5
   \       0x52   0x7812             LDRB     R2,[R2, #+0]
   \       0x54   0x2A2F             CMP      R2,#+47
   \       0x56   0xD0E2             BEQ.N    ??iotx_mc_is_topic_matched_5
   \       0x58   0x1C49             ADDS     R1,R1,#+1
   \       0x5A   0x1C4A             ADDS     R2,R1,#+1
   \       0x5C   0xE7F7             B.N      ??iotx_mc_is_topic_matched_9
   1197              }
   1198          
   1199              return (curn == curn_end) && (*curf == '\0');
   \                     ??iotx_mc_is_topic_matched_6: (+1)
   \       0x5E   0x4299             CMP      R1,R3
   \       0x60   0xD104             BNE.N    ??iotx_mc_is_topic_matched_10
   \       0x62   0x4610             MOV      R0,R2
   \       0x64   0x1E40             SUBS     R0,R0,#+1
   \       0x66   0x4180             SBCS     R0,R0,R0
   \       0x68   0x0FC0             LSRS     R0,R0,#+31
   \       0x6A   0xE000             B.N      ??iotx_mc_is_topic_matched_2
   \                     ??iotx_mc_is_topic_matched_10: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_is_topic_matched_2: (+1)
   \       0x6E   0xBC10             POP      {R4}
   \       0x70   0x4770             BX       LR               ;; return
   1200          }
   1201          

   \                                 In section .text, align 2, keep-with-next
   1202          static void iotx_mc_deliver_message(iotx_mc_client_t *c, MQTTString *topicName, iotx_mqtt_topic_info_pt topic_msg)
   1203          {
   \                     iotx_mc_deliver_message: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   1204              int flag_matched = 0;
   \        0xA   0x2700             MOVS     R7,#+0
   1205              MQTTString *compare_topic = NULL;
   1206          #ifdef PLATFORM_HAS_DYNMEM
   1207              iotx_mc_topic_handle_t *node = NULL;
   1208          #else
   1209              int idx = 0;
   1210          #endif
   1211          
   1212          #if WITH_MQTT_ZIP_TOPIC
   1213              MQTTString      md5_topic;
   1214              char            md5_topic_data[MQTT_ZIP_PATH_DEFAULT_LEN] = {0};
   1215              char           *net_topic;
   1216              uint32_t        net_topic_len;
   1217          #endif
   1218          
   1219              if (!c || !topicName || !topic_msg) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD04E             BEQ.N    ??iotx_mc_deliver_message_0
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD04C             BEQ.N    ??iotx_mc_deliver_message_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD04A             BEQ.N    ??iotx_mc_deliver_message_0
   1220                  return;
   1221              }
   1222          
   1223              topic_msg->ptopic = topicName->lenstring.data;
   \       0x18   0x68B0             LDR      R0,[R6, #+8]
   \       0x1A   0x60E8             STR      R0,[R5, #+12]
   1224              topic_msg->topic_len = topicName->lenstring.len;
   \       0x1C   0x6870             LDR      R0,[R6, #+4]
   \       0x1E   0x80E8             STRH     R0,[R5, #+6]
   1225          
   1226          #if WITH_MQTT_ZIP_TOPIC
   1227              if (topicName->cstring) {
   1228                  net_topic = topicName->cstring;
   1229                  net_topic_len = strlen(topicName->cstring);
   1230              } else {
   1231                  net_topic = topicName->lenstring.data;
   1232                  net_topic_len = topicName->lenstring.len;
   1233              }
   1234              md5_topic.cstring = NULL;
   1235              md5_topic.lenstring.data = md5_topic_data;
   1236              md5_topic.lenstring.len = MQTT_ZIP_PATH_DEFAULT_LEN;
   1237              iotx_mc_get_zip_topic(net_topic, net_topic_len, md5_topic_data, MQTT_ZIP_PATH_DEFAULT_LEN);
   1238              compare_topic = &md5_topic;
   1239          #else
   1240              compare_topic = topicName;
   1241          #endif
   1242          
   1243              /* we have to find the right message handler - indexed by topic */
   1244              HAL_MutexLock(c->lock_generic);
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x....'....        BL       HAL_MutexLock
   1245          #ifdef PLATFORM_HAS_DYNMEM
   1246              list_for_each_entry(node, &c->list_sub_handle, linked_list, iotx_mc_topic_handle_t) {
   \       0x26   0x6B20             LDR      R0,[R4, #+48]
   \       0x28   0xF1A0 0x0810      SUB      R8,R0,#+16
   \       0x2C   0xE026             B.N      ??iotx_mc_deliver_message_1
   1247                  if (MQTTPacket_equals(compare_topic, (char *)node->topic_filter)
   1248                      || iotx_mc_is_topic_matched((char *)node->topic_filter, topicName)) {
   \                     ??iotx_mc_deliver_message_2: (+1)
   \       0x2E   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \       0x32   0x4630             MOV      R0,R6
   \       0x34   0x....'....        BL       MQTTPacket_equals
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD106             BNE.N    ??iotx_mc_deliver_message_3
   \       0x3C   0x4631             MOV      R1,R6
   \       0x3E   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0x42   0x....'....        BL       iotx_mc_is_topic_matched
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD014             BEQ.N    ??iotx_mc_deliver_message_4
   1249                      mqtt_debug("topic be matched");
   1250          
   1251                      HAL_MutexUnlock(c->lock_generic);
   \                     ??iotx_mc_deliver_message_3: (+1)
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x....'....        BL       HAL_MutexUnlock
   1252                      if (NULL != node->handle.h_fp) {
   \       0x50   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD00A             BEQ.N    ??iotx_mc_deliver_message_5
   1253                          iotx_mqtt_event_msg_t msg;
   1254                          msg.event_type = IOTX_MQTT_EVENT_PUBLISH_RECEIVED;
   \       0x58   0x200C             MOVS     R0,#+12
   \       0x5A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1255                          msg.msg = (void *)topic_msg;
   \       0x5E   0x9501             STR      R5,[SP, #+4]
   1256                          _handle_event(&node->handle, c, &msg);
   \       0x60   0x466A             MOV      R2,SP
   \       0x62   0x4621             MOV      R1,R4
   \       0x64   0xF108 0x0004      ADD      R0,R8,#+4
   \       0x68   0x....'....        BL       _handle_event
   1257                          flag_matched = 1;
   \       0x6C   0x2701             MOVS     R7,#+1
   1258                      }
   1259                      HAL_MutexLock(c->lock_generic);
   \                     ??iotx_mc_deliver_message_5: (+1)
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x....'....        BL       HAL_MutexLock
   1260                  }
   1261              }
   \                     ??iotx_mc_deliver_message_4: (+1)
   \       0x74   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x78   0xF1A0 0x0810      SUB      R8,R0,#+16
   \                     ??iotx_mc_deliver_message_1: (+1)
   \       0x7C   0xF108 0x0010      ADD      R0,R8,#+16
   \       0x80   0xF104 0x012C      ADD      R1,R4,#+44
   \       0x84   0x4288             CMP      R0,R1
   \       0x86   0xD1D2             BNE.N    ??iotx_mc_deliver_message_2
   1262          #else
   1263              for (idx = 0; idx < IOTX_MC_SUBHANDLE_LIST_MAX_LEN; idx++) {
   1264                  if ((c->list_sub_handle[idx].used == 1) &&
   1265                      (MQTTPacket_equals(compare_topic, (char *)c->list_sub_handle[idx].topic_filter)
   1266                       || iotx_mc_is_topic_matched((char *)c->list_sub_handle[idx].topic_filter, topicName))) {
   1267                      mqtt_debug("topic be matched");
   1268          
   1269                      HAL_MutexUnlock(c->lock_generic);
   1270                      if (NULL != c->list_sub_handle[idx].handle.h_fp) {
   1271                          iotx_mqtt_event_msg_t msg;
   1272                          msg.event_type = IOTX_MQTT_EVENT_PUBLISH_RECEIVED;
   1273                          msg.msg = (void *)topic_msg;
   1274                          _handle_event(&c->list_sub_handle[idx].handle, c, &msg);
   1275                          flag_matched = 1;
   1276                      }
   1277                      HAL_MutexLock(c->lock_generic);
   1278                  }
   1279              }
   1280          #endif
   1281              HAL_MutexUnlock(c->lock_generic);
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x....'....        BL       HAL_MutexUnlock
   1282          
   1283              if (0 == flag_matched) {
   \       0x8E   0x2F00             CMP      R7,#+0
   \       0x90   0xD10D             BNE.N    ??iotx_mc_deliver_message_0
   1284                  mqtt_info("NO matching any topic, call default handle function");
   1285          
   1286                  if (NULL != c->handle_event.h_fp) {
   \       0x92   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD009             BEQ.N    ??iotx_mc_deliver_message_0
   1287                      iotx_mqtt_event_msg_t msg;
   1288          
   1289                      msg.event_type = IOTX_MQTT_EVENT_PUBLISH_RECEIVED;
   \       0x9A   0x200C             MOVS     R0,#+12
   \       0x9C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1290                      msg.msg = topic_msg;
   \       0xA0   0x9501             STR      R5,[SP, #+4]
   1291                      _handle_event(&c->handle_event, c, &msg);
   \       0xA2   0x466A             MOV      R2,SP
   \       0xA4   0x4621             MOV      R1,R4
   \       0xA6   0xF104 0x00E0      ADD      R0,R4,#+224
   \       0xAA   0x....'....        BL       _handle_event
   1292                  }
   1293              }
   1294          }
   \                     ??iotx_mc_deliver_message_0: (+1)
   \       0xAE   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
   1295          

   \                                 In section .text, align 2, keep-with-next
   1296          static int MQTTPuback(iotx_mc_client_t *c, unsigned int msgId, enum msgTypes type)
   1297          {
   \                     MQTTPuback: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   1298              int rc = 0;
   1299              int len = 0;
   1300              iotx_time_t timer;
   1301          
   1302              if (!c) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD102             BNE.N    ??MQTTPuback_0
   1303                  return FAIL_RETURN;
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
   \       0x10   0xBD76             POP      {R1,R2,R4-R6,PC}
   1304              }
   1305          
   1306              iotx_time_init(&timer);
   \                     ??MQTTPuback_0: (+1)
   \       0x12   0xA801             ADD      R0,SP,#+4
   \       0x14   0x....'....        BL       iotx_time_init
   1307              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x18   0x68A1             LDR      R1,[R4, #+8]
   \       0x1A   0xA801             ADD      R0,SP,#+4
   \       0x1C   0x....'....        BL       utils_time_countdown_ms
   1308          
   1309              HAL_MutexLock(c->lock_write_buf);
   \       0x20   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x24   0x....'....        BL       HAL_MutexLock
   1310              if (type == PUBACK) {
   \       0x28   0x2E04             CMP      R6,#+4
   \       0x2A   0xD120             BNE.N    ??MQTTPuback_1
   1311          
   1312                  if (_alloc_send_buffer(c, 0) < 0) {
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        BL       _alloc_send_buffer
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD506             BPL.N    ??MQTTPuback_2
   1313                      HAL_MutexUnlock(c->lock_write_buf);
   \       0x38   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x3C   0x....'....        BL       HAL_MutexUnlock
   1314                      return FAIL_RETURN;
   \       0x40   0xF04F 0x30FF      MOV      R0,#-1
   \       0x44   0xBD76             POP      {R1,R2,R4-R6,PC}
   1315                  }
   1316          
   1317                  len = MQTTSerialize_ack((unsigned char *)c->buf_send, c->buf_size_send, PUBACK, 0, msgId);
   \                     ??MQTTPuback_2: (+1)
   \       0x46   0xB2AD             UXTH     R5,R5
   \       0x48   0x9500             STR      R5,[SP, #+0]
   \       0x4A   0x2300             MOVS     R3,#+0
   \       0x4C   0x2204             MOVS     R2,#+4
   \       0x4E   0x6921             LDR      R1,[R4, #+16]
   \       0x50   0x6A60             LDR      R0,[R4, #+36]
   \       0x52   0x....'....        BL       MQTTSerialize_ack
   1318          #if WITH_MQTT_QOS2_PACKET
   1319              } else if (type == PUBREC) {
   1320                  if (_alloc_send_buffer(c, 0) < 0) {
   1321                      HAL_MutexUnlock(c->lock_write_buf);
   1322                      return FAIL_RETURN;
   1323                  }
   1324                  len = MQTTSerialize_ack((unsigned char *)c->buf_send, c->buf_size_send, PUBREC, 0, msgId);
   1325              } else if (type == PUBREL) {
   1326                  if (_alloc_send_buffer(c, 0) < 0) {
   1327                      HAL_MutexUnlock(c->lock_write_buf);
   1328                      return FAIL_RETURN;
   1329                  }
   1330                  len = MQTTSerialize_ack((unsigned char *)c->buf_send, c->buf_size_send, PUBREL, 0, msgId);
   1331          #endif  /* #if WITH_MQTT_QOS2_PACKET */
   1332              } else {
   1333                  HAL_MutexUnlock(c->lock_write_buf);
   1334                  return MQTT_PUBLISH_ACK_TYPE_ERROR;
   1335              }
   1336          
   1337              if (len <= 0) {
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xDA10             BGE.N    ??MQTTPuback_3
   1338                  _reset_send_buffer(c);
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x....'....        BL       _reset_send_buffer
   1339                  HAL_MutexUnlock(c->lock_write_buf);
   \       0x60   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x64   0x....'....        BL       HAL_MutexUnlock
   1340                  return MQTT_PUBLISH_ACK_PACKET_ERROR;
   \       0x68   0xF06F 0x0012      MVN      R0,#+18
   \       0x6C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1341              }
   \                     ??MQTTPuback_1: (+1)
   \       0x6E   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x72   0x....'....        BL       HAL_MutexUnlock
   \       0x76   0xF06F 0x000C      MVN      R0,#+12
   \       0x7A   0xBD76             POP      {R1,R2,R4-R6,PC}
   1342          
   1343              rc = iotx_mc_send_packet(c, c->buf_send, len, &timer);
   1344              if (rc != SUCCESS_RETURN) {
   \                     ??MQTTPuback_3: (+1)
   \       0x7C   0xAB01             ADD      R3,SP,#+4
   \       0x7E   0x4602             MOV      R2,R0
   \       0x80   0x6A61             LDR      R1,[R4, #+36]
   \       0x82   0x4620             MOV      R0,R4
   \       0x84   0x....'....        BL       iotx_mc_send_packet
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0x4620             MOV      R0,R4
   \       0x8C   0xD008             BEQ.N    ??MQTTPuback_4
   1345                  _reset_send_buffer(c);
   \       0x8E   0x....'....        BL       _reset_send_buffer
   1346                  HAL_MutexUnlock(c->lock_write_buf);
   \       0x92   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x96   0x....'....        BL       HAL_MutexUnlock
   1347                  return MQTT_NETWORK_ERROR;
   \       0x9A   0xF06F 0x000D      MVN      R0,#+13
   \       0x9E   0xBD76             POP      {R1,R2,R4-R6,PC}
   1348              }
   1349          
   1350              _reset_send_buffer(c);
   \                     ??MQTTPuback_4: (+1)
   \       0xA0   0x....'....        BL       _reset_send_buffer
   1351              HAL_MutexUnlock(c->lock_write_buf);
   \       0xA4   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xA8   0x....'....        BL       HAL_MutexUnlock
   1352              return SUCCESS_RETURN;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1353          }
   1354          

   \                                 In section .text, align 2, keep-with-next
   1355          static int iotx_mc_handle_recv_PUBLISH(iotx_mc_client_t *c)
   1356          {
   \                     iotx_mc_handle_recv_PUBLISH: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB08F             SUB      SP,SP,#+60
   \        0x4   0x4604             MOV      R4,R0
   1357              int result = 0;
   1358              MQTTString topicName;
   1359              iotx_mqtt_topic_info_t topic_msg;
   1360              int qos = 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9006             STR      R0,[SP, #+24]
   1361              uint32_t payload_len = 0;
   \        0xA   0x9005             STR      R0,[SP, #+20]
   1362          #ifdef INFRA_LOG_NETWORK_PAYLOAD
   1363              const char     *json_payload = NULL;
   1364          #endif
   1365          
   1366              if (!c) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD102             BNE.N    ??iotx_mc_handle_recv_PUBLISH_0
   1367                  return FAIL_RETURN;
   \       0x10   0xF04F 0x30FF      MOV      R0,#-1
   \       0x14   0xE044             B.N      ??iotx_mc_handle_recv_PUBLISH_1
   1368              }
   1369          
   1370              memset(&topic_msg, 0x0, sizeof(iotx_mqtt_topic_info_t));
   \                     ??iotx_mc_handle_recv_PUBLISH_0: (+1)
   \       0x16   0x4602             MOV      R2,R0
   \       0x18   0x2114             MOVS     R1,#+20
   \       0x1A   0xA807             ADD      R0,SP,#+28
   \       0x1C   0x....'....        BL       __aeabi_memset4
   1371              memset(&topicName, 0x0, sizeof(MQTTString));
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x210C             MOVS     R1,#+12
   \       0x24   0xA80C             ADD      R0,SP,#+48
   \       0x26   0x....'....        BL       __aeabi_memset4
   1372          
   1373              if (1 != MQTTDeserialize_publish((unsigned char *)&topic_msg.dup,
   1374                                               (int *)&qos,
   1375                                               (unsigned char *)&topic_msg.retain,
   1376                                               (unsigned short *)&topic_msg.packet_id,
   1377                                               &topicName,
   1378                                               (unsigned char **)&topic_msg.payload,
   1379                                               (int *)&payload_len,
   1380                                               (unsigned char *)c->buf_read,
   1381                                               c->buf_size_read)) {
   \       0x2A   0x69E0             LDR      R0,[R4, #+28]
   \       0x2C   0x9004             STR      R0,[SP, #+16]
   \       0x2E   0x6AA0             LDR      R0,[R4, #+40]
   \       0x30   0x9003             STR      R0,[SP, #+12]
   \       0x32   0xA805             ADD      R0,SP,#+20
   \       0x34   0x9002             STR      R0,[SP, #+8]
   \       0x36   0xA80B             ADD      R0,SP,#+44
   \       0x38   0x9001             STR      R0,[SP, #+4]
   \       0x3A   0xA80C             ADD      R0,SP,#+48
   \       0x3C   0x9000             STR      R0,[SP, #+0]
   \       0x3E   0xAB07             ADD      R3,SP,#+28
   \       0x40   0xAA08             ADD      R2,SP,#+32
   \       0x42   0xA906             ADD      R1,SP,#+24
   \       0x44   0xF10D 0x001F      ADD      R0,SP,#+31
   \       0x48   0x....'....        BL       MQTTDeserialize_publish
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD002             BEQ.N    ??iotx_mc_handle_recv_PUBLISH_2
   1382                  return MQTT_PUBLISH_PACKET_ERROR;
   \       0x50   0xF06F 0x0014      MVN      R0,#+20
   \       0x54   0xE024             B.N      ??iotx_mc_handle_recv_PUBLISH_1
   1383              }
   1384              topic_msg.qos = (unsigned char)qos;
   \                     ??iotx_mc_handle_recv_PUBLISH_2: (+1)
   \       0x56   0x9806             LDR      R0,[SP, #+24]
   \       0x58   0xF88D 0x001E      STRB     R0,[SP, #+30]
   1385              topic_msg.payload_len = payload_len;
   \       0x5C   0x9805             LDR      R0,[SP, #+20]
   \       0x5E   0x9009             STR      R0,[SP, #+36]
   1386          
   1387          #ifdef INFRA_LOG_NETWORK_PAYLOAD
   1388          
   1389              json_payload = (const char *)topic_msg.payload;
   1390              mqtt_info("Downstream Topic: '%.*s'", topicName.lenstring.len, topicName.lenstring.data);
   1391              mqtt_info("Downstream Payload:");
   1392              iotx_facility_json_print(json_payload, LOG_INFO_LEVEL, '<');
   \       0x60   0x223C             MOVS     R2,#+60
   \       0x62   0x2104             MOVS     R1,#+4
   \       0x64   0x980B             LDR      R0,[SP, #+44]
   \       0x66   0x....'....        BL       iotx_facility_json_print
   1393          
   1394          #endif  /* #ifdef INFRA_LOG */
   1395          
   1396              mqtt_debug("%20s : %08d", "Packet Ident", topic_msg.packet_id);
   1397              mqtt_debug("%20s : %d", "Topic Length", topicName.lenstring.len);
   1398              mqtt_debug("%20s : %.*s",
   1399                         "Topic Name",
   1400                         topicName.lenstring.len,
   1401                         topicName.lenstring.data);
   1402              mqtt_debug("%20s : %u / %d", "Payload Len/Room",
   1403                         (unsigned int)topic_msg.payload_len,
   1404                         (int)(c->buf_read + c->buf_size_read - topic_msg.payload));
   1405              mqtt_debug("%20s : %lu", "Receive Buflen", c->buf_size_read);
   1406          
   1407          #if defined(INSPECT_MQTT_FLOW)
   1408              mqtt_debug("%20s : %p", "Payload Buffer", topic_msg.payload);
   1409              mqtt_debug("%20s : %p", "Receive Buffer", c->buf_read);
   1410          #ifdef INFRA_LOG
   1411              HEXDUMP_DEBUG(topic_msg.payload, topic_msg.payload_len);
   1412          #endif
   1413          #endif
   1414          #ifdef LOG_REPORT_TO_CLOUD
   1415              get_msgid(topicName.lenstring.data, 1);
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0x980E             LDR      R0,[SP, #+56]
   \       0x6E   0x....'....        BL       get_msgid
   1416          #endif
   1417          
   1418              topic_msg.ptopic = NULL;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x900A             STR      R0,[SP, #+40]
   1419              topic_msg.topic_len = 0;
   \       0x76   0xF8AD 0x0022      STRH     R0,[SP, #+34]
   1420          
   1421              mqtt_debug("delivering msg ...");
   1422          
   1423          #if WITH_MQTT_FLOW_CTRL
   1424              /* flowControl for specific topic */
   1425              static uint64_t time_prev = 0;
   1426              uint64_t time_curr = 0;
   1427              char *filterStr = "{\"method\":\"thing.service.property.set\"";
   1428              int filterLen = strlen(filterStr);
   1429          
   1430              if (0 == memcmp(topic_msg.payload, filterStr, filterLen)) {
   1431                  time_curr = HAL_UptimeMs();
   1432                  if (time_curr < time_prev) {
   1433                      time_curr = time_prev;
   1434                  }
   1435                  if ((time_curr - time_prev) <= (uint64_t)50) {
   1436                      mqtt_info("MQTT over threshould");
   1437                      return SUCCESS_RETURN;
   1438                  } else {
   1439                      time_prev = time_curr;
   1440                  }
   1441              }
   1442          #endif
   1443          
   1444              iotx_mc_deliver_message(c, &topicName, &topic_msg);
   \       0x7A   0xAA07             ADD      R2,SP,#+28
   \       0x7C   0xA90C             ADD      R1,SP,#+48
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0x....'....        BL       iotx_mc_deliver_message
   1445          
   1446              if (topic_msg.qos == IOTX_MQTT_QOS0) {
   \       0x84   0xF89D 0x001E      LDRB     R0,[SP, #+30]
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD101             BNE.N    ??iotx_mc_handle_recv_PUBLISH_3
   1447                  return SUCCESS_RETURN;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xE007             B.N      ??iotx_mc_handle_recv_PUBLISH_1
   1448              } else if (topic_msg.qos == IOTX_MQTT_QOS1) {
   \                     ??iotx_mc_handle_recv_PUBLISH_3: (+1)
   \       0x90   0x2801             CMP      R0,#+1
   \       0x92   0xD107             BNE.N    ??iotx_mc_handle_recv_PUBLISH_4
   1449                  result = MQTTPuback(c, topic_msg.packet_id, PUBACK);
   \       0x94   0x2204             MOVS     R2,#+4
   \       0x96   0xF8BD 0x101C      LDRH     R1,[SP, #+28]
   \       0x9A   0x4620             MOV      R0,R4
   \       0x9C   0x....'....        BL       MQTTPuback
   1450              } else if (topic_msg.qos == IOTX_MQTT_QOS2) {
   1451                  result = MQTTPuback(c, topic_msg.packet_id, PUBREC);
   1452              } else {
   1453                  mqtt_err("Invalid QOS, QOSvalue = %d", topic_msg.qos);
   1454                  return MQTT_PUBLISH_QOS_ERROR;
   1455              }
   1456          
   1457              return result;
   \                     ??iotx_mc_handle_recv_PUBLISH_1: (+1)
   \       0xA0   0xB010             ADD      SP,SP,#+64
   \       0xA2   0xBD10             POP      {R4,PC}          ;; return
   \                     ??iotx_mc_handle_recv_PUBLISH_4: (+1)
   \       0xA4   0x2802             CMP      R0,#+2
   \       0xA6   0xD106             BNE.N    ??iotx_mc_handle_recv_PUBLISH_5
   \       0xA8   0x2205             MOVS     R2,#+5
   \       0xAA   0xF8BD 0x101C      LDRH     R1,[SP, #+28]
   \       0xAE   0x4620             MOV      R0,R4
   \       0xB0   0x....'....        BL       MQTTPuback
   \       0xB4   0xE7F4             B.N      ??iotx_mc_handle_recv_PUBLISH_1
   \                     ??iotx_mc_handle_recv_PUBLISH_5: (+1)
   \       0xB6   0xF06F 0x0013      MVN      R0,#+19
   \       0xBA   0xE7F1             B.N      ??iotx_mc_handle_recv_PUBLISH_1
   1458          }
   1459          

   \                                 In section .text, align 2, keep-with-next
   1460          static int iotx_mc_handle_recv_UNSUBACK(iotx_mc_client_t *c)
   1461          {
   \                     iotx_mc_handle_recv_UNSUBACK: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1462              unsigned short mypacketid = 0;  /* should be the same as the packetid above */
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1463              if (!c) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??iotx_mc_handle_recv_UNSUBACK_0
   1464                  return FAIL_RETURN;
   \        0xE   0xF04F 0x30FF      MOV      R0,#-1
   \       0x12   0xE01A             B.N      ??iotx_mc_handle_recv_UNSUBACK_1
   1465              }
   1466          
   1467              if (MQTTDeserialize_unsuback(&mypacketid, (unsigned char *)c->buf_read, c->buf_size_read) != 1) {
   \                     ??iotx_mc_handle_recv_UNSUBACK_0: (+1)
   \       0x14   0x69E2             LDR      R2,[R4, #+28]
   \       0x16   0x6AA1             LDR      R1,[R4, #+40]
   \       0x18   0x4668             MOV      R0,SP
   \       0x1A   0x....'....        BL       MQTTDeserialize_unsuback
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD002             BEQ.N    ??iotx_mc_handle_recv_UNSUBACK_2
   1468                  return MQTT_UNSUBSCRIBE_ACK_PACKET_ERROR;
   \       0x22   0xF06F 0x000E      MVN      R0,#+14
   \       0x26   0xE010             B.N      ??iotx_mc_handle_recv_UNSUBACK_1
   1469              }
   1470          
   1471              if (NULL != c->handle_event.h_fp) {
   \                     ??iotx_mc_handle_recv_UNSUBACK_2: (+1)
   \       0x28   0xF8D4 0x00E0      LDR      R0,[R4, #+224]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD00B             BEQ.N    ??iotx_mc_handle_recv_UNSUBACK_3
   1472                  iotx_mqtt_event_msg_t msg;
   1473                  msg.event_type = IOTX_MQTT_EVENT_UNSUBCRIBE_SUCCESS;
   \       0x30   0x2006             MOVS     R0,#+6
   \       0x32   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1474                  msg.msg = (void *)(uintptr_t)mypacketid;
   \       0x36   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x3A   0x9002             STR      R0,[SP, #+8]
   1475                  _handle_event(&c->handle_event, c, &msg);
   \       0x3C   0xAA01             ADD      R2,SP,#+4
   \       0x3E   0x4621             MOV      R1,R4
   \       0x40   0xF104 0x00E0      ADD      R0,R4,#+224
   \       0x44   0x....'....        BL       _handle_event
   1476              }
   1477          
   1478              return SUCCESS_RETURN;
   \                     ??iotx_mc_handle_recv_UNSUBACK_3: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??iotx_mc_handle_recv_UNSUBACK_1: (+1)
   \       0x4A   0xB004             ADD      SP,SP,#+16
   \       0x4C   0xBD10             POP      {R4,PC}          ;; return
   1479          }
   1480          

   \                                 In section .text, align 2, keep-with-next
   1481          static int iotx_mc_cycle(iotx_mc_client_t *c, iotx_time_t *timer)
   1482          {
   \                     iotx_mc_cycle: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1483              unsigned int packetType;
   1484              iotx_mc_state_t state;
   1485              int rc = SUCCESS_RETURN;
   1486          
   1487              if (!c) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??iotx_mc_cycle_0
   1488                  return FAIL_RETURN;
   \        0xA   0xF04F 0x30FF      MOV      R0,#-1
   \        0xE   0xBD76             POP      {R1,R2,R4-R6,PC}
   1489              }
   1490          
   1491              state = iotx_mc_get_client_state(c);
   1492              if (state != IOTX_MC_STATE_CONNECTED) {
   \                     ??iotx_mc_cycle_0: (+1)
   \       0x10   0x....'....        BL       iotx_mc_get_client_state
   \       0x14   0x2802             CMP      R0,#+2
   \       0x16   0xD002             BEQ.N    ??iotx_mc_cycle_1
   1493                  mqtt_debug("state = %d", state);
   1494                  return MQTT_STATE_ERROR;
   \       0x18   0xF06F 0x001A      MVN      R0,#+26
   \       0x1C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1495              }
   1496          
   1497              if (IOTX_MC_KEEPALIVE_PROBE_MAX < c->keepalive_probes) {
   \                     ??iotx_mc_cycle_1: (+1)
   \       0x1E   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \       0x22   0x2803             CMP      R0,#+3
   \       0x24   0xDB06             BLT.N    ??iotx_mc_cycle_2
   1498                  iotx_mc_set_client_state(c, IOTX_MC_STATE_DISCONNECTED);
   \       0x26   0x2103             MOVS     R1,#+3
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....'....        BL       iotx_mc_set_client_state
   1499                  c->keepalive_probes = 0;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF884 0x0020      STRB     R0,[R4, #+32]
   1500                  mqtt_debug("keepalive_probes more than %u, disconnected\n", IOTX_MC_KEEPALIVE_PROBE_MAX);
   1501              }
   1502          
   1503              /* read the socket, see what work is due */
   1504              rc = iotx_mc_read_packet(c, timer, &packetType);
   \                     ??iotx_mc_cycle_2: (+1)
   \       0x34   0x466A             MOV      R2,SP
   \       0x36   0x4629             MOV      R1,R5
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x....'....        BL       iotx_mc_read_packet
   \       0x3E   0x0005             MOVS     R5,R0
   1505              if (rc != SUCCESS_RETURN) {
   \       0x40   0xD014             BEQ.N    ??iotx_mc_cycle_3
   1506                  HAL_MutexLock(c->lock_read_buf);
   \       0x42   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x46   0x....'....        BL       HAL_MutexLock
   1507                  _reset_recv_buffer(c);
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x....'....        BL       _reset_recv_buffer
   1508                  HAL_MutexUnlock(c->lock_read_buf);
   \       0x50   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x54   0x....'....        BL       HAL_MutexUnlock
   1509                  if (rc == MQTT_NETWORK_ERROR) {
   \       0x58   0xF06F 0x060D      MVN      R6,#+13
   \       0x5C   0x42B5             CMP      R5,R6
   \       0x5E   0xD103             BNE.N    ??iotx_mc_cycle_4
   1510                      iotx_mc_set_client_state(c, IOTX_MC_STATE_DISCONNECTED);
   \       0x60   0x2103             MOVS     R1,#+3
   \       0x62   0x4620             MOV      R0,R4
   \       0x64   0x....'....        BL       iotx_mc_set_client_state
   1511                  }
   1512                  mqtt_err("readPacket error,result = %d", rc);
   1513                  return MQTT_NETWORK_ERROR;
   \                     ??iotx_mc_cycle_4: (+1)
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0xBD76             POP      {R1,R2,R4-R6,PC}
   1514              }
   1515          
   1516              if (MQTT_CPT_RESERVED == packetType) {
   \                     ??iotx_mc_cycle_3: (+1)
   \       0x6C   0x9800             LDR      R0,[SP, #+0]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD10C             BNE.N    ??iotx_mc_cycle_5
   1517                  /* mqtt_debug("wait data timeout"); */
   1518                  HAL_MutexLock(c->lock_read_buf);
   \       0x72   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x76   0x....'....        BL       HAL_MutexLock
   1519                  _reset_recv_buffer(c);
   \       0x7A   0x4620             MOV      R0,R4
   \       0x7C   0x....'....        BL       _reset_recv_buffer
   1520                  HAL_MutexUnlock(c->lock_read_buf);
   \       0x80   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0x84   0x....'....        BL       HAL_MutexUnlock
   1521                  return SUCCESS_RETURN;
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0xBD76             POP      {R1,R2,R4-R6,PC}
   1522              }
   1523          
   1524              /* clear ping mark when any data received from MQTT broker */
   1525              HAL_MutexLock(c->lock_generic);
   \                     ??iotx_mc_cycle_5: (+1)
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x....'....        BL       HAL_MutexLock
   1526              c->keepalive_probes = 0;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xF884 0x0020      STRB     R0,[R4, #+32]
   1527              HAL_MutexUnlock(c->lock_generic);
   \       0x98   0x6820             LDR      R0,[R4, #+0]
   \       0x9A   0x....'....        BL       HAL_MutexUnlock
   1528              HAL_MutexLock(c->lock_read_buf);
   \       0x9E   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0xA2   0x....'....        BL       HAL_MutexLock
   1529              switch (packetType) {
   \       0xA6   0x9800             LDR      R0,[SP, #+0]
   \       0xA8   0x2802             CMP      R0,#+2
   \       0xAA   0xD00E             BEQ.N    ??iotx_mc_cycle_6
   \       0xAC   0x2803             CMP      R0,#+3
   \       0xAE   0xD01A             BEQ.N    ??iotx_mc_cycle_7
   \       0xB0   0x2804             CMP      R0,#+4
   \       0xB2   0xD006             BEQ.N    ??iotx_mc_cycle_8
   \       0xB4   0x2809             CMP      R0,#+9
   \       0xB6   0xD011             BEQ.N    ??iotx_mc_cycle_9
   \       0xB8   0x280B             CMP      R0,#+11
   \       0xBA   0xD019             BEQ.N    ??iotx_mc_cycle_10
   \       0xBC   0x280D             CMP      R0,#+13
   \       0xBE   0xD004             BEQ.N    ??iotx_mc_cycle_6
   \       0xC0   0xE01B             B.N      ??iotx_mc_cycle_11
   1530                  case CONNACK: {
   1531                      mqtt_debug("CONNACK");
   1532                      break;
   1533                  }
   1534          #if !WITH_MQTT_ONLY_QOS0
   1535                  case PUBACK: {
   1536                      mqtt_debug("PUBACK");
   1537                      rc = iotx_mc_handle_recv_PUBACK(c);
   \                     ??iotx_mc_cycle_8: (+1)
   \       0xC2   0x4620             MOV      R0,R4
   \       0xC4   0x....'....        BL       iotx_mc_handle_recv_PUBACK
   \       0xC8   0x4605             MOV      R5,R0
   1538                      if (SUCCESS_RETURN != rc) {
   1539                          mqtt_err("recvPubackProc error,result = %d", rc);
   1540                      }
   1541          
   1542                      break;
   1543                  }
   1544          #endif
   1545                  case SUBACK: {
   1546                      mqtt_debug("SUBACK");
   1547                      rc = iotx_mc_handle_recv_SUBACK(c);
   1548                      if (SUCCESS_RETURN != rc) {
   1549                          mqtt_err("recvSubAckProc error,result = %d", rc);
   1550                      }
   1551                      break;
   1552                  }
   1553                  case PUBLISH: {
   1554                      mqtt_debug("PUBLISH");
   1555                      /* HEXDUMP_DEBUG(c->buf_read, 32); */
   1556          
   1557                      rc = iotx_mc_handle_recv_PUBLISH(c);
   1558                      if (SUCCESS_RETURN != rc) {
   1559                          mqtt_err("recvPublishProc error,result = %d", rc);
   1560                      }
   1561                      break;
   1562                  }
   1563                  case UNSUBACK: {
   1564                      mqtt_debug("UNSUBACK");
   1565                      rc = iotx_mc_handle_recv_UNSUBACK(c);
   1566                      if (SUCCESS_RETURN != rc) {
   1567                          mqtt_err("recvUnsubAckProc error,result = %d", rc);
   1568                      }
   1569                      break;
   1570                  }
   1571                  case PINGRESP: {
   1572                      rc = SUCCESS_RETURN;
   1573                      mqtt_info("receive ping response!");
   1574                      break;
   1575                  }
   1576                  default:
   1577                      mqtt_err("INVALID TYPE");
   1578                      _reset_recv_buffer(c);
   1579                      HAL_MutexUnlock(c->lock_read_buf);
   1580                      return FAIL_RETURN;
   1581              }
   1582              _reset_recv_buffer(c);
   \                     ??iotx_mc_cycle_6: (+1)
   \       0xCA   0x4620             MOV      R0,R4
   \       0xCC   0x....'....        BL       _reset_recv_buffer
   1583              HAL_MutexUnlock(c->lock_read_buf);
   \       0xD0   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \       0xD4   0x....'....        BL       HAL_MutexUnlock
   1584              return rc;
   \       0xD8   0x4628             MOV      R0,R5
   \       0xDA   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??iotx_mc_cycle_9: (+1)
   \       0xDC   0x4620             MOV      R0,R4
   \       0xDE   0x....'....        BL       iotx_mc_handle_recv_SUBACK
   \       0xE2   0x4605             MOV      R5,R0
   \       0xE4   0xE7F1             B.N      ??iotx_mc_cycle_6
   \                     ??iotx_mc_cycle_7: (+1)
   \       0xE6   0x4620             MOV      R0,R4
   \       0xE8   0x....'....        BL       iotx_mc_handle_recv_PUBLISH
   \       0xEC   0x4605             MOV      R5,R0
   \       0xEE   0xE7EC             B.N      ??iotx_mc_cycle_6
   \                     ??iotx_mc_cycle_10: (+1)
   \       0xF0   0x4620             MOV      R0,R4
   \       0xF2   0x....'....        BL       iotx_mc_handle_recv_UNSUBACK
   \       0xF6   0x4605             MOV      R5,R0
   \       0xF8   0xE7E7             B.N      ??iotx_mc_cycle_6
   \                     ??iotx_mc_cycle_11: (+1)
   \       0xFA   0x4620             MOV      R0,R4
   \       0xFC   0x....'....        BL       _reset_recv_buffer
   \      0x100   0xF8D4 0x00D8      LDR      R0,[R4, #+216]
   \      0x104   0x....'....        BL       HAL_MutexUnlock
   \      0x108   0xF04F 0x30FF      MOV      R0,#-1
   \      0x10C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1585          }
   1586          

   \                                 In section .text, align 2, keep-with-next
   1587          void _mqtt_cycle(void *client)
   1588          {
   \                     _mqtt_cycle: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1589              int                 rc = SUCCESS_RETURN;
   1590              iotx_time_t         time;
   1591              iotx_mc_client_t *pClient = (iotx_mc_client_t *)client;
   1592          
   1593              iotx_time_init(&time);
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x....'....        BL       iotx_time_init
   1594              utils_time_countdown_ms(&time, pClient->cycle_timeout_ms);
   \        0xA   0x68E1             LDR      R1,[R4, #+12]
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x....'....        BL       utils_time_countdown_ms
   1595          
   1596              do {
   1597                  unsigned int left_t;
   1598          
   1599                  if (SUCCESS_RETURN != rc) {
   1600                      mqtt_err("error occur rc=%d", rc);
   1601                  }
   1602          
   1603                  HAL_MutexLock(pClient->lock_yield);
   \                     ??_mqtt_cycle_0: (+1)
   \       0x12   0xF8D4 0x00DC      LDR      R0,[R4, #+220]
   \       0x16   0x....'....        BL       HAL_MutexLock
   1604          
   1605                  /* acquire package in cycle, such as PINGRESP or PUBLISH */
   1606                  rc = iotx_mc_cycle(pClient, &time);
   1607                  if (SUCCESS_RETURN == rc) {
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       iotx_mc_cycle
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD102             BNE.N    ??_mqtt_cycle_1
   1608          #ifndef ASYNC_PROTOCOL_STACK
   1609          #if !WITH_MQTT_ONLY_QOS0
   1610                      /* check list of wait publish ACK to remove node that is ACKED or timeout */
   1611                      MQTTPubInfoProc(pClient);
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       MQTTPubInfoProc
   1612          #endif
   1613          #endif
   1614                  }
   1615                  HAL_MutexUnlock(pClient->lock_yield);
   \                     ??_mqtt_cycle_1: (+1)
   \       0x2C   0xF8D4 0x00DC      LDR      R0,[R4, #+220]
   \       0x30   0x....'....        BL       HAL_MutexUnlock
   1616          
   1617                  left_t = iotx_time_left(&time);
   \       0x34   0x4668             MOV      R0,SP
   \       0x36   0x....'....        BL       iotx_time_left
   1618                  if (left_t < 10) {
   \       0x3A   0x280A             CMP      R0,#+10
   \       0x3C   0xD202             BCS.N    ??_mqtt_cycle_2
   1619                      HAL_SleepMs(left_t);
   \       0x3E   0x....'....        BL       HAL_SleepMs
   \       0x42   0xE002             B.N      ??_mqtt_cycle_3
   1620                  } else {
   1621                      HAL_SleepMs(10);
   \                     ??_mqtt_cycle_2: (+1)
   \       0x44   0x200A             MOVS     R0,#+10
   \       0x46   0x....'....        BL       HAL_SleepMs
   1622                  }
   1623              } while (!utils_time_is_expired(&time));
   \                     ??_mqtt_cycle_3: (+1)
   \       0x4A   0x4668             MOV      R0,SP
   \       0x4C   0x....'....        BL       utils_time_is_expired
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD0DE             BEQ.N    ??_mqtt_cycle_0
   1624          }
   \       0x54   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1625          

   \                                 In section .text, align 2, keep-with-next
   1626          static int MQTTKeepalive(iotx_mc_client_t *pClient)
   1627          {
   \                     MQTTKeepalive: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1628              int len = 0;
   1629              int rc = 0;
   1630              /* there is no ping outstanding - send ping packet */
   1631              iotx_time_t timer;
   1632          
   1633              if (!pClient) {
   \        0x4   0xD102             BNE.N    ??MQTTKeepalive_0
   1634                  return FAIL_RETURN;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD16             POP      {R1,R2,R4,PC}
   1635              }
   1636          
   1637              iotx_time_init(&timer);
   \                     ??MQTTKeepalive_0: (+1)
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x....'....        BL       iotx_time_init
   1638              utils_time_countdown_ms(&timer, 1000);
   \       0x12   0xF44F 0x717A      MOV      R1,#+1000
   \       0x16   0x4668             MOV      R0,SP
   \       0x18   0x....'....        BL       utils_time_countdown_ms
   1639          
   1640              HAL_MutexLock(pClient->lock_write_buf);
   \       0x1C   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x20   0x....'....        BL       HAL_MutexLock
   1641              rc = _alloc_send_buffer(pClient, 0);
   1642              if (rc < 0) {
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       _alloc_send_buffer
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD506             BPL.N    ??MQTTKeepalive_1
   1643                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x30   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x34   0x....'....        BL       HAL_MutexUnlock
   1644                  return FAIL_RETURN;
   \       0x38   0xF04F 0x30FF      MOV      R0,#-1
   \       0x3C   0xBD16             POP      {R1,R2,R4,PC}
   1645              }
   1646          
   1647              len = MQTTSerialize_pingreq((unsigned char *)pClient->buf_send, pClient->buf_size_send);
   \                     ??MQTTKeepalive_1: (+1)
   \       0x3E   0x6921             LDR      R1,[R4, #+16]
   \       0x40   0x6A60             LDR      R0,[R4, #+36]
   \       0x42   0x....'....        BL       MQTTSerialize_pingreq
   \       0x46   0x4602             MOV      R2,R0
   1648              mqtt_debug("len = MQTTSerialize_pingreq() = %d", len);
   1649          
   1650              if (len <= 0) {
   \       0x48   0x2A01             CMP      R2,#+1
   \       0x4A   0xDA09             BGE.N    ??MQTTKeepalive_2
   1651                  mqtt_err("Serialize ping request is error");
   1652                  _reset_send_buffer(pClient);
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x....'....        BL       _reset_send_buffer
   1653                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x52   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x56   0x....'....        BL       HAL_MutexUnlock
   1654                  return MQTT_PING_PACKET_ERROR;
   \       0x5A   0xF06F 0x001E      MVN      R0,#+30
   \       0x5E   0xBD16             POP      {R1,R2,R4,PC}
   1655              }
   1656          
   1657              rc = iotx_mc_send_packet(pClient, pClient->buf_send, len, &timer);
   1658              if (SUCCESS_RETURN != rc) {
   \                     ??MQTTKeepalive_2: (+1)
   \       0x60   0x466B             MOV      R3,SP
   \       0x62   0x6A61             LDR      R1,[R4, #+36]
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0x....'....        BL       iotx_mc_send_packet
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0x4620             MOV      R0,R4
   \       0x6E   0xD008             BEQ.N    ??MQTTKeepalive_3
   1659                  /* ping outstanding, then close socket unsubscribe topic and handle callback function */
   1660                  mqtt_err("ping outstanding is error,result = %d", rc);
   1661          
   1662                  _reset_send_buffer(pClient);
   \       0x70   0x....'....        BL       _reset_send_buffer
   1663                  HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x74   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x78   0x....'....        BL       HAL_MutexUnlock
   1664                  return MQTT_NETWORK_ERROR;
   \       0x7C   0xF06F 0x000D      MVN      R0,#+13
   \       0x80   0xBD16             POP      {R1,R2,R4,PC}
   1665              }
   1666              _reset_send_buffer(pClient);
   \                     ??MQTTKeepalive_3: (+1)
   \       0x82   0x....'....        BL       _reset_send_buffer
   1667              HAL_MutexUnlock(pClient->lock_write_buf);
   \       0x86   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x8A   0x....'....        BL       HAL_MutexUnlock
   1668              return SUCCESS_RETURN;
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1669          }
   1670          

   \                                 In section .text, align 2, keep-with-next
   1671          static int iotx_mc_keepalive_sub(iotx_mc_client_t *pClient)
   1672          {
   \                     iotx_mc_keepalive_sub: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1673          
   1674              int rc = SUCCESS_RETURN;
   1675          
   1676              if (NULL == pClient) {
   \        0x4   0xD102             BNE.N    ??iotx_mc_keepalive_sub_0
   1677                  return NULL_VALUE_ERROR;
   \        0x6   0xF06F 0x0001      MVN      R0,#+1
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
   1678              }
   1679          
   1680              /* if in disabled state, without having to send ping packets */
   1681              if (!wrapper_mqtt_check_state(pClient)) {
   \                     ??iotx_mc_keepalive_sub_0: (+1)
   \        0xC   0x....'....        BL       wrapper_mqtt_check_state
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD005             BEQ.N    ??iotx_mc_keepalive_sub_1
   1682                  return SUCCESS_RETURN;
   1683              }
   1684          
   1685              /* if there is no ping_timer timeout, then return success */
   1686              if (!utils_time_is_expired(&pClient->next_ping_time)) {
   \       0x14   0xF105 0x0058      ADD      R0,R5,#+88
   \       0x18   0x....'....        BL       utils_time_is_expired
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD101             BNE.N    ??iotx_mc_keepalive_sub_2
   1687                  return SUCCESS_RETURN;
   \                     ??iotx_mc_keepalive_sub_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}
   1688              }
   1689          
   1690              /* update to next time sending MQTT keep-alive */
   1691              utils_time_countdown_ms(&pClient->next_ping_time, pClient->connect_data.keepAliveInterval * 1000);
   \                     ??iotx_mc_keepalive_sub_2: (+1)
   \       0x24   0xF8B5 0x1080      LDRH     R1,[R5, #+128]
   \       0x28   0xF44F 0x707A      MOV      R0,#+1000
   \       0x2C   0x4341             MULS     R1,R0,R1
   \       0x2E   0xF105 0x0058      ADD      R0,R5,#+88
   \       0x32   0x....'....        BL       utils_time_countdown_ms
   1692          
   1693              rc = MQTTKeepalive(pClient);
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x....'....        BL       MQTTKeepalive
   \       0x3C   0x0004             MOVS     R4,R0
   1694              if (SUCCESS_RETURN != rc) {
   \       0x3E   0xD008             BEQ.N    ??iotx_mc_keepalive_sub_3
   1695                  if (rc == MQTT_NETWORK_ERROR) {
   \       0x40   0xF114 0x0F0E      CMN      R4,#+14
   \       0x44   0xD103             BNE.N    ??iotx_mc_keepalive_sub_4
   1696                      iotx_mc_set_client_state(pClient, IOTX_MC_STATE_DISCONNECTED);
   \       0x46   0x2103             MOVS     R1,#+3
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x....'....        BL       iotx_mc_set_client_state
   1697                  }
   1698                  mqtt_err("ping outstanding is error,result = %d", rc);
   1699                  return rc;
   \                     ??iotx_mc_keepalive_sub_4: (+1)
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0xBD32             POP      {R1,R4,R5,PC}
   1700              }
   1701          
   1702              mqtt_info("send MQTT ping...");
   1703          
   1704              HAL_MutexLock(pClient->lock_generic);
   \                     ??iotx_mc_keepalive_sub_3: (+1)
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x....'....        BL       HAL_MutexLock
   1705              pClient->keepalive_probes++;
   \       0x58   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \       0x5C   0x1C40             ADDS     R0,R0,#+1
   \       0x5E   0xF885 0x0020      STRB     R0,[R5, #+32]
   1706              HAL_MutexUnlock(pClient->lock_generic);
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x....'....        BL       HAL_MutexUnlock
   1707          
   1708              return SUCCESS_RETURN;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1709          }
   1710          

   \                                 In section .text, align 2, keep-with-next
   1711          static int iotx_mc_attempt_reconnect(iotx_mc_client_t *pClient)
   1712          {
   \                     iotx_mc_attempt_reconnect: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1713              int rc;
   1714              if (pClient == NULL) {
   \        0x4   0xD102             BNE.N    ??iotx_mc_attempt_reconnect_0
   1715                  return NULL_VALUE_ERROR;
   \        0x6   0xF06F 0x0001      MVN      R0,#+1
   \        0xA   0xBD10             POP      {R4,PC}
   1716              }
   1717          
   1718              pClient->ipstack.disconnect(&pClient->ipstack);
   \                     ??iotx_mc_attempt_reconnect_0: (+1)
   \        0xC   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x10   0x6D21             LDR      R1,[R4, #+80]
   \       0x12   0x4788             BLX      R1
   1719          
   1720              mqtt_info("reconnect params: MQTTVersion=%d, clientID=%s, keepAliveInterval=%d, username=%s",
   1721                        pClient->connect_data.MQTTVersion,
   1722                        pClient->connect_data.clientID.cstring,
   1723                        pClient->connect_data.keepAliveInterval,
   1724                        pClient->connect_data.username.cstring);
   1725          
   1726              /* Ignoring return code. failures expected if network is disconnected */
   1727              rc = wrapper_mqtt_connect(pClient);
   1728          
   1729              if (SUCCESS_RETURN != rc && MQTT_CONNECT_BLOCK != rc) {
   1730                  mqtt_err("run iotx_mqtt_connect() error!");
   1731              }
   1732          
   1733              return rc;
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1A   0x....'....        B.W      wrapper_mqtt_connect
   1734          }
   1735          

   \                                 In section .text, align 2, keep-with-next
   1736          static int iotx_mc_handle_reconnect(iotx_mc_client_t *pClient)
   1737          {
   \                     iotx_mc_handle_reconnect: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1738              int             rc = FAIL_RETURN;
   1739              uint32_t        interval_ms = 0;
   1740          
   1741              if (NULL == pClient) {
   \        0x4   0xD102             BNE.N    ??iotx_mc_handle_reconnect_0
   1742                  return NULL_VALUE_ERROR;
   \        0x6   0xF06F 0x0001      MVN      R0,#+1
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
   1743              }
   1744              mqtt_info("Waiting to reconnect...");
   1745              if (!utils_time_is_expired(&(pClient->reconnect_param.reconnect_next_time))) {
   \                     ??iotx_mc_handle_reconnect_0: (+1)
   \        0xC   0xF105 0x0060      ADD      R0,R5,#+96
   \       0x10   0x....'....        BL       utils_time_is_expired
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??iotx_mc_handle_reconnect_1
   1746                  /* Timer has not expired. Not time to attempt reconnect yet. Return attempting reconnect */
   1747                  HAL_SleepMs(100);
   \       0x18   0x2064             MOVS     R0,#+100
   \       0x1A   0x....'....        BL       HAL_SleepMs
   1748                  return FAIL_RETURN;
   \       0x1E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}
   1749              }
   1750          
   1751              mqtt_info("start to reconnect");
   1752              /*
   1753                  rc = _conn_info_dynamic_reload(pClient);
   1754                  if (SUCCESS_RETURN != rc) {
   1755                      mqtt_err("update connect info err");
   1756                      return -1;
   1757                  }
   1758              */
   1759              rc = iotx_mc_attempt_reconnect(pClient);
   \                     ??iotx_mc_handle_reconnect_1: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x....'....        BL       iotx_mc_attempt_reconnect
   \       0x2A   0x0004             MOVS     R4,R0
   1760              if (SUCCESS_RETURN == rc) {
   \       0x2C   0xD105             BNE.N    ??iotx_mc_handle_reconnect_2
   1761                  iotx_mc_set_client_state(pClient, IOTX_MC_STATE_CONNECTED);
   \       0x2E   0x2102             MOVS     R1,#+2
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x....'....        BL       iotx_mc_set_client_state
   1762                  /*
   1763                          _conn_info_dynamic_reload_clear(pClient);
   1764                  */
   1765                  return SUCCESS_RETURN;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}
   1766              } else if (MQTT_CONNECT_BLOCK == rc) {
   \                     ??iotx_mc_handle_reconnect_2: (+1)
   \       0x3A   0xF06F 0x002B      MVN      R0,#+43
   \       0x3E   0x4284             CMP      R4,R0
   \       0x40   0xD013             BEQ.N    ??iotx_mc_handle_reconnect_3
   1767                  return rc;
   1768              } else {
   1769                  /* if reconnect network failed, then increase currentReconnectWaitInterval */
   1770                  /* e.g. init currentReconnectWaitInterval=1s, reconnect failed, then 2s..4s..8s */
   1771                  if (IOTX_MC_RECONNECT_INTERVAL_MAX_MS > pClient->reconnect_param.reconnect_time_interval_ms) {
   \       0x42   0xF64E 0x2060      MOVW     R0,#+60000
   \       0x46   0x6E69             LDR      R1,[R5, #+100]
   \       0x48   0x4281             CMP      R1,R0
   \       0x4A   0xD202             BCS.N    ??iotx_mc_handle_reconnect_4
   1772                      pClient->reconnect_param.reconnect_time_interval_ms *= 2;
   \       0x4C   0x0049             LSLS     R1,R1,#+1
   \       0x4E   0x6669             STR      R1,[R5, #+100]
   \       0x50   0xE000             B.N      ??iotx_mc_handle_reconnect_5
   1773                  } else {
   1774                      pClient->reconnect_param.reconnect_time_interval_ms = IOTX_MC_RECONNECT_INTERVAL_MAX_MS;
   \                     ??iotx_mc_handle_reconnect_4: (+1)
   \       0x52   0x6668             STR      R0,[R5, #+100]
   1775                  }
   1776              }
   1777              /*
   1778                  _conn_info_dynamic_reload_clear(pClient);
   1779              */
   1780              interval_ms = pClient->reconnect_param.reconnect_time_interval_ms;
   \                     ??iotx_mc_handle_reconnect_5: (+1)
   \       0x54   0x6E69             LDR      R1,[R5, #+100]
   1781              if (IOTX_MC_RECONNECT_INTERVAL_MAX_MS < interval_ms) {
   \       0x56   0xF64E 0x2261      MOVW     R2,#+60001
   \       0x5A   0x4291             CMP      R1,R2
   \       0x5C   0xD300             BCC.N    ??iotx_mc_handle_reconnect_6
   1782                  interval_ms = IOTX_MC_RECONNECT_INTERVAL_MAX_MS;
   \       0x5E   0x4601             MOV      R1,R0
   1783              }
   1784              utils_time_countdown_ms(&(pClient->reconnect_param.reconnect_next_time), interval_ms);
   \                     ??iotx_mc_handle_reconnect_6: (+1)
   \       0x60   0xF105 0x0060      ADD      R0,R5,#+96
   \       0x64   0x....'....        BL       utils_time_countdown_ms
   1785          
   1786              mqtt_err("mqtt reconnect failed rc = %d", rc);
   1787          
   1788              return rc;
   \       0x68   0x4620             MOV      R0,R4
   \                     ??iotx_mc_handle_reconnect_3: (+1)
   \       0x6A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1789          }
   1790          

   \                                 In section .text, align 2, keep-with-next
   1791          static void iotx_mc_reconnect_callback(iotx_mc_client_t *pClient)
   1792          {
   \                     iotx_mc_reconnect_callback: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xF8D1 0x00E0      LDR      R0,[R1, #+224]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD100             BNE.N    ??iotx_mc_reconnect_callback_0
   \        0xA   0x4770             BX       LR
   \                     ??iotx_mc_reconnect_callback_0: (+1)
   \        0xC   0xB5E0             PUSH     {R5-R7,LR}
   1793          
   1794              /* handle callback function */
   1795              if (NULL != pClient->handle_event.h_fp) {
   1796                  iotx_mqtt_event_msg_t msg;
   1797                  msg.event_type = IOTX_MQTT_EVENT_RECONNECT;
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1798                  msg.msg = NULL;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9001             STR      R0,[SP, #+4]
   1799          
   1800                  pClient->handle_event.h_fp(pClient->handle_event.pcontext,
   1801                                             pClient,
   1802                                             &msg);
   \       0x18   0x466A             MOV      R2,SP
   \       0x1A   0xF8D1 0x00E4      LDR      R0,[R1, #+228]
   \       0x1E   0xF8D1 0x30E0      LDR      R3,[R1, #+224]
   \       0x22   0x4798             BLX      R3
   1803              }
   1804          }
   \       0x24   0xBD07             POP      {R0-R2,PC}       ;; return
   1805          

   \                                 In section .text, align 2, keep-with-next
   1806          static void iotx_mc_disconnect_callback(iotx_mc_client_t *pClient)
   1807          {
   \                     iotx_mc_disconnect_callback: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xF8D1 0x00E0      LDR      R0,[R1, #+224]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD100             BNE.N    ??iotx_mc_disconnect_callback_0
   \        0xA   0x4770             BX       LR
   \                     ??iotx_mc_disconnect_callback_0: (+1)
   \        0xC   0xB5E0             PUSH     {R5-R7,LR}
   1808          
   1809              if (NULL != pClient->handle_event.h_fp) {
   1810                  iotx_mqtt_event_msg_t msg;
   1811                  msg.event_type = IOTX_MQTT_EVENT_DISCONNECT;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1812                  msg.msg = NULL;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9001             STR      R0,[SP, #+4]
   1813          
   1814                  pClient->handle_event.h_fp(pClient->handle_event.pcontext,
   1815                                             pClient,
   1816                                             &msg);
   \       0x18   0x466A             MOV      R2,SP
   \       0x1A   0xF8D1 0x00E4      LDR      R0,[R1, #+228]
   \       0x1E   0xF8D1 0x30E0      LDR      R3,[R1, #+224]
   \       0x22   0x4798             BLX      R3
   1817              }
   1818          }
   \       0x24   0xBD07             POP      {R0-R2,PC}       ;; return
   1819          

   \                                 In section .text, align 2, keep-with-next
   1820          static void iotx_mc_keepalive(iotx_mc_client_t *pClient)
   1821          {
   \                     iotx_mc_keepalive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1822              int rc = 0;
   1823              iotx_mc_state_t currentState;
   1824          
   1825              if (!pClient) {
   \        0x4   0xD02B             BEQ.N    ??iotx_mc_keepalive_0
   1826                  return;
   1827              }
   1828          
   1829              /* Periodic sending ping packet to detect whether the network is connected */
   1830              iotx_mc_keepalive_sub(pClient);
   \        0x6   0x....'....        BL       iotx_mc_keepalive_sub
   1831          
   1832              currentState = iotx_mc_get_client_state(pClient);
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x....'....        BL       iotx_mc_get_client_state
   1833              do {
   1834                  /* if Exceeds the maximum delay time, then return reconnect timeout */
   1835                  if (IOTX_MC_STATE_DISCONNECTED_RECONNECTING == currentState ||
   1836                      IOTX_MC_STATE_CONNECT_BLOCK == currentState) {
   \       0x10   0x2804             CMP      R0,#+4
   \       0x12   0xD001             BEQ.N    ??iotx_mc_keepalive_1
   \       0x14   0x2805             CMP      R0,#+5
   \       0x16   0xD10B             BNE.N    ??iotx_mc_keepalive_2
   1837                      /* Reconnection is successful, Resume regularly ping packets */
   1838                      rc = iotx_mc_handle_reconnect(pClient);
   1839                      if (SUCCESS_RETURN != rc) {
   \                     ??iotx_mc_keepalive_1: (+1)
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x....'....        BL       iotx_mc_handle_reconnect
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD11D             BNE.N    ??iotx_mc_keepalive_0
   1840                          mqtt_err("reconnect network fail, rc = %d", rc);
   1841                      } else if (MQTT_CONNECT_BLOCK == rc) {
   1842                          mqtt_debug("now using async protocol stack, wait network connected...");
   1843                      } else {
   1844                          mqtt_info("network is reconnected!");
   1845                          iotx_mc_reconnect_callback(pClient);
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x....'....        BL       iotx_mc_reconnect_callback
   1846                          pClient->reconnect_param.reconnect_time_interval_ms = IOTX_MC_RECONNECT_INTERVAL_MIN_MS;
   \       0x28   0xF44F 0x707A      MOV      R0,#+1000
   \       0x2C   0x6660             STR      R0,[R4, #+100]
   \       0x2E   0xBD10             POP      {R4,PC}
   1847                      }
   1848          
   1849                      break;
   1850                  }
   1851          
   1852                  /* If network suddenly interrupted, stop pinging packet, try to reconnect network immediately */
   1853                  if (IOTX_MC_STATE_DISCONNECTED == currentState) {
   \                     ??iotx_mc_keepalive_2: (+1)
   \       0x30   0x2803             CMP      R0,#+3
   \       0x32   0xD114             BNE.N    ??iotx_mc_keepalive_0
   1854                      mqtt_err("network is disconnected!");
   1855                      iotx_mc_disconnect_callback(pClient);
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       iotx_mc_disconnect_callback
   1856          
   1857                      pClient->reconnect_param.reconnect_time_interval_ms = IOTX_MC_RECONNECT_INTERVAL_MIN_MS;
   \       0x3A   0xF44F 0x707A      MOV      R0,#+1000
   \       0x3E   0x6660             STR      R0,[R4, #+100]
   1858                      utils_time_countdown_ms(&(pClient->reconnect_param.reconnect_next_time),
   1859                                              pClient->reconnect_param.reconnect_time_interval_ms);
   \       0x40   0x4601             MOV      R1,R0
   \       0x42   0xF104 0x0060      ADD      R0,R4,#+96
   \       0x46   0x....'....        BL       utils_time_countdown_ms
   1860          
   1861                      pClient->ipstack.disconnect(&pClient->ipstack);
   \       0x4A   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x4E   0x6D21             LDR      R1,[R4, #+80]
   \       0x50   0x4788             BLX      R1
   1862                      iotx_mc_set_client_state(pClient, IOTX_MC_STATE_DISCONNECTED_RECONNECTING);
   \       0x52   0x2104             MOVS     R1,#+4
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0xE8BD 0x4010      POP      {R4,LR}
   \       0x5A   0x....'....        B.W      iotx_mc_set_client_state
   1863                      break;
   1864                  }
   1865          
   1866              } while (0);
   1867          }
   \                     ??iotx_mc_keepalive_0: (+1)
   \       0x5E   0xBD10             POP      {R4,PC}          ;; return
   1868          

   \                                 In section .text, align 2, keep-with-next
   1869          static int iotx_mc_check_handle_is_identical_ex(iotx_mc_topic_handle_t *messageHandlers1,
   1870                  iotx_mc_topic_handle_t *messageHandler2)
   1871          {
   \                     iotx_mc_check_handle_is_identical_ex: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   1872              int topicNameLen = 0;
   1873          
   1874              if (!messageHandlers1 || !messageHandler2) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD001             BEQ.N    ??iotx_mc_check_handle_is_identical_ex_0
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??iotx_mc_check_handle_is_identical_ex_1
   1875                  return 1;
   \                     ??iotx_mc_check_handle_is_identical_ex_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xBD70             POP      {R4-R6,PC}
   1876              }
   1877          
   1878              if (!(messageHandlers1->topic_filter) || !(messageHandler2->topic_filter)) {
   \                     ??iotx_mc_check_handle_is_identical_ex_1: (+1)
   \       0x12   0x68E8             LDR      R0,[R5, #+12]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??iotx_mc_check_handle_is_identical_ex_2
   \       0x18   0x68E0             LDR      R0,[R4, #+12]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD101             BNE.N    ??iotx_mc_check_handle_is_identical_ex_3
   1879                  return 1;
   \                     ??iotx_mc_check_handle_is_identical_ex_2: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xBD70             POP      {R4-R6,PC}
   1880              }
   1881          
   1882          #if !(WITH_MQTT_ZIP_TOPIC)
   1883              topicNameLen = strlen(messageHandlers1->topic_filter);
   \                     ??iotx_mc_check_handle_is_identical_ex_3: (+1)
   \       0x22   0x68E8             LDR      R0,[R5, #+12]
   \       0x24   0x....'....        BL       strlen
   \       0x28   0x4606             MOV      R6,R0
   1884          
   1885              if (topicNameLen != strlen(messageHandler2->topic_filter)) {
   \       0x2A   0x68E0             LDR      R0,[R4, #+12]
   \       0x2C   0x....'....        BL       strlen
   \       0x30   0x4286             CMP      R6,R0
   \       0x32   0xD001             BEQ.N    ??iotx_mc_check_handle_is_identical_ex_4
   1886                  return 1;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xBD70             POP      {R4-R6,PC}
   1887              }
   1888          
   1889              if (0 != strncmp(messageHandlers1->topic_filter, messageHandler2->topic_filter, topicNameLen)) {
   \                     ??iotx_mc_check_handle_is_identical_ex_4: (+1)
   \       0x38   0x4632             MOV      R2,R6
   \       0x3A   0x68E1             LDR      R1,[R4, #+12]
   \       0x3C   0x68E8             LDR      R0,[R5, #+12]
   \       0x3E   0x....'....        BL       strncmp
   \       0x42   0x1E40             SUBS     R0,R0,#+1
   \       0x44   0x4180             SBCS     R0,R0,R0
   \       0x46   0x43C0             MVNS     R0,R0
   \       0x48   0x0FC0             LSRS     R0,R0,#+31
   1890                  return 1;
   1891              }
   1892          #else
   1893          
   1894              if (messageHandlers1->topic_type != messageHandler2->topic_type) {
   1895                  return 1;
   1896              }
   1897          
   1898              if (messageHandlers1->topic_type == TOPIC_NAME_TYPE) {
   1899                  int i;
   1900                  for (i = 0; i < MQTT_ZIP_PATH_DEFAULT_LEN; i++) {
   1901                      if (messageHandler2->topic_filter[i] != messageHandlers1->topic_filter[i]) {
   1902                          return 1;
   1903                      }
   1904                  }
   1905              } else {
   1906                  topicNameLen = strlen(messageHandlers1->topic_filter);
   1907          
   1908                  if (topicNameLen != strlen(messageHandler2->topic_filter)) {
   1909                      return 1;
   1910                  }
   1911          
   1912                  if (0 != strncmp(messageHandlers1->topic_filter, messageHandler2->topic_filter, topicNameLen)) {
   1913                      return 1;
   1914                  }
   1915              }
   1916          #endif
   1917          
   1918              return 0;
   \       0x4A   0xBD70             POP      {R4-R6,PC}       ;; return
   1919          }
   1920          

   \                                 In section .text, align 2, keep-with-next
   1921          static int iotx_mc_check_handle_is_identical(iotx_mc_topic_handle_t *messageHandlers1,
   1922                  iotx_mc_topic_handle_t *messageHandler2)
   1923          {
   \                     iotx_mc_check_handle_is_identical: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1924              if (iotx_mc_check_handle_is_identical_ex(messageHandlers1, messageHandler2) != 0) {
   \        0x6   0x....'....        BL       iotx_mc_check_handle_is_identical_ex
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??iotx_mc_check_handle_is_identical_0
   1925                  return 1;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
   1926              }
   1927          
   1928              if (messageHandlers1->handle.h_fp != messageHandler2->handle.h_fp) {
   \                     ??iotx_mc_check_handle_is_identical_0: (+1)
   \       0x12   0x6860             LDR      R0,[R4, #+4]
   \       0x14   0x6869             LDR      R1,[R5, #+4]
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD001             BEQ.N    ??iotx_mc_check_handle_is_identical_1
   1929                  return 1;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xBD32             POP      {R1,R4,R5,PC}
   1930              }
   1931          
   1932              /* context must be identical also */
   1933              if (messageHandlers1->handle.pcontext != messageHandler2->handle.pcontext) {
   \                     ??iotx_mc_check_handle_is_identical_1: (+1)
   \       0x1E   0x68A0             LDR      R0,[R4, #+8]
   \       0x20   0x68A9             LDR      R1,[R5, #+8]
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD001             BEQ.N    ??iotx_mc_check_handle_is_identical_2
   1934                  return 1;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}
   1935              }
   1936          
   1937              return 0;
   \                     ??iotx_mc_check_handle_is_identical_2: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1938          }
   1939          

   \                                 In section .text, align 2, keep-with-next
   1940          static int MQTTSubscribe(iotx_mc_client_t *c, const char *topicFilter, iotx_mqtt_qos_t qos, unsigned int msgId,
   1941                                   iotx_mqtt_event_handle_func_fpt messageHandler, void *pcontext)
   1942          {
   \                     MQTTSubscribe: (+1)
   \        0x0   0xE92D 0x43F6      PUSH     {R1,R2,R4-R9,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x461F             MOV      R7,R3
   1943              int                         len = 0;
   1944              iotx_time_t                 timer;
   1945              MQTTString                  topic = MQTTString_initializer;
   \        0xC   0xA804             ADD      R0,SP,#+16
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x460A             MOV      R2,R1
   \       0x12   0x460B             MOV      R3,R1
   \       0x14   0xE880 0x000E      STM      R0,{R1-R3}
   1946              /*iotx_mc_topic_handle_t handler = {topicFilter, {messageHandler, pcontext}};*/
   1947              iotx_mc_topic_handle_t     *handler = NULL;
   1948          #ifndef PLATFORM_HAS_DYNMEM
   1949              int idx = 0;
   1950          #endif
   1951          
   1952              if (!c || !topicFilter || !messageHandler) {
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD013             BEQ.N    ??MQTTSubscribe_0
   \       0x1C   0x2E00             CMP      R6,#+0
   \       0x1E   0xD011             BEQ.N    ??MQTTSubscribe_0
   \       0x20   0xF8DD 0x8040      LDR      R8,[SP, #+64]
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD00C             BEQ.N    ??MQTTSubscribe_0
   1953                  return FAIL_RETURN;
   1954              }
   1955          #if !( WITH_MQTT_DYN_BUF)
   1956              if (!c->buf_send) {
   1957                  return FAIL_RETURN;
   1958              }
   1959          #endif
   1960          
   1961              topic.cstring = (char *)topicFilter;
   \       0x2A   0x9604             STR      R6,[SP, #+16]
   1962              iotx_time_init(&timer);
   \       0x2C   0xA803             ADD      R0,SP,#+12
   \       0x2E   0x....'....        BL       iotx_time_init
   1963              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x32   0x68A1             LDR      R1,[R4, #+8]
   \       0x34   0xA803             ADD      R0,SP,#+12
   \       0x36   0x....'....        BL       utils_time_countdown_ms
   1964          
   1965          #ifdef PLATFORM_HAS_DYNMEM
   1966              handler = mqtt_malloc(sizeof(iotx_mc_topic_handle_t));
   \       0x3A   0x2018             MOVS     R0,#+24
   \       0x3C   0x....'....        BL       HAL_Malloc
   \       0x40   0x0005             MOVS     R5,R0
   1967              if (NULL == handler) {
   \       0x42   0xD102             BNE.N    ??MQTTSubscribe_1
   1968                  return FAIL_RETURN;
   \                     ??MQTTSubscribe_0: (+1)
   \       0x44   0xF04F 0x30FF      MOV      R0,#-1
   \       0x48   0xE0B7             B.N      ??MQTTSubscribe_2
   1969              }
   1970              memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   \                     ??MQTTSubscribe_1: (+1)
   \       0x4A   0x2200             MOVS     R2,#+0
   \       0x4C   0x2118             MOVS     R1,#+24
   \       0x4E   0x....'....        BL       __aeabi_memset4
   1971              INIT_LIST_HEAD(&handler->linked_list);
   \       0x52   0xF105 0x0010      ADD      R0,R5,#+16
   \       0x56   0x....'....        BL       INIT_AOS_DLIST_HEAD
   1972          #else
   1973              for (idx = 0; idx < IOTX_MC_SUBHANDLE_LIST_MAX_LEN; idx++) {
   1974                  if (c->list_sub_handle[idx].used == 0) {
   1975                      handler = &c->list_sub_handle[idx];
   1976                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   1977                      c->list_sub_handle[idx].used = 1;
   1978                      break;
   1979                  }
   1980              }
   1981          
   1982              if (handler == NULL) {
   1983                  return MQTT_SUBHANDLE_LIST_LEN_TOO_SHORT;
   1984              }
   1985          #endif
   1986          
   1987          #if !(WITH_MQTT_ZIP_TOPIC)
   1988          #ifdef PLATFORM_HAS_DYNMEM
   1989              handler->topic_filter = mqtt_malloc(strlen(topicFilter) + 1);
   \       0x5A   0x4630             MOV      R0,R6
   \       0x5C   0x....'....        BL       strlen
   \       0x60   0x1C40             ADDS     R0,R0,#+1
   \       0x62   0x....'....        BL       HAL_Malloc
   \       0x66   0x60E8             STR      R0,[R5, #+12]
   1990              if (NULL == handler->topic_filter) {
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD105             BNE.N    ??MQTTSubscribe_3
   1991                  mqtt_free(handler);
   \       0x6C   0x4628             MOV      R0,R5
   \       0x6E   0x....'....        BL       HAL_Free
   1992                  return FAIL_RETURN;
   \       0x72   0xF04F 0x30FF      MOV      R0,#-1
   \       0x76   0xE0A0             B.N      ??MQTTSubscribe_2
   1993              }
   \                     ??MQTTSubscribe_3: (+1)
   \       0x78   0xF8DD 0x9044      LDR      R9,[SP, #+68]
   1994              memset((char *)handler->topic_filter, 0, strlen(topicFilter) + 1);
   \       0x7C   0x4630             MOV      R0,R6
   \       0x7E   0x....'....        BL       strlen
   \       0x82   0x1C40             ADDS     R0,R0,#+1
   \       0x84   0x2200             MOVS     R2,#+0
   \       0x86   0x4601             MOV      R1,R0
   \       0x88   0x68E8             LDR      R0,[R5, #+12]
   \       0x8A   0x....'....        BL       __aeabi_memset
   1995          #else
   1996              if (strlen(topicFilter) >= CONFIG_MQTT_TOPIC_MAXLEN) {
   1997                  memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   1998                  return MQTT_TOPIC_LEN_TOO_SHORT;
   1999              }
   2000          
   2001              memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2002          #endif
   2003              memcpy((char *)handler->topic_filter, topicFilter, strlen(topicFilter) + 1);
   \       0x8E   0x4630             MOV      R0,R6
   \       0x90   0x....'....        BL       strlen
   \       0x94   0x1C40             ADDS     R0,R0,#+1
   \       0x96   0x4602             MOV      R2,R0
   \       0x98   0x4631             MOV      R1,R6
   \       0x9A   0x68E8             LDR      R0,[R5, #+12]
   \       0x9C   0x....'....        BL       __aeabi_memcpy
   2004          #else
   2005              if (strstr(topicFilter, "/+") != NULL || strstr(topicFilter, "/#") != NULL) {
   2006          #ifdef PLATFORM_HAS_DYNMEM
   2007                  handler->topic_filter = mqtt_malloc(strlen(topicFilter) + 1);
   2008                  if (NULL == handler->topic_filter) {
   2009                      mqtt_free(handler);
   2010                      return FAIL_RETURN;
   2011                  }
   2012                  memset((char *)handler->topic_filter, 0, strlen(topicFilter) + 1);
   2013          #else
   2014                  if (strlen(topicFilter) >= CONFIG_MQTT_TOPIC_MAXLEN) {
   2015                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2016                      return MQTT_TOPIC_LEN_TOO_SHORT;
   2017                  }
   2018                  memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2019          #endif
   2020                  handler->topic_type = TOPIC_FILTER_TYPE;
   2021                  memcpy((char *)handler->topic_filter, topicFilter, strlen(topicFilter) + 1);
   2022              } else {
   2023          #ifdef PLATFORM_HAS_DYNMEM
   2024                  handler->topic_filter = mqtt_malloc(MQTT_ZIP_PATH_DEFAULT_LEN);
   2025                  if (NULL == handler->topic_filter) {
   2026                      mqtt_free(handler);
   2027                      return FAIL_RETURN;
   2028                  }
   2029                  memset((char *)handler->topic_filter, 0, MQTT_ZIP_PATH_DEFAULT_LEN);
   2030          #else
   2031                  if (MQTT_ZIP_PATH_DEFAULT_LEN >= CONFIG_MQTT_TOPIC_MAXLEN) {
   2032                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2033                      return MQTT_TOPIC_LEN_TOO_SHORT;
   2034                  }
   2035                  memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2036          #endif
   2037                  handler->topic_type = TOPIC_NAME_TYPE;
   2038                  if (iotx_mc_get_zip_topic(topicFilter, strlen(topicFilter), (char *)handler->topic_filter,
   2039                                            MQTT_ZIP_PATH_DEFAULT_LEN) != 0) {
   2040          #ifdef PLATFORM_HAS_DYNMEM
   2041                      mqtt_free(handler->topic_filter);
   2042                      mqtt_free(handler);
   2043          #else
   2044                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2045          #endif
   2046                      return FAIL_RETURN;
   2047                  }
   2048              }
   2049          #endif
   2050              handler->handle.h_fp = messageHandler;
   \       0xA0   0xF8C5 0x8004      STR      R8,[R5, #+4]
   2051              handler->handle.pcontext = pcontext;
   \       0xA4   0xF8C5 0x9008      STR      R9,[R5, #+8]
   2052          
   2053          #ifdef SUB_PERSISTENCE_ENABLED
   2054              if (qos == IOTX_MQTT_QOS3_SUB_LOCAL) {
   2055                  uint8_t dup = 0;
   2056          #ifdef PLATFORM_HAS_DYNMEM
   2057                  iotx_mc_topic_handle_t *node;
   2058          #endif
   2059                  HAL_MutexLock(c->lock_generic);
   2060          #ifdef PLATFORM_HAS_DYNMEM
   2061          #if defined(INSPECT_MQTT_FLOW) && defined (INFRA_LOG)
   2062          #if WITH_MQTT_ZIP_TOPIC
   2063                  HEXDUMP_DEBUG(handler->topic_filter, MQTT_ZIP_PATH_DEFAULT_LEN);
   2064          #else
   2065                  mqtt_warning("handler->topic: %s", handler->topic_filter);
   2066          #endif
   2067          #endif
   2068                  list_for_each_entry(node, &c->list_sub_handle, linked_list, iotx_mc_topic_handle_t) {
   2069                      /* If subscribe the same topic and callback function, then ignore */
   2070          #if defined(INSPECT_MQTT_FLOW) && defined (INFRA_LOG)
   2071          #if WITH_MQTT_ZIP_TOPIC
   2072                      HEXDUMP_DEBUG(node->topic_filter, MQTT_ZIP_PATH_DEFAULT_LEN);
   2073          #else
   2074                      mqtt_warning("node->topic: %s", node->topic_filter);
   2075          #endif
   2076          #endif
   2077                      if (0 == iotx_mc_check_handle_is_identical(node, handler)) {
   2078                          mqtt_warning("dup sub,topic = %s", topicFilter);
   2079                          dup = 1;
   2080                      }
   2081                  }
   2082          #else
   2083                  for (idx = 0; idx < IOTX_MC_SUBHANDLE_LIST_MAX_LEN; idx++) {
   2084                      /* If subscribe the same topic and callback function, then ignore */
   2085                      if (&c->list_sub_handle[idx] != handler &&
   2086                          0 == iotx_mc_check_handle_is_identical(&c->list_sub_handle[idx], handler)) {
   2087                          mqtt_warning("dup sub,topic = %s", topicFilter);
   2088                          dup = 1;
   2089                      }
   2090                  }
   2091          #endif
   2092                  if (dup == 0) {
   2093          #ifdef PLATFORM_HAS_DYNMEM
   2094                      list_add_tail(&handler->linked_list, &c->list_sub_handle);
   2095          #endif
   2096                  } else {
   2097          #ifdef PLATFORM_HAS_DYNMEM
   2098                      mqtt_free(handler->topic_filter);
   2099                      mqtt_free(handler);
   2100          #else
   2101                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2102          #endif
   2103                  }
   2104                  HAL_MutexUnlock(c->lock_generic);
   2105                  return SUCCESS_RETURN;
   2106              }
   2107          #endif
   2108          
   2109              HAL_MutexLock(c->lock_write_buf);
   \       0xA8   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xAC   0x....'....        BL       HAL_MutexLock
   2110          
   2111              if (_alloc_send_buffer(c, strlen(topicFilter)) < 0) {
   \       0xB0   0x4630             MOV      R0,R6
   \       0xB2   0x....'....        BL       strlen
   \       0xB6   0x4601             MOV      R1,R0
   \       0xB8   0x4620             MOV      R0,R4
   \       0xBA   0x....'....        BL       _alloc_send_buffer
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD50E             BPL.N    ??MQTTSubscribe_4
   2112                  HAL_MutexUnlock(c->lock_write_buf);
   \       0xC2   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xC6   0x....'....        BL       HAL_MutexUnlock
   2113          #ifdef PLATFORM_HAS_DYNMEM
   2114                  mqtt_free(handler->topic_filter);
   \       0xCA   0x68E8             LDR      R0,[R5, #+12]
   \       0xCC   0x....'....        BL       HAL_Free
   \       0xD0   0x2000             MOVS     R0,#+0
   \       0xD2   0x60E8             STR      R0,[R5, #+12]
   2115                  mqtt_free(handler);
   \       0xD4   0x4628             MOV      R0,R5
   \       0xD6   0x....'....        BL       HAL_Free
   2116          #else
   2117                  memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2118          #endif
   2119                  return FAIL_RETURN;
   \       0xDA   0xF04F 0x30FF      MOV      R0,#-1
   \       0xDE   0xE06C             B.N      ??MQTTSubscribe_2
   2120              }
   2121          
   2122              len = MQTTSerialize_subscribe((unsigned char *)c->buf_send, c->buf_size_send, 0, (unsigned short)msgId, 1, &topic,
   2123                                            (int *)&qos);
   \                     ??MQTTSubscribe_4: (+1)
   \       0xE0   0xA808             ADD      R0,SP,#+32
   \       0xE2   0x9002             STR      R0,[SP, #+8]
   \       0xE4   0xA804             ADD      R0,SP,#+16
   \       0xE6   0x9001             STR      R0,[SP, #+4]
   \       0xE8   0x2001             MOVS     R0,#+1
   \       0xEA   0x9000             STR      R0,[SP, #+0]
   \       0xEC   0x463B             MOV      R3,R7
   \       0xEE   0xB29B             UXTH     R3,R3
   \       0xF0   0x2200             MOVS     R2,#+0
   \       0xF2   0x6921             LDR      R1,[R4, #+16]
   \       0xF4   0x6A60             LDR      R0,[R4, #+36]
   \       0xF6   0x....'....        BL       MQTTSerialize_subscribe
   2124              if (len <= 0) {
   \       0xFA   0x2801             CMP      R0,#+1
   \       0xFC   0xDA11             BGE.N    ??MQTTSubscribe_5
   2125          #ifdef PLATFORM_HAS_DYNMEM
   2126                  mqtt_free(handler->topic_filter);
   \       0xFE   0x68E8             LDR      R0,[R5, #+12]
   \      0x100   0x....'....        BL       HAL_Free
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0x60E8             STR      R0,[R5, #+12]
   2127                  mqtt_free(handler);
   \      0x108   0x4628             MOV      R0,R5
   \      0x10A   0x....'....        BL       HAL_Free
   2128          #else
   2129                  memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2130          #endif
   2131                  _reset_send_buffer(c);
   \      0x10E   0x4620             MOV      R0,R4
   \      0x110   0x....'....        BL       _reset_send_buffer
   2132                  HAL_MutexUnlock(c->lock_write_buf);
   \      0x114   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x118   0x....'....        BL       HAL_MutexUnlock
   2133                  return MQTT_SUBSCRIBE_PACKET_ERROR;
   \      0x11C   0xF06F 0x0019      MVN      R0,#+25
   \      0x120   0xE04B             B.N      ??MQTTSubscribe_2
   2134              }
   2135          
   2136              mqtt_debug("%20s : %08d", "Packet Ident", msgId);
   2137              mqtt_debug("%20s : %s", "Topic", topicFilter);
   2138              mqtt_debug("%20s : %d", "QoS", (int)qos);
   2139              mqtt_debug("%20s : %d", "Packet Length", len);
   2140          #if defined(INSPECT_MQTT_FLOW) && defined (INFRA_LOG)
   2141              HEXDUMP_DEBUG(c->buf_send, len);
   2142          #endif
   2143          
   2144              if ((iotx_mc_send_packet(c, c->buf_send, len, &timer)) != SUCCESS_RETURN) { /* send the subscribe packet */
   \                     ??MQTTSubscribe_5: (+1)
   \      0x122   0xAB03             ADD      R3,SP,#+12
   \      0x124   0x4602             MOV      R2,R0
   \      0x126   0x6A61             LDR      R1,[R4, #+36]
   \      0x128   0x4620             MOV      R0,R4
   \      0x12A   0x....'....        BL       iotx_mc_send_packet
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD011             BEQ.N    ??MQTTSubscribe_6
   2145                  /* If send failed, remove it */
   2146                  mqtt_err("run sendPacket error!");
   2147          #ifdef PLATFORM_HAS_DYNMEM
   2148                  mqtt_free(handler->topic_filter);
   \      0x132   0x68E8             LDR      R0,[R5, #+12]
   \      0x134   0x....'....        BL       HAL_Free
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0x60E8             STR      R0,[R5, #+12]
   2149                  mqtt_free(handler);
   \      0x13C   0x4628             MOV      R0,R5
   \      0x13E   0x....'....        BL       HAL_Free
   2150          #else
   2151                  memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2152          #endif
   2153                  _reset_send_buffer(c);
   \      0x142   0x4620             MOV      R0,R4
   \      0x144   0x....'....        BL       _reset_send_buffer
   2154                  HAL_MutexUnlock(c->lock_write_buf);
   \      0x148   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x14C   0x....'....        BL       HAL_MutexUnlock
   2155                  return MQTT_NETWORK_ERROR;
   \      0x150   0xF06F 0x000D      MVN      R0,#+13
   \      0x154   0xE031             B.N      ??MQTTSubscribe_2
   2156              }
   2157              _reset_send_buffer(c);
   \                     ??MQTTSubscribe_6: (+1)
   \      0x156   0x4620             MOV      R0,R4
   \      0x158   0x....'....        BL       _reset_send_buffer
   2158              HAL_MutexUnlock(c->lock_write_buf);
   \      0x15C   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x160   0x....'....        BL       HAL_MutexUnlock
   2159          
   2160              {
   2161                  uint8_t dup = 0;
   \      0x164   0x2600             MOVS     R6,#+0
   2162          #ifdef PLATFORM_HAS_DYNMEM
   2163                  iotx_mc_topic_handle_t *node;
   2164          #endif
   2165                  HAL_MutexLock(c->lock_generic);
   \      0x166   0x6820             LDR      R0,[R4, #+0]
   \      0x168   0x....'....        BL       HAL_MutexLock
   2166          #ifdef PLATFORM_HAS_DYNMEM
   2167          #if defined(INSPECT_MQTT_FLOW) && defined (INFRA_LOG)
   2168          #if WITH_MQTT_ZIP_TOPIC
   2169                  HEXDUMP_DEBUG(handler->topic_filter, MQTT_ZIP_PATH_DEFAULT_LEN);
   2170          #else
   2171                  mqtt_warning("handler->topic: %s", handler->topic_filter);
   2172          #endif
   2173          #endif
   2174                  list_for_each_entry(node, &c->list_sub_handle, linked_list, iotx_mc_topic_handle_t) {
   \      0x16C   0x6B20             LDR      R0,[R4, #+48]
   \      0x16E   0xF1A0 0x0710      SUB      R7,R0,#+16
   \      0x172   0xE009             B.N      ??MQTTSubscribe_7
   2175                      /* If subscribe the same topic and callback function, then ignore */
   2176          #if defined(INSPECT_MQTT_FLOW) && defined (INFRA_LOG)
   2177          #if WITH_MQTT_ZIP_TOPIC
   2178                      HEXDUMP_DEBUG(node->topic_filter, MQTT_ZIP_PATH_DEFAULT_LEN);
   2179          #else
   2180                      mqtt_warning("node->topic: %s", node->topic_filter);
   2181          #endif
   2182          #endif
   2183                      if (0 == iotx_mc_check_handle_is_identical(node, handler)) {
   \                     ??MQTTSubscribe_8: (+1)
   \      0x174   0x4629             MOV      R1,R5
   \      0x176   0x4638             MOV      R0,R7
   \      0x178   0x....'....        BL       iotx_mc_check_handle_is_identical
   \      0x17C   0x2800             CMP      R0,#+0
   \      0x17E   0xD100             BNE.N    ??MQTTSubscribe_9
   2184                          mqtt_warning("dup sub,topic = %s", topicFilter);
   2185                          dup = 1;
   \      0x180   0x2601             MOVS     R6,#+1
   2186                      }
   2187                  }
   \                     ??MQTTSubscribe_9: (+1)
   \      0x182   0x6978             LDR      R0,[R7, #+20]
   \      0x184   0xF1A0 0x0710      SUB      R7,R0,#+16
   \                     ??MQTTSubscribe_7: (+1)
   \      0x188   0xF107 0x0010      ADD      R0,R7,#+16
   \      0x18C   0xF104 0x012C      ADD      R1,R4,#+44
   \      0x190   0x4288             CMP      R0,R1
   \      0x192   0xD1EF             BNE.N    ??MQTTSubscribe_8
   2188          #else
   2189                  for (idx = 0; idx < IOTX_MC_SUBHANDLE_LIST_MAX_LEN; idx++) {
   2190                      /* If subscribe the same topic and callback function, then ignore */
   2191                      if (&c->list_sub_handle[idx] != handler &&
   2192                          0 == iotx_mc_check_handle_is_identical(&c->list_sub_handle[idx], handler)) {
   2193                          mqtt_warning("dup sub,topic = %s", topicFilter);
   2194                          dup = 1;
   2195                      }
   2196                  }
   2197          #endif
   2198                  if (dup == 0) {
   \      0x194   0x2E00             CMP      R6,#+0
   \      0x196   0xD104             BNE.N    ??MQTTSubscribe_10
   2199          #ifdef PLATFORM_HAS_DYNMEM
   2200                      list_add_tail(&handler->linked_list, &c->list_sub_handle);
   \      0x198   0xF105 0x0010      ADD      R0,R5,#+16
   \      0x19C   0x....'....        BL       dlist_add_tail
   \      0x1A0   0xE007             B.N      ??MQTTSubscribe_11
   2201          #endif
   2202                  } else {
   2203          #ifdef PLATFORM_HAS_DYNMEM
   2204                      mqtt_free(handler->topic_filter);
   \                     ??MQTTSubscribe_10: (+1)
   \      0x1A2   0x68E8             LDR      R0,[R5, #+12]
   \      0x1A4   0x....'....        BL       HAL_Free
   \      0x1A8   0x2000             MOVS     R0,#+0
   \      0x1AA   0x60E8             STR      R0,[R5, #+12]
   2205                      mqtt_free(handler);
   \      0x1AC   0x4628             MOV      R0,R5
   \      0x1AE   0x....'....        BL       HAL_Free
   2206          #else
   2207                      memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   2208          #endif
   2209                  }
   2210                  HAL_MutexUnlock(c->lock_generic);
   \                     ??MQTTSubscribe_11: (+1)
   \      0x1B2   0x6820             LDR      R0,[R4, #+0]
   \      0x1B4   0x....'....        BL       HAL_MutexUnlock
   2211              }
   2212          
   2213              return SUCCESS_RETURN;
   \      0x1B8   0x2000             MOVS     R0,#+0
   \                     ??MQTTSubscribe_2: (+1)
   \      0x1BA   0xB009             ADD      SP,SP,#+36
   \      0x1BC   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2214          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   2215          

   \                                 In section .text, align 2, keep-with-next
   2216          static int iotx_mc_get_next_packetid(iotx_mc_client_t *c)
   2217          {
   \                     iotx_mc_get_next_packetid: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2218              unsigned int id = 0;
   2219          
   2220              if (!c) {
   \        0x4   0xD102             BNE.N    ??iotx_mc_get_next_packetid_0
   2221                  return FAIL_RETURN;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
   2222              }
   2223          
   2224              HAL_MutexLock(c->lock_generic);
   \                     ??iotx_mc_get_next_packetid_0: (+1)
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x....'....        BL       HAL_MutexLock
   2225              c->packet_id = (c->packet_id == IOTX_MC_PACKET_ID_MAX) ? 1 : c->packet_id + 1;
   \       0x12   0x6860             LDR      R0,[R4, #+4]
   \       0x14   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0x18   0x4288             CMP      R0,R1
   \       0x1A   0xD101             BNE.N    ??iotx_mc_get_next_packetid_1
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE000             B.N      ??iotx_mc_get_next_packetid_2
   \                     ??iotx_mc_get_next_packetid_1: (+1)
   \       0x20   0x1C40             ADDS     R0,R0,#+1
   \                     ??iotx_mc_get_next_packetid_2: (+1)
   \       0x22   0x6060             STR      R0,[R4, #+4]
   2226              id = c->packet_id;
   \       0x24   0x4605             MOV      R5,R0
   2227              HAL_MutexUnlock(c->lock_generic);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x....'....        BL       HAL_MutexUnlock
   2228          
   2229              return id;
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2230          }
   2231          

   \                                 In section .text, align 2, keep-with-next
   2232          static int iotx_mc_check_rule(char *iterm, iotx_mc_topic_type_t type)
   2233          {
   \                     iotx_mc_check_rule: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   2234              int i = 0;
   \        0x6   0x2600             MOVS     R6,#+0
   2235              int len = 0;
   2236          
   2237              if (NULL == iterm) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD016             BEQ.N    ??iotx_mc_check_rule_0
   2238                  mqtt_err("iterm is NULL");
   2239                  return FAIL_RETURN;
   2240              }
   2241          
   2242              len = strlen(iterm);
   \        0xC   0x....'....        BL       strlen
   2243          
   2244              for (i = 0; i < len; i++) {
   \       0x10   0xE007             B.N      ??iotx_mc_check_rule_1
   2245                  if (TOPIC_FILTER_TYPE == type) {
   2246                      if ('+' == iterm[i] || '#' == iterm[i]) {
   2247                          if (1 != len) {
   2248                              mqtt_err("the character # and + is error");
   2249                              return FAIL_RETURN;
   2250                          }
   2251                      }
   2252                  } else {
   2253                      if ('+' == iterm[i] || '#' == iterm[i]) {
   \                     ??iotx_mc_check_rule_2: (+1)
   \       0x12   0x292B             CMP      R1,#+43
   \       0x14   0xD011             BEQ.N    ??iotx_mc_check_rule_0
   \       0x16   0x2923             CMP      R1,#+35
   \       0x18   0xD00F             BEQ.N    ??iotx_mc_check_rule_0
   2254                          mqtt_err("has character # and + is error");
   2255                          return FAIL_RETURN;
   2256                      }
   2257                  }
   2258          
   2259                  if (iterm[i] < 32 || iterm[i] >= 127) {
   \                     ??iotx_mc_check_rule_3: (+1)
   \       0x1A   0x3920             SUBS     R1,R1,#+32
   \       0x1C   0x295F             CMP      R1,#+95
   \       0x1E   0xD20C             BCS.N    ??iotx_mc_check_rule_0
   \       0x20   0x1C76             ADDS     R6,R6,#+1
   \                     ??iotx_mc_check_rule_1: (+1)
   \       0x22   0x4286             CMP      R6,R0
   \       0x24   0xDA0C             BGE.N    ??iotx_mc_check_rule_4
   \       0x26   0x4629             MOV      R1,R5
   \       0x28   0x2901             CMP      R1,#+1
   \       0x2A   0x5DA1             LDRB     R1,[R4, R6]
   \       0x2C   0xD1F1             BNE.N    ??iotx_mc_check_rule_2
   \       0x2E   0x292B             CMP      R1,#+43
   \       0x30   0xD001             BEQ.N    ??iotx_mc_check_rule_5
   \       0x32   0x2923             CMP      R1,#+35
   \       0x34   0xD1F1             BNE.N    ??iotx_mc_check_rule_3
   \                     ??iotx_mc_check_rule_5: (+1)
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD0EF             BEQ.N    ??iotx_mc_check_rule_3
   2260                      return FAIL_RETURN;
   \                     ??iotx_mc_check_rule_0: (+1)
   \       0x3A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x3E   0xBD70             POP      {R4-R6,PC}
   2261                  }
   2262              }
   2263              return SUCCESS_RETURN;
   \                     ??iotx_mc_check_rule_4: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD70             POP      {R4-R6,PC}       ;; return
   2264          }
   2265          

   \                                 In section .text, align 2, keep-with-next
   2266          static int iotx_mc_check_topic(const char *topicName, iotx_mc_topic_type_t type)
   2267          {
   \                     iotx_mc_check_topic: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB0A0             SUB      SP,SP,#+128
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   2268              int mask = 0;
   \        0x8   0x2600             MOVS     R6,#+0
   2269              char *delim = "/";
   \        0xA   0x....             ADR.N    R7,??DataTable7  ;; "/"
   2270              char *iterm = NULL;
   2271              char topicString[CONFIG_MQTT_TOPIC_MAXLEN];
   2272              if (NULL == topicName || '/' != topicName[0]) {
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD02B             BEQ.N    ??iotx_mc_check_topic_0
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x282F             CMP      R0,#+47
   \       0x14   0xD128             BNE.N    ??iotx_mc_check_topic_0
   2273                  return FAIL_RETURN;
   2274              }
   2275          
   2276              if (strlen(topicName) > CONFIG_MQTT_TOPIC_MAXLEN) {
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x....'....        BL       strlen
   \       0x1C   0x2881             CMP      R0,#+129
   \       0x1E   0xD223             BCS.N    ??iotx_mc_check_topic_0
   2277                  mqtt_err("len of topicName exceeds %d", CONFIG_MQTT_TOPIC_MAXLEN);
   2278                  return FAIL_RETURN;
   2279              }
   2280          
   2281              memset(topicString, 0x0, CONFIG_MQTT_TOPIC_MAXLEN);
   \       0x20   0x4632             MOV      R2,R6
   \       0x22   0x2180             MOVS     R1,#+128
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x....'....        BL       __aeabi_memset4
   2282              strncpy(topicString, topicName, CONFIG_MQTT_TOPIC_MAXLEN - 1);
   \       0x2A   0x227F             MOVS     R2,#+127
   \       0x2C   0x4621             MOV      R1,R4
   \       0x2E   0x4668             MOV      R0,SP
   \       0x30   0x....'....        BL       strncpy
   2283          
   2284              iterm = infra_strtok(topicString, delim);
   \       0x34   0x4639             MOV      R1,R7
   \       0x36   0x....'....        BL       infra_strtok
   2285          
   2286              if (SUCCESS_RETURN != iotx_mc_check_rule(iterm, type)) {
   \       0x3A   0x4629             MOV      R1,R5
   \       0x3C   0x....'....        BL       iotx_mc_check_rule
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD111             BNE.N    ??iotx_mc_check_topic_0
   \       0x44   0xE003             B.N      ??iotx_mc_check_topic_1
   2287                  mqtt_err("run iotx_check_rule error");
   2288                  return FAIL_RETURN;
   2289              }
   2290          
   2291              for (;;) {
   2292                  iterm = infra_strtok(NULL, delim);
   2293          
   2294                  if (iterm == NULL) {
   2295                      break;
   2296                  }
   2297          
   2298                  /* The character '#' is not in the last */
   2299                  if (1 == mask) {
   2300                      mqtt_err("the character # is error");
   2301                      return FAIL_RETURN;
   2302                  }
   2303          
   2304                  if (SUCCESS_RETURN != iotx_mc_check_rule(iterm, type)) {
   2305                      mqtt_err("run iotx_check_rule error");
   2306                      return FAIL_RETURN;
   2307                  }
   2308          
   2309                  if (iterm[0] == '#') {
   \                     ??iotx_mc_check_topic_2: (+1)
   \       0x46   0x7820             LDRB     R0,[R4, #+0]
   \       0x48   0x2823             CMP      R0,#+35
   \       0x4A   0xD100             BNE.N    ??iotx_mc_check_topic_1
   2310                      mask = 1;
   \       0x4C   0x2601             MOVS     R6,#+1
   2311                  }
   \                     ??iotx_mc_check_topic_1: (+1)
   \       0x4E   0x4639             MOV      R1,R7
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x....'....        BL       infra_strtok
   \       0x56   0x0004             MOVS     R4,R0
   \       0x58   0xD00A             BEQ.N    ??iotx_mc_check_topic_3
   \       0x5A   0x2E01             CMP      R6,#+1
   \       0x5C   0xD004             BEQ.N    ??iotx_mc_check_topic_0
   \       0x5E   0x4629             MOV      R1,R5
   \       0x60   0x....'....        BL       iotx_mc_check_rule
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD0EE             BEQ.N    ??iotx_mc_check_topic_2
   \                     ??iotx_mc_check_topic_0: (+1)
   \       0x68   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??iotx_mc_check_topic_4: (+1)
   \       0x6C   0xB021             ADD      SP,SP,#+132
   \       0x6E   0xBDF0             POP      {R4-R7,PC}       ;; return
   2312              }
   2313          
   2314              return SUCCESS_RETURN;
   \                     ??iotx_mc_check_topic_3: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xE7FB             B.N      ??iotx_mc_check_topic_4
   2315          }
   2316          

   \                                 In section .text, align 2, keep-with-next
   2317          static inline int _is_in_yield_cb()
   2318          {
   2319              return _in_yield_cb;
   \                     _is_in_yield_cb: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable8
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR               ;; return
   2320          }
   2321          

   \                                 In section .text, align 2, keep-with-next
   2322          static int MQTTUnsubscribe(iotx_mc_client_t *c, const char *topicFilter, unsigned int msgId)
   2323          {
   \                     MQTTUnsubscribe: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   2324              MQTTString cur_topic;
   2325              iotx_time_t timer;
   2326              MQTTString topic = MQTTString_initializer;
   \        0xA   0xA806             ADD      R0,SP,#+24
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x460A             MOV      R2,R1
   \       0x10   0x460B             MOV      R3,R1
   \       0x12   0xE880 0x000E      STM      R0,{R1-R3}
   2327              int len = 0;
   2328              /*iotx_mc_topic_handle_t handler = {topicFilter, {NULL, NULL}};*/
   2329              iotx_mc_topic_handle_t *handler = NULL;
   2330          #ifdef PLATFORM_HAS_DYNMEM
   2331              iotx_mc_topic_handle_t *node = NULL;
   2332              iotx_mc_topic_handle_t *next = NULL;
   2333          #else
   2334              int idx = 0;
   2335              iotx_mc_topic_handle_t s_handler;
   2336          #endif
   2337              if (!c || !topicFilter) {
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD00E             BEQ.N    ??MQTTUnsubscribe_0
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD00C             BEQ.N    ??MQTTUnsubscribe_0
   2338                  return FAIL_RETURN;
   2339              }
   2340          
   2341              topic.cstring = (char *)topicFilter;
   \       0x1E   0x9606             STR      R6,[SP, #+24]
   2342              iotx_time_init(&timer);
   \       0x20   0xA802             ADD      R0,SP,#+8
   \       0x22   0x....'....        BL       iotx_time_init
   2343              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x26   0x68A1             LDR      R1,[R4, #+8]
   \       0x28   0xA802             ADD      R0,SP,#+8
   \       0x2A   0x....'....        BL       utils_time_countdown_ms
   2344          
   2345          #ifdef PLATFORM_HAS_DYNMEM
   2346              handler = mqtt_malloc(sizeof(iotx_mc_topic_handle_t));
   \       0x2E   0x2018             MOVS     R0,#+24
   \       0x30   0x....'....        BL       HAL_Malloc
   \       0x34   0x0005             MOVS     R5,R0
   2347              if (NULL == handler) {
   \       0x36   0xD102             BNE.N    ??MQTTUnsubscribe_1
   2348                  return FAIL_RETURN;
   \                     ??MQTTUnsubscribe_0: (+1)
   \       0x38   0xF04F 0x30FF      MOV      R0,#-1
   \       0x3C   0xE0C1             B.N      ??MQTTUnsubscribe_2
   2349              }
   2350          #else
   2351              handler = &s_handler;
   2352          #endif
   2353          
   2354              memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
   \                     ??MQTTUnsubscribe_1: (+1)
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x2118             MOVS     R1,#+24
   \       0x42   0x....'....        BL       __aeabi_memset4
   2355          
   2356          #if !(WITH_MQTT_ZIP_TOPIC)
   2357          #ifdef PLATFORM_HAS_DYNMEM
   2358              handler->topic_filter = mqtt_malloc(strlen(topicFilter) + 1);
   \       0x46   0x4630             MOV      R0,R6
   \       0x48   0x....'....        BL       strlen
   \       0x4C   0x1C40             ADDS     R0,R0,#+1
   \       0x4E   0x....'....        BL       HAL_Malloc
   \       0x52   0x60E8             STR      R0,[R5, #+12]
   2359              if (NULL == handler->topic_filter) {
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD105             BNE.N    ??MQTTUnsubscribe_3
   2360                  mqtt_free(handler);
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       HAL_Free
   2361                  return FAIL_RETURN;
   \       0x5E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x62   0xE0AE             B.N      ??MQTTUnsubscribe_2
   2362              }
   2363              memset((char *)handler->topic_filter, 0, strlen(topicFilter) + 1);
   \                     ??MQTTUnsubscribe_3: (+1)
   \       0x64   0x4630             MOV      R0,R6
   \       0x66   0x....'....        BL       strlen
   \       0x6A   0x1C40             ADDS     R0,R0,#+1
   \       0x6C   0x2200             MOVS     R2,#+0
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0x68E8             LDR      R0,[R5, #+12]
   \       0x72   0x....'....        BL       __aeabi_memset
   2364          #else
   2365              if (strlen(topicFilter) >= CONFIG_MQTT_TOPIC_MAXLEN) {
   2366                  return MQTT_TOPIC_LEN_TOO_SHORT;
   2367              }
   2368              memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2369          #endif
   2370              memcpy((char *)handler->topic_filter, topicFilter, strlen(topicFilter) + 1);
   \       0x76   0x4630             MOV      R0,R6
   \       0x78   0x....'....        BL       strlen
   \       0x7C   0x1C40             ADDS     R0,R0,#+1
   \       0x7E   0x4602             MOV      R2,R0
   \       0x80   0x4631             MOV      R1,R6
   \       0x82   0x68E8             LDR      R0,[R5, #+12]
   \       0x84   0x....'....        BL       __aeabi_memcpy
   2371          #else
   2372              if (strstr(topicFilter, "/+") != NULL || strstr(topicFilter, "/#") != NULL) {
   2373          #ifdef PLATFORM_HAS_DYNMEM
   2374                  handler->topic_filter = mqtt_malloc(strlen(topicFilter) + 1);
   2375                  if (NULL == handler->topic_filter) {
   2376                      mqtt_free(handler);
   2377                      return FAIL_RETURN;
   2378                  }
   2379                  memset((char *)handler->topic_filter, 0, strlen(topicFilter) + 1);
   2380          #else
   2381                  if (strlen(topicFilter) >= CONFIG_MQTT_TOPIC_MAXLEN) {
   2382                      return MQTT_TOPIC_LEN_TOO_SHORT;
   2383                  }
   2384                  memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2385          #endif
   2386                  handler->topic_type = TOPIC_FILTER_TYPE;
   2387                  memcpy((char *)handler->topic_filter, topicFilter, strlen(topicFilter) + 1);
   2388              } else {
   2389          #ifdef PLATFORM_HAS_DYNMEM
   2390                  handler->topic_filter = mqtt_malloc(MQTT_ZIP_PATH_DEFAULT_LEN);
   2391                  if (NULL == handler->topic_filter) {
   2392                      mqtt_free(handler);
   2393                      return FAIL_RETURN;
   2394                  }
   2395                  memset((char *)handler->topic_filter, 0, MQTT_ZIP_PATH_DEFAULT_LEN);
   2396          #else
   2397                  if (MQTT_ZIP_PATH_DEFAULT_LEN >= CONFIG_MQTT_TOPIC_MAXLEN) {
   2398                      return MQTT_TOPIC_LEN_TOO_SHORT;
   2399                  }
   2400                  memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
   2401          #endif
   2402                  handler->topic_type = TOPIC_NAME_TYPE;
   2403                  if (iotx_mc_get_zip_topic(topicFilter, strlen(topicFilter), (char *)handler->topic_filter,
   2404                                            MQTT_ZIP_PATH_DEFAULT_LEN) != 0) {
   2405          #ifdef PLATFORM_HAS_DYNMEM
   2406                      mqtt_free(handler->topic_filter);
   2407                      mqtt_free(handler);
   2408          #endif
   2409                      return FAIL_RETURN;
   2410                  }
   2411              }
   2412          #endif
   2413          
   2414              HAL_MutexLock(c->lock_write_buf);
   \       0x88   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x8C   0x....'....        BL       HAL_MutexLock
   2415          
   2416              if (_alloc_send_buffer(c, strlen(topicFilter)) < 0) {
   \       0x90   0x4630             MOV      R0,R6
   \       0x92   0x....'....        BL       strlen
   \       0x96   0x4601             MOV      R1,R0
   \       0x98   0x4620             MOV      R0,R4
   \       0x9A   0x....'....        BL       _alloc_send_buffer
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD50E             BPL.N    ??MQTTUnsubscribe_4
   2417                  HAL_MutexUnlock(c->lock_write_buf);
   \       0xA2   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xA6   0x....'....        BL       HAL_MutexUnlock
   2418          #ifdef PLATFORM_HAS_DYNMEM
   2419                  mqtt_free(handler->topic_filter);
   \       0xAA   0x68E8             LDR      R0,[R5, #+12]
   \       0xAC   0x....'....        BL       HAL_Free
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0x60E8             STR      R0,[R5, #+12]
   2420                  mqtt_free(handler);
   \       0xB4   0x4628             MOV      R0,R5
   \       0xB6   0x....'....        BL       HAL_Free
   2421          #endif
   2422                  return FAIL_RETURN;
   \       0xBA   0xF04F 0x30FF      MOV      R0,#-1
   \       0xBE   0xE080             B.N      ??MQTTUnsubscribe_2
   2423              }
   2424          
   2425              if ((len = MQTTSerialize_unsubscribe((unsigned char *)c->buf_send, c->buf_size_send, 0, (unsigned short)msgId, 1,
   2426                                                   &topic)) <= 0) {
   \                     ??MQTTUnsubscribe_4: (+1)
   \       0xC0   0xA806             ADD      R0,SP,#+24
   \       0xC2   0x9001             STR      R0,[SP, #+4]
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0x9000             STR      R0,[SP, #+0]
   \       0xC8   0x463B             MOV      R3,R7
   \       0xCA   0xB29B             UXTH     R3,R3
   \       0xCC   0x2200             MOVS     R2,#+0
   \       0xCE   0x6921             LDR      R1,[R4, #+16]
   \       0xD0   0x6A60             LDR      R0,[R4, #+36]
   \       0xD2   0x....'....        BL       MQTTSerialize_unsubscribe
   \       0xD6   0x2801             CMP      R0,#+1
   \       0xD8   0xDA11             BGE.N    ??MQTTUnsubscribe_5
   2427          #ifdef PLATFORM_HAS_DYNMEM
   2428                  mqtt_free(handler->topic_filter);
   \       0xDA   0x68E8             LDR      R0,[R5, #+12]
   \       0xDC   0x....'....        BL       HAL_Free
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0x60E8             STR      R0,[R5, #+12]
   2429                  mqtt_free(handler);
   \       0xE4   0x4628             MOV      R0,R5
   \       0xE6   0x....'....        BL       HAL_Free
   2430          #endif
   2431                  _reset_send_buffer(c);
   \       0xEA   0x4620             MOV      R0,R4
   \       0xEC   0x....'....        BL       _reset_send_buffer
   2432                  HAL_MutexUnlock(c->lock_write_buf);
   \       0xF0   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xF4   0x....'....        BL       HAL_MutexUnlock
   2433                  return MQTT_UNSUBSCRIBE_PACKET_ERROR;
   \       0xF8   0xF06F 0x0015      MVN      R0,#+21
   \       0xFC   0xE061             B.N      ??MQTTUnsubscribe_2
   2434              }
   2435          
   2436              if ((iotx_mc_send_packet(c, c->buf_send, len, &timer)) != SUCCESS_RETURN) { /* send the subscribe packet */
   \                     ??MQTTUnsubscribe_5: (+1)
   \       0xFE   0xAB02             ADD      R3,SP,#+8
   \      0x100   0x4602             MOV      R2,R0
   \      0x102   0x6A61             LDR      R1,[R4, #+36]
   \      0x104   0x4620             MOV      R0,R4
   \      0x106   0x....'....        BL       iotx_mc_send_packet
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD011             BEQ.N    ??MQTTUnsubscribe_6
   2437          #ifdef PLATFORM_HAS_DYNMEM
   2438                  mqtt_free(handler->topic_filter);
   \      0x10E   0x68E8             LDR      R0,[R5, #+12]
   \      0x110   0x....'....        BL       HAL_Free
   \      0x114   0x2000             MOVS     R0,#+0
   \      0x116   0x60E8             STR      R0,[R5, #+12]
   2439                  mqtt_free(handler);
   \      0x118   0x4628             MOV      R0,R5
   \      0x11A   0x....'....        BL       HAL_Free
   2440          #endif
   2441                  _reset_send_buffer(c);
   \      0x11E   0x4620             MOV      R0,R4
   \      0x120   0x....'....        BL       _reset_send_buffer
   2442                  HAL_MutexUnlock(c->lock_write_buf);
   \      0x124   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x128   0x....'....        BL       HAL_MutexUnlock
   2443                  return MQTT_NETWORK_ERROR;
   \      0x12C   0xF06F 0x000D      MVN      R0,#+13
   \      0x130   0xE047             B.N      ??MQTTUnsubscribe_2
   2444              }
   2445          
   2446              cur_topic.cstring = NULL;
   \                     ??MQTTUnsubscribe_6: (+1)
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0x9003             STR      R0,[SP, #+12]
   2447              cur_topic.lenstring.data = (char *)handler->topic_filter;
   \      0x136   0x68E8             LDR      R0,[R5, #+12]
   \      0x138   0x9005             STR      R0,[SP, #+20]
   2448          
   2449          #if !(WITH_MQTT_ZIP_TOPIC)
   2450              cur_topic.lenstring.len = strlen(handler->topic_filter) + 1;
   \      0x13A   0x68E8             LDR      R0,[R5, #+12]
   \      0x13C   0x....'....        BL       strlen
   \      0x140   0x1C40             ADDS     R0,R0,#+1
   \      0x142   0x9004             STR      R0,[SP, #+16]
   2451          #else
   2452              if (handler->topic_type == TOPIC_FILTER_TYPE) {
   2453                  cur_topic.lenstring.len = strlen(handler->topic_filter) + 1;
   2454              } else {
   2455                  cur_topic.lenstring.len = MQTT_ZIP_PATH_DEFAULT_LEN;
   2456              }
   2457          #endif
   2458              /* we have to find the right message handler - indexed by topic */
   2459              HAL_MutexLock(c->lock_generic);
   \      0x144   0x6820             LDR      R0,[R4, #+0]
   \      0x146   0x....'....        BL       HAL_MutexLock
   2460          #ifdef PLATFORM_HAS_DYNMEM
   2461              list_for_each_entry_safe(node, next, &c->list_sub_handle, linked_list, iotx_mc_topic_handle_t) {
   \      0x14A   0x6B20             LDR      R0,[R4, #+48]
   \      0x14C   0xF1A0 0x0610      SUB      R6,R0,#+16
   \      0x150   0x6970             LDR      R0,[R6, #+20]
   \      0x152   0xF1A0 0x0710      SUB      R7,R0,#+16
   \      0x156   0xE01B             B.N      ??MQTTUnsubscribe_7
   2462                  if (MQTTPacket_equals(&cur_topic, (char *)node->topic_filter)
   2463                      || iotx_mc_is_topic_matched((char *)node->topic_filter, &cur_topic)) {
   \                     ??MQTTUnsubscribe_8: (+1)
   \      0x158   0x68F1             LDR      R1,[R6, #+12]
   \      0x15A   0xA803             ADD      R0,SP,#+12
   \      0x15C   0x....'....        BL       MQTTPacket_equals
   \      0x160   0x2800             CMP      R0,#+0
   \      0x162   0xD105             BNE.N    ??MQTTUnsubscribe_9
   \      0x164   0xA903             ADD      R1,SP,#+12
   \      0x166   0x68F0             LDR      R0,[R6, #+12]
   \      0x168   0x....'....        BL       iotx_mc_is_topic_matched
   \      0x16C   0x2800             CMP      R0,#+0
   \      0x16E   0xD00B             BEQ.N    ??MQTTUnsubscribe_10
   2464                      mqtt_debug("topic be matched");
   2465                      list_del(&node->linked_list);
   \                     ??MQTTUnsubscribe_9: (+1)
   \      0x170   0xF106 0x0010      ADD      R0,R6,#+16
   \      0x174   0x....'....        BL       dlist_del
   2466                      mqtt_free(node->topic_filter);
   \      0x178   0x68F0             LDR      R0,[R6, #+12]
   \      0x17A   0x....'....        BL       HAL_Free
   \      0x17E   0x2000             MOVS     R0,#+0
   \      0x180   0x60F0             STR      R0,[R6, #+12]
   2467                      mqtt_free(node);
   \      0x182   0x4630             MOV      R0,R6
   \      0x184   0x....'....        BL       HAL_Free
   2468                  }
   2469              }
   \                     ??MQTTUnsubscribe_10: (+1)
   \      0x188   0x463E             MOV      R6,R7
   \      0x18A   0x6978             LDR      R0,[R7, #+20]
   \      0x18C   0xF1A0 0x0710      SUB      R7,R0,#+16
   \                     ??MQTTUnsubscribe_7: (+1)
   \      0x190   0xF106 0x0010      ADD      R0,R6,#+16
   \      0x194   0xF104 0x012C      ADD      R1,R4,#+44
   \      0x198   0x4288             CMP      R0,R1
   \      0x19A   0xD1DD             BNE.N    ??MQTTUnsubscribe_8
   2470              mqtt_free(handler->topic_filter);
   \      0x19C   0x68E8             LDR      R0,[R5, #+12]
   \      0x19E   0x....'....        BL       HAL_Free
   \      0x1A2   0x2000             MOVS     R0,#+0
   \      0x1A4   0x60E8             STR      R0,[R5, #+12]
   2471              mqtt_free(handler);
   \      0x1A6   0x4628             MOV      R0,R5
   \      0x1A8   0x....'....        BL       HAL_Free
   2472          #else
   2473              for (idx = 0; idx < IOTX_MC_SUBHANDLE_LIST_MAX_LEN; idx++) {
   2474                  if ((c->list_sub_handle[idx].used == 1) &&
   2475                      (MQTTPacket_equals(&cur_topic, (char *)c->list_sub_handle[idx].topic_filter) ||
   2476                       iotx_mc_is_topic_matched((char *)c->list_sub_handle[idx].topic_filter, &cur_topic))) {
   2477                      mqtt_debug("topic be matched");
   2478                      memset(&c->list_sub_handle[idx], 0, sizeof(iotx_mc_topic_handle_t));
   2479                  }
   2480              }
   2481          #endif
   2482              HAL_MutexUnlock(c->lock_generic);
   \      0x1AC   0x6820             LDR      R0,[R4, #+0]
   \      0x1AE   0x....'....        BL       HAL_MutexUnlock
   2483              _reset_send_buffer(c);
   \      0x1B2   0x4620             MOV      R0,R4
   \      0x1B4   0x....'....        BL       _reset_send_buffer
   2484              HAL_MutexUnlock(c->lock_write_buf);
   \      0x1B8   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x1BC   0x....'....        BL       HAL_MutexUnlock
   2485              return SUCCESS_RETURN;
   \      0x1C0   0x2000             MOVS     R0,#+0
   \                     ??MQTTUnsubscribe_2: (+1)
   \      0x1C2   0xB009             ADD      SP,SP,#+36
   \      0x1C4   0xBDF0             POP      {R4-R7,PC}       ;; return
   2486          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   2487          

   \                                 In section .text, align 2, keep-with-next
   2488          int MQTTPublish(iotx_mc_client_t *c, const char *topicName, iotx_mqtt_topic_info_pt topic_msg)
   2489          
   2490          {
   \                     MQTTPublish: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB08C             SUB      SP,SP,#+48
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4615             MOV      R5,R2
   2491              iotx_time_t         timer;
   2492              MQTTString          topic = MQTTString_initializer;
   \        0xA   0xA809             ADD      R0,SP,#+36
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x460A             MOV      R2,R1
   \       0x10   0x460B             MOV      R3,R1
   \       0x12   0xE880 0x000E      STM      R0,{R1-R3}
   2493              int                 len = 0;
   2494          #if !WITH_MQTT_ONLY_QOS0
   2495              iotx_mc_pub_info_t  *node = NULL;
   \       0x16   0x4608             MOV      R0,R1
   \       0x18   0x9007             STR      R0,[SP, #+28]
   2496          #endif
   2497          #ifdef INFRA_LOG_NETWORK_PAYLOAD
   2498              const char     *json_payload = NULL;
   2499          #endif
   2500          
   2501              if (!c || !topicName || !topic_msg) {
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD003             BEQ.N    ??MQTTPublish_0
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD001             BEQ.N    ??MQTTPublish_0
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD102             BNE.N    ??MQTTPublish_1
   2502                  return FAIL_RETURN;
   \                     ??MQTTPublish_0: (+1)
   \       0x26   0xF04F 0x30FF      MOV      R0,#-1
   \       0x2A   0xE098             B.N      ??MQTTPublish_2
   2503              }
   2504          
   2505              topic.cstring = (char *)topicName;
   \                     ??MQTTPublish_1: (+1)
   \       0x2C   0x9609             STR      R6,[SP, #+36]
   2506              iotx_time_init(&timer);
   \       0x2E   0xA808             ADD      R0,SP,#+32
   \       0x30   0x....'....        BL       iotx_time_init
   2507              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x34   0x68A1             LDR      R1,[R4, #+8]
   \       0x36   0xA808             ADD      R0,SP,#+32
   \       0x38   0x....'....        BL       utils_time_countdown_ms
   2508          
   2509              HAL_MutexLock(c->lock_list_pub);
   \       0x3C   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x40   0x....'....        BL       HAL_MutexLock
   2510              HAL_MutexLock(c->lock_write_buf);
   \       0x44   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x48   0x....'....        BL       HAL_MutexLock
   2511          
   2512              if (_alloc_send_buffer(c, strlen(topicName) + topic_msg->payload_len) < 0) {
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x....'....        BL       strlen
   \       0x52   0x68A9             LDR      R1,[R5, #+8]
   \       0x54   0x1808             ADDS     R0,R1,R0
   \       0x56   0x4601             MOV      R1,R0
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x....'....        BL       _alloc_send_buffer
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD50A             BPL.N    ??MQTTPublish_3
   2513                  HAL_MutexUnlock(c->lock_write_buf);
   \       0x62   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x66   0x....'....        BL       HAL_MutexUnlock
   2514                  HAL_MutexUnlock(c->lock_list_pub);
   \       0x6A   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0x6E   0x....'....        BL       HAL_MutexUnlock
   2515                  return FAIL_RETURN;
   \       0x72   0xF04F 0x30FF      MOV      R0,#-1
   \       0x76   0xE072             B.N      ??MQTTPublish_2
   2516              }
   2517          
   2518              len = MQTTSerialize_publish((unsigned char *)c->buf_send,
   2519                                          c->buf_size_send,
   2520                                          0,
   2521                                          topic_msg->qos,
   2522                                          topic_msg->retain,
   2523                                          topic_msg->packet_id,
   2524                                          topic,
   2525                                          (unsigned char *)topic_msg->payload,
   2526                                          topic_msg->payload_len);
   \                     ??MQTTPublish_3: (+1)
   \       0x78   0x68A8             LDR      R0,[R5, #+8]
   \       0x7A   0x9006             STR      R0,[SP, #+24]
   \       0x7C   0x6928             LDR      R0,[R5, #+16]
   \       0x7E   0x9005             STR      R0,[SP, #+20]
   \       0x80   0xA809             ADD      R0,SP,#+36
   \       0x82   0xAA02             ADD      R2,SP,#+8
   \       0x84   0xC80A             LDM      R0!,{R1,R3}
   \       0x86   0xC20A             STM      R2!,{R1,R3}
   \       0x88   0x6803             LDR      R3,[R0, #+0]
   \       0x8A   0x6013             STR      R3,[R2, #+0]
   \       0x8C   0x8828             LDRH     R0,[R5, #+0]
   \       0x8E   0x9001             STR      R0,[SP, #+4]
   \       0x90   0x7928             LDRB     R0,[R5, #+4]
   \       0x92   0x9000             STR      R0,[SP, #+0]
   \       0x94   0x78AB             LDRB     R3,[R5, #+2]
   \       0x96   0x2200             MOVS     R2,#+0
   \       0x98   0x6921             LDR      R1,[R4, #+16]
   \       0x9A   0x6A60             LDR      R0,[R4, #+36]
   \       0x9C   0x....'....        BL       MQTTSerialize_publish
   \       0xA0   0x4606             MOV      R6,R0
   2527              if (len <= 0) {
   \       0xA2   0x2E01             CMP      R6,#+1
   \       0xA4   0xDA0D             BGE.N    ??MQTTPublish_4
   2528                  mqtt_err("MQTTSerialize_publish is error, len=%d, buf_size_send=%u, payloadlen=%u",
   2529                           len,
   2530                           c->buf_size_send,
   2531                           topic_msg->payload_len);
   2532                  _reset_send_buffer(c);
   \       0xA6   0x4620             MOV      R0,R4
   \       0xA8   0x....'....        BL       _reset_send_buffer
   2533                  HAL_MutexUnlock(c->lock_write_buf);
   \       0xAC   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xB0   0x....'....        BL       HAL_MutexUnlock
   2534                  HAL_MutexUnlock(c->lock_list_pub);
   \       0xB4   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0xB8   0x....'....        BL       HAL_MutexUnlock
   2535                  return MQTT_PUBLISH_PACKET_ERROR;
   \       0xBC   0xF06F 0x0014      MVN      R0,#+20
   \       0xC0   0xE04D             B.N      ??MQTTPublish_2
   2536              }
   2537          
   2538          #if !WITH_MQTT_ONLY_QOS0
   2539              node = NULL;
   \                     ??MQTTPublish_4: (+1)
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x9007             STR      R0,[SP, #+28]
   2540              /* If the QOS >1, push the information into list of wait publish ACK */
   2541              if (topic_msg->qos > IOTX_MQTT_QOS0) {
   \       0xC6   0x78A8             LDRB     R0,[R5, #+2]
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD015             BEQ.N    ??MQTTPublish_5
   2542                  /* push into list */
   2543                  if (SUCCESS_RETURN != iotx_mc_push_pubInfo_to(c, len, topic_msg->packet_id, &node)) {
   \       0xCC   0xAB07             ADD      R3,SP,#+28
   \       0xCE   0x882A             LDRH     R2,[R5, #+0]
   \       0xD0   0x4631             MOV      R1,R6
   \       0xD2   0x4620             MOV      R0,R4
   \       0xD4   0x....'....        BL       iotx_mc_push_pubInfo_to
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD00D             BEQ.N    ??MQTTPublish_5
   2544                      mqtt_err("push publish into to pubInfolist failed!");
   2545                      _reset_send_buffer(c);
   \       0xDC   0x4620             MOV      R0,R4
   \       0xDE   0x....'....        BL       _reset_send_buffer
   2546                      HAL_MutexUnlock(c->lock_write_buf);
   \       0xE2   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0xE6   0x....'....        BL       HAL_MutexUnlock
   2547                      HAL_MutexUnlock(c->lock_list_pub);
   \       0xEA   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \       0xEE   0x....'....        BL       HAL_MutexUnlock
   2548                      return MQTT_PUSH_TO_LIST_ERROR;
   \       0xF2   0xF06F 0x0029      MVN      R0,#+41
   \       0xF6   0xE032             B.N      ??MQTTPublish_2
   2549                  }
   2550              }
   2551          #endif
   2552              /* send the publish packet */
   2553              if (iotx_mc_send_packet(c, c->buf_send, len, &timer) != SUCCESS_RETURN) {
   \                     ??MQTTPublish_5: (+1)
   \       0xF8   0xAB08             ADD      R3,SP,#+32
   \       0xFA   0x4632             MOV      R2,R6
   \       0xFC   0x6A61             LDR      R1,[R4, #+36]
   \       0xFE   0x4620             MOV      R0,R4
   \      0x100   0x....'....        BL       iotx_mc_send_packet
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD019             BEQ.N    ??MQTTPublish_6
   2554          #if !WITH_MQTT_ONLY_QOS0
   2555                  if (topic_msg->qos > IOTX_MQTT_QOS0) {
   \      0x108   0x78A8             LDRB     R0,[R5, #+2]
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD008             BEQ.N    ??MQTTPublish_7
   2556                      /* If not even successfully sent to IP stack, meaningless to wait QOS1 ack, give up waiting */
   2557          #ifdef PLATFORM_HAS_DYNMEM
   2558                      list_del(&node->linked_list);
   \      0x10E   0x9807             LDR      R0,[SP, #+28]
   \      0x110   0x3010             ADDS     R0,R0,#+16
   \      0x112   0x....'....        BL       dlist_del
   2559                      mqtt_free(node);
   \      0x116   0x9807             LDR      R0,[SP, #+28]
   \      0x118   0x....'....        BL       HAL_Free
   \      0x11C   0x2000             MOVS     R0,#+0
   \      0x11E   0x9007             STR      R0,[SP, #+28]
   2560          #else
   2561                      memset(node, 0, sizeof(iotx_mc_pub_info_t));
   2562          #endif
   2563                  }
   2564          #endif
   2565                  _reset_send_buffer(c);
   \                     ??MQTTPublish_7: (+1)
   \      0x120   0x4620             MOV      R0,R4
   \      0x122   0x....'....        BL       _reset_send_buffer
   2566                  HAL_MutexUnlock(c->lock_write_buf);
   \      0x126   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x12A   0x....'....        BL       HAL_MutexUnlock
   2567                  HAL_MutexUnlock(c->lock_list_pub);
   \      0x12E   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \      0x132   0x....'....        BL       HAL_MutexUnlock
   2568                  return MQTT_NETWORK_ERROR;
   \      0x136   0xF06F 0x000D      MVN      R0,#+13
   \      0x13A   0xE010             B.N      ??MQTTPublish_2
   2569              }
   2570          
   2571          #ifdef INFRA_LOG_NETWORK_PAYLOAD
   2572              json_payload = (const char *)topic_msg->payload;
   2573          
   2574              mqtt_info("Upstream Topic: '%s'", topicName);
   2575              mqtt_info("Upstream Payload:");
   2576              iotx_facility_json_print(json_payload, LOG_INFO_LEVEL, '>');
   \                     ??MQTTPublish_6: (+1)
   \      0x13C   0x223E             MOVS     R2,#+62
   \      0x13E   0x2104             MOVS     R1,#+4
   \      0x140   0x6928             LDR      R0,[R5, #+16]
   \      0x142   0x....'....        BL       iotx_facility_json_print
   2577          
   2578          #endif  /* #ifdef INFRA_LOG */
   2579          
   2580              _reset_send_buffer(c);
   \      0x146   0x4620             MOV      R0,R4
   \      0x148   0x....'....        BL       _reset_send_buffer
   2581              HAL_MutexUnlock(c->lock_write_buf);
   \      0x14C   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \      0x150   0x....'....        BL       HAL_MutexUnlock
   2582              HAL_MutexUnlock(c->lock_list_pub);
   \      0x154   0xF8D4 0x00D0      LDR      R0,[R4, #+208]
   \      0x158   0x....'....        BL       HAL_MutexUnlock
   2583          
   2584              return SUCCESS_RETURN;
   \      0x15C   0x2000             MOVS     R0,#+0
   \                     ??MQTTPublish_2: (+1)
   \      0x15E   0xB00C             ADD      SP,SP,#+48
   \      0x160   0xBD70             POP      {R4-R6,PC}       ;; return
   2585          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0H, 0, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   2586          

   \                                 In section .text, align 2, keep-with-next
   2587          static int MQTTDisconnect(iotx_mc_client_t *c)
   2588          {
   \                     MQTTDisconnect: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   2589              int             rc = FAIL_RETURN;
   \        0x4   0xF04F 0x35FF      MOV      R5,#-1
   2590              int             len = 0;
   2591              iotx_time_t     timer;     /* we might wait for incomplete incoming publishes to complete */
   2592          
   2593              if (!c) {
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??MQTTDisconnect_0
   2594                  return FAIL_RETURN;
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0xBD76             POP      {R1,R2,R4-R6,PC}
   2595              }
   2596          
   2597              HAL_MutexLock(c->lock_write_buf);
   \                     ??MQTTDisconnect_0: (+1)
   \       0x10   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x14   0x....'....        BL       HAL_MutexLock
   2598          
   2599              if (_alloc_send_buffer(c, 0) < 0) {
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x....'....        BL       _alloc_send_buffer
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD505             BPL.N    ??MQTTDisconnect_1
   2600                  HAL_MutexUnlock(c->lock_write_buf);
   \       0x24   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x28   0x....'....        BL       HAL_MutexUnlock
   2601                  return FAIL_RETURN;
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0xBD76             POP      {R1,R2,R4-R6,PC}
   2602              }
   2603          
   2604              len = MQTTSerialize_disconnect((unsigned char *)c->buf_send, c->buf_size_send);
   \                     ??MQTTDisconnect_1: (+1)
   \       0x30   0x6921             LDR      R1,[R4, #+16]
   \       0x32   0x6A60             LDR      R0,[R4, #+36]
   \       0x34   0x....'....        BL       MQTTSerialize_disconnect
   \       0x38   0x4606             MOV      R6,R0
   2605          
   2606              iotx_time_init(&timer);
   \       0x3A   0x4668             MOV      R0,SP
   \       0x3C   0x....'....        BL       iotx_time_init
   2607              utils_time_countdown_ms(&timer, c->request_timeout_ms);
   \       0x40   0x68A1             LDR      R1,[R4, #+8]
   \       0x42   0x4668             MOV      R0,SP
   \       0x44   0x....'....        BL       utils_time_countdown_ms
   2608          
   2609              if (len > 0) {
   \       0x48   0x2E01             CMP      R6,#+1
   \       0x4A   0xDB06             BLT.N    ??MQTTDisconnect_2
   2610                  rc = iotx_mc_send_packet(c, c->buf_send, len, &timer);           /* send the disconnect packet */
   \       0x4C   0x466B             MOV      R3,SP
   \       0x4E   0x4632             MOV      R2,R6
   \       0x50   0x6A61             LDR      R1,[R4, #+36]
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x....'....        BL       iotx_mc_send_packet
   \       0x58   0x4605             MOV      R5,R0
   2611              }
   2612              _reset_send_buffer(c);
   \                     ??MQTTDisconnect_2: (+1)
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0x....'....        BL       _reset_send_buffer
   2613              HAL_MutexUnlock(c->lock_write_buf);
   \       0x60   0xF8D4 0x00D4      LDR      R0,[R4, #+212]
   \       0x64   0x....'....        BL       HAL_MutexUnlock
   2614              return rc;
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   2615          }
   2616          

   \                                 In section .text, align 2, keep-with-next
   2617          static int iotx_mc_disconnect(iotx_mc_client_t *pClient)
   2618          {
   \                     iotx_mc_disconnect: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2619              int             rc = -1;
   2620          
   2621              if (NULL == pClient) {
   \        0x4   0xD102             BNE.N    ??iotx_mc_disconnect_0
   2622                  return NULL_VALUE_ERROR;
   \        0x6   0xF06F 0x0001      MVN      R0,#+1
   \        0xA   0xBD10             POP      {R4,PC}
   2623              }
   2624          
   2625              if (wrapper_mqtt_check_state(pClient)) {
   \                     ??iotx_mc_disconnect_0: (+1)
   \        0xC   0x....'....        BL       wrapper_mqtt_check_state
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD002             BEQ.N    ??iotx_mc_disconnect_1
   2626                  rc = MQTTDisconnect(pClient);
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       MQTTDisconnect
   2627                  mqtt_debug("rc = MQTTDisconnect() = %d", rc);
   2628                  rc = rc;
   2629              }
   2630          
   2631              /* close tcp/ip socket or free tls resources */
   2632              pClient->ipstack.disconnect(&pClient->ipstack);
   \                     ??iotx_mc_disconnect_1: (+1)
   \       0x1A   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x1E   0x6D21             LDR      R1,[R4, #+80]
   \       0x20   0x4788             BLX      R1
   2633          
   2634              iotx_mc_set_client_state(pClient, IOTX_MC_STATE_INITIALIZED);
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       iotx_mc_set_client_state
   2635          
   2636              mqtt_info("mqtt disconnect!");
   2637              return SUCCESS_RETURN;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
   2638          }
   2639          
   2640          /************************  Public Interface ************************/

   \                                 In section .text, align 2, keep-with-next
   2641          void *wrapper_mqtt_init(iotx_mqtt_param_t *mqtt_params)
   2642          {
   \                     wrapper_mqtt_init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   2643              int err;
   2644              iotx_mc_client_t *pclient = NULL;
   2645          #ifndef PLATFORM_HAS_DYNMEM
   2646              int idx;
   2647          #endif
   2648          
   2649          #ifdef PLATFORM_HAS_DYNMEM
   2650              pclient = (iotx_mc_client_t *)mqtt_malloc(sizeof(iotx_mc_client_t));
   \        0x4   0x20E8             MOVS     R0,#+232
   \        0x6   0x....'....        BL       HAL_Malloc
   \        0xA   0x0004             MOVS     R4,R0
   2651              if (NULL == pclient) {
   \        0xC   0xD101             BNE.N    ??wrapper_mqtt_init_0
   2652                  mqtt_err("not enough memory.");
   2653                  return NULL;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
   2654              }
   2655              memset(pclient, 0, sizeof(iotx_mc_client_t));
   \                     ??wrapper_mqtt_init_0: (+1)
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x21E8             MOVS     R1,#+232
   \       0x16   0x....'....        BL       __aeabi_memset4
   2656          #else
   2657              for (idx = 0; idx < IOTX_MC_CLIENT_MAX_COUNT; idx++) {
   2658                  if (g_iotx_mc_client[idx].used == 0) {
   2659                      g_iotx_mc_client[idx].used = 1;
   2660                      pclient = &g_iotx_mc_client[idx];
   2661                      break;
   2662                  }
   2663              }
   2664          
   2665              if (NULL == pclient) {
   2666                  mqtt_err("IOTX_MC_CLIENT_MAX_COUNT too short: %d", IOTX_MC_CLIENT_MAX_COUNT);
   2667                  return NULL;
   2668              }
   2669          #endif
   2670          
   2671              err = iotx_mc_init(pclient, mqtt_params);
   2672          
   2673              if (SUCCESS_RETURN != err) {
   \       0x1A   0x4629             MOV      R1,R5
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       iotx_mc_init
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0xD002             BEQ.N    ??wrapper_mqtt_init_1
   2674                  mqtt_err("iotx_mc_init failed");
   2675                  iotx_mc_release(pclient);
   \       0x28   0x....'....        BL       iotx_mc_release
   2676                  return NULL;
   \       0x2C   0x2000             MOVS     R0,#+0
   2677              }
   2678          
   2679              return pclient;
   \                     ??wrapper_mqtt_init_1: (+1)
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2680          }
   2681          

   \                                 In section .text, align 2, keep-with-next
   2682          int wrapper_mqtt_connect(void *client)
   2683          {
   \                     wrapper_mqtt_connect: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   2684              int rc = FAIL_RETURN;
   2685              int retry_max = 3;
   2686              int retry_cnt = 1;
   \        0x4   0x2601             MOVS     R6,#+1
   2687              int retry_interval = 1000;
   2688              iotx_mc_client_t *pClient = (iotx_mc_client_t *)client;
   2689          
   2690              if (NULL == pClient) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD10C             BNE.N    ??wrapper_mqtt_connect_0
   2691                  return NULL_VALUE_ERROR;
   \        0xA   0xF06F 0x0001      MVN      R0,#+1
   \        0xE   0xBD70             POP      {R4-R6,PC}
   2692              }
   2693          
   2694              /* Establish TCP or TLS connection */
   2695              do {
   2696                  mqtt_debug("calling TCP or TLS connect HAL for [%d/%d] iteration", retry_cnt, retry_max);
   2697          
   2698                  rc = pClient->ipstack.connect(&pClient->ipstack);
   2699                  if (SUCCESS_RETURN != rc) {
   2700                      pClient->ipstack.disconnect(&pClient->ipstack);
   2701                      mqtt_err("TCP or TLS Connection failed");
   2702          
   2703                      if (ERROR_CERTIFICATE_EXPIRED == rc) {
   2704                          mqtt_err("certificate is expired! rc = %d", rc);
   2705                          rc = ERROR_CERT_VERIFY_FAIL;
   2706                          HAL_SleepMs(retry_interval);
   2707                          continue;
   2708                      } else {
   2709                          rc = MQTT_NETWORK_CONNECT_ERROR;
   2710                          HAL_SleepMs(retry_interval);
   \                     ??wrapper_mqtt_connect_1: (+1)
   \       0x10   0x....'....        BL       HAL_SleepMs
   2711                          continue;
   2712                      }
   2713                  } else {
   2714                      mqtt_debug("rc = pClient->ipstack.connect() = %d, success @ [%d/%d] iteration", rc, retry_cnt, retry_max);
   2715                      break;
   2716                  }
   2717              } while (++retry_cnt <= retry_max);
   \                     ??wrapper_mqtt_connect_2: (+1)
   \       0x14   0x1C76             ADDS     R6,R6,#+1
   \       0x16   0x2E04             CMP      R6,#+4
   \       0x18   0xDB04             BLT.N    ??wrapper_mqtt_connect_0
   2718          
   2719          #ifdef ASYNC_PROTOCOL_STACK
   2720              iotx_mc_set_client_state(pClient, IOTX_MC_STATE_CONNECT_BLOCK);
   2721              rc = MQTT_CONNECT_BLOCK;
   2722          #else
   2723              rc = _mqtt_connect(pClient);
   2724          #endif
   2725              return rc;
   \                     ??wrapper_mqtt_connect_3: (+1)
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x20   0x....'....        B.W      _mqtt_connect
   \                     ??wrapper_mqtt_connect_0: (+1)
   \       0x24   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x28   0x6D69             LDR      R1,[R5, #+84]
   \       0x2A   0x4788             BLX      R1
   \       0x2C   0x0004             MOVS     R4,R0
   \       0x2E   0xD0F4             BEQ.N    ??wrapper_mqtt_connect_3
   \       0x30   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x34   0x6D29             LDR      R1,[R5, #+80]
   \       0x36   0x4788             BLX      R1
   \       0x38   0x....             LDR.N    R0,??DataTable8_1  ;; 0xfffffc09
   \       0x3A   0x4284             CMP      R4,R0
   \       0x3C   0xF44F 0x707A      MOV      R0,#+1000
   \       0x40   0xD1E6             BNE.N    ??wrapper_mqtt_connect_1
   \       0x42   0x....'....        BL       HAL_SleepMs
   \       0x46   0xE7E5             B.N      ??wrapper_mqtt_connect_2
   2726          }
   2727          

   \                                 In section .text, align 2, keep-with-next
   2728          int wrapper_mqtt_release(void **c)
   2729          {
   \                     wrapper_mqtt_release: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2730              iotx_mc_client_t *pClient;
   2731          #ifdef PLATFORM_HAS_DYNMEM
   2732              iotx_mc_topic_handle_t *node = NULL, *next = NULL;
   2733          #endif
   2734              if (NULL == c) {
   \        0x4   0xD002             BEQ.N    ??wrapper_mqtt_release_0
   2735                  return NULL_VALUE_ERROR;
   2736              }
   2737          
   2738              pClient = (iotx_mc_client_t *)*c;
   \        0x6   0x6825             LDR      R5,[R4, #+0]
   2739              if (NULL == pClient) {
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD102             BNE.N    ??wrapper_mqtt_release_1
   2740                  return NULL_VALUE_ERROR;
   \                     ??wrapper_mqtt_release_0: (+1)
   \        0xC   0xF06F 0x0001      MVN      R0,#+1
   \       0x10   0xBDF2             POP      {R1,R4-R7,PC}
   2741              }
   2742              /* iotx_delete_thread(pClient); */
   2743              HAL_SleepMs(100);
   \                     ??wrapper_mqtt_release_1: (+1)
   \       0x12   0x2064             MOVS     R0,#+100
   \       0x14   0x....'....        BL       HAL_SleepMs
   2744          
   2745              iotx_mc_disconnect(pClient);
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0x....'....        BL       iotx_mc_disconnect
   2746              iotx_mc_set_client_state(pClient, IOTX_MC_STATE_INVALID);
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0x....'....        BL       iotx_mc_set_client_state
   2747              HAL_SleepMs(100);
   \       0x26   0x2064             MOVS     R0,#+100
   \       0x28   0x....'....        BL       HAL_SleepMs
   2748          
   2749          #ifdef PLATFORM_HAS_DYNMEM
   2750              list_for_each_entry_safe(node, next, &pClient->list_sub_handle, linked_list, iotx_mc_topic_handle_t) {
   \       0x2C   0x6B28             LDR      R0,[R5, #+48]
   \       0x2E   0xF1A0 0x0610      SUB      R6,R0,#+16
   \       0x32   0x6970             LDR      R0,[R6, #+20]
   \       0x34   0xF1A0 0x0710      SUB      R7,R0,#+16
   \       0x38   0xE00D             B.N      ??wrapper_mqtt_release_2
   2751                  list_del(&node->linked_list);
   \                     ??wrapper_mqtt_release_3: (+1)
   \       0x3A   0x....'....        BL       dlist_del
   2752                  mqtt_free(node->topic_filter);
   \       0x3E   0x68F0             LDR      R0,[R6, #+12]
   \       0x40   0x....'....        BL       HAL_Free
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x60F0             STR      R0,[R6, #+12]
   2753                  mqtt_free(node);
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0x....'....        BL       HAL_Free
   2754              }
   \       0x4E   0x463E             MOV      R6,R7
   \       0x50   0x6978             LDR      R0,[R7, #+20]
   \       0x52   0xF1A0 0x0710      SUB      R7,R0,#+16
   \                     ??wrapper_mqtt_release_2: (+1)
   \       0x56   0xF106 0x0010      ADD      R0,R6,#+16
   \       0x5A   0xF105 0x012C      ADD      R1,R5,#+44
   \       0x5E   0x4288             CMP      R0,R1
   \       0x60   0xD1EB             BNE.N    ??wrapper_mqtt_release_3
   2755          #else
   2756              memset(pClient->list_sub_handle, 0, sizeof(iotx_mc_topic_handle_t) * IOTX_MC_SUBHANDLE_LIST_MAX_LEN);
   2757          #endif
   2758              HAL_MutexDestroy(pClient->lock_generic);
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x....'....        BL       HAL_MutexDestroy
   2759              HAL_MutexDestroy(pClient->lock_list_pub);
   \       0x68   0xF8D5 0x00D0      LDR      R0,[R5, #+208]
   \       0x6C   0x....'....        BL       HAL_MutexDestroy
   2760              HAL_MutexDestroy(pClient->lock_write_buf);
   \       0x70   0xF8D5 0x00D4      LDR      R0,[R5, #+212]
   \       0x74   0x....'....        BL       HAL_MutexDestroy
   2761              HAL_MutexDestroy(pClient->lock_yield);
   \       0x78   0xF8D5 0x00DC      LDR      R0,[R5, #+220]
   \       0x7C   0x....'....        BL       HAL_MutexDestroy
   2762              HAL_MutexDestroy(pClient->lock_read_buf);
   \       0x80   0xF8D5 0x00D8      LDR      R0,[R5, #+216]
   \       0x84   0x....'....        BL       HAL_MutexDestroy
   2763          
   2764          #if !WITH_MQTT_ONLY_QOS0
   2765              iotx_mc_pub_wait_list_deinit(pClient);
   \       0x88   0x4628             MOV      R0,R5
   \       0x8A   0x....'....        BL       iotx_mc_pub_wait_list_deinit
   2766          #endif
   2767          #ifdef PLATFORM_HAS_DYNMEM
   2768              if (pClient->buf_send != NULL) {
   \       0x8E   0x6A68             LDR      R0,[R5, #+36]
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD003             BEQ.N    ??wrapper_mqtt_release_4
   2769                  mqtt_free(pClient->buf_send);
   \       0x94   0x....'....        BL       HAL_Free
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x6268             STR      R0,[R5, #+36]
   2770                  pClient->buf_send = NULL;
   2771              }
   2772              if (pClient->buf_read != NULL) {
   \                     ??wrapper_mqtt_release_4: (+1)
   \       0x9C   0x6AA8             LDR      R0,[R5, #+40]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD003             BEQ.N    ??wrapper_mqtt_release_5
   2773                  mqtt_free(pClient->buf_read);
   \       0xA2   0x....'....        BL       HAL_Free
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x62A8             STR      R0,[R5, #+40]
   2774                  pClient->buf_read = NULL;
   2775              }
   2776              mqtt_free(pClient);
   \                     ??wrapper_mqtt_release_5: (+1)
   \       0xAA   0x4628             MOV      R0,R5
   \       0xAC   0x....'....        BL       HAL_Free
   2777          #else
   2778              memset(pClient, 0, sizeof(iotx_mc_client_t));
   2779          #endif
   2780              *c = NULL;
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0x6020             STR      R0,[R4, #+0]
   2781              mqtt_info("mqtt release!");
   2782              return SUCCESS_RETURN;
   \       0xB4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2783          }
   2784          

   \                                 In section .text, align 2, keep-with-next
   2785          int wrapper_mqtt_yield(void *client, int timeout_ms)
   2786          {
   \                     wrapper_mqtt_yield: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   2787              iotx_mc_client_t *pClient = (iotx_mc_client_t *)client;
   2788          
   2789              if (pClient == NULL) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD102             BNE.N    ??wrapper_mqtt_yield_0
   2790                  return NULL_VALUE_ERROR;
   \        0xA   0xF06F 0x0001      MVN      R0,#+1
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
   2791              }
   2792          
   2793              if (timeout_ms < 0) {
   \                     ??wrapper_mqtt_yield_0: (+1)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD502             BPL.N    ??wrapper_mqtt_yield_1
   2794                  mqtt_err("Invalid argument, timeout_ms = %d", timeout_ms);
   2795                  return -1;
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xBD32             POP      {R1,R4,R5,PC}
   2796              }
   2797              if (timeout_ms == 0) {
   \                     ??wrapper_mqtt_yield_1: (+1)
   \       0x1A   0xD100             BNE.N    ??wrapper_mqtt_yield_2
   2798                  timeout_ms = 10;
   \       0x1C   0x240A             MOVS     R4,#+10
   2799              }
   2800          
   2801              HAL_MutexLock(pClient->lock_yield);
   \                     ??wrapper_mqtt_yield_2: (+1)
   \       0x1E   0xF8D5 0x00DC      LDR      R0,[R5, #+220]
   \       0x22   0x....'....        BL       HAL_MutexLock
   2802              pClient->cycle_timeout_ms = timeout_ms;
   \       0x26   0x60EC             STR      R4,[R5, #+12]
   2803              /* Keep MQTT alive or reconnect if connection abort */
   2804              iotx_mc_keepalive(pClient);
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       iotx_mc_keepalive
   2805              HAL_MutexUnlock(pClient->lock_yield);
   \       0x2E   0xF8D5 0x00DC      LDR      R0,[R5, #+220]
   \       0x32   0x....'....        BL       HAL_MutexUnlock
   2806          
   2807          #ifndef ASYNC_PROTOCOL_STACK
   2808              _mqtt_cycle(client);
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x....'....        BL       _mqtt_cycle
   2809          #else
   2810              if (pClient->client_state == IOTX_MC_STATE_CONNECTED) {
   2811          #if !WITH_MQTT_ONLY_QOS0
   2812                  /* check list of wait publish ACK to remove node that is ACKED or timeout */
   2813                  MQTTPubInfoProc(pClient);
   2814          #endif
   2815              }
   2816              HAL_SleepMs(timeout_ms);
   2817          #endif
   2818          
   2819              return 0;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2820          }
   2821          
   2822          
   2823          /* check MQTT client is in normal state */
   2824          /* 0, in abnormal state; 1, in normal state */

   \                                 In section .text, align 2, keep-with-next
   2825          int wrapper_mqtt_check_state(void *client)
   2826          {
   \                     wrapper_mqtt_check_state: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2827              if (!client) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??wrapper_mqtt_check_state_0
   2828                  return 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}
   2829              }
   2830          
   2831              if (iotx_mc_get_client_state((iotx_mc_client_t *)client) == IOTX_MC_STATE_CONNECTED) {
   \                     ??wrapper_mqtt_check_state_0: (+1)
   \        0xA   0x....'....        BL       iotx_mc_get_client_state
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE.N    ??wrapper_mqtt_check_state_1
   2832                  return 1;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xBD02             POP      {R1,PC}
   2833              }
   2834          
   2835              return 0;
   \                     ??wrapper_mqtt_check_state_1: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xBD02             POP      {R1,PC}          ;; return
   2836          }
   2837          

   \                                 In section .text, align 2, keep-with-next
   2838          int wrapper_mqtt_subscribe(void *client,
   2839                                     const char *topicFilter,
   2840                                     iotx_mqtt_qos_t qos,
   2841                                     iotx_mqtt_event_handle_func_fpt topic_handle_func,
   2842                                     void *pcontext)
   2843          {
   \                     wrapper_mqtt_subscribe: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
   2844              int rc = FAIL_RETURN;
   2845              unsigned int msgId;
   2846              iotx_mc_client_t *c;
   2847          
   2848              if (NULL == client || NULL == topicFilter || strlen(topicFilter) == 0 || !topic_handle_func) {
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD008             BEQ.N    ??wrapper_mqtt_subscribe_0
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD006             BEQ.N    ??wrapper_mqtt_subscribe_0
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       strlen
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??wrapper_mqtt_subscribe_0
   \       0x1E   0x0038             MOVS     R0,R7
   \       0x20   0xD102             BNE.N    ??wrapper_mqtt_subscribe_1
   2849                  mqtt_err(" paras error");
   2850                  return NULL_VALUE_ERROR;
   \                     ??wrapper_mqtt_subscribe_0: (+1)
   \       0x22   0xF06F 0x0001      MVN      R0,#+1
   \       0x26   0xE029             B.N      ??wrapper_mqtt_subscribe_2
   2851              }
   2852          
   2853              c = (iotx_mc_client_t *)client;
   2854          
   2855              msgId = iotx_mc_get_next_packetid(c);
   \                     ??wrapper_mqtt_subscribe_1: (+1)
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       iotx_mc_get_next_packetid
   \       0x2E   0x4680             MOV      R8,R0
   2856          
   2857              if (!wrapper_mqtt_check_state(c)) {
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x....'....        BL       wrapper_mqtt_check_state
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD102             BNE.N    ??wrapper_mqtt_subscribe_3
   2858                  mqtt_err("mqtt client state is error,state = %d", iotx_mc_get_client_state(c));
   2859                  return MQTT_STATE_ERROR;
   \       0x3A   0xF06F 0x001A      MVN      R0,#+26
   \       0x3E   0xE01D             B.N      ??wrapper_mqtt_subscribe_2
   2860              }
   2861          
   2862              if (0 != iotx_mc_check_topic(topicFilter, TOPIC_FILTER_TYPE)) {
   \                     ??wrapper_mqtt_subscribe_3: (+1)
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0x....'....        BL       iotx_mc_check_topic
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD002             BEQ.N    ??wrapper_mqtt_subscribe_4
   2863                  mqtt_err("topic format is error,topicFilter = %s", topicFilter);
   2864                  return MQTT_TOPIC_FORMAT_ERROR;
   \       0x4C   0xF06F 0x0028      MVN      R0,#+40
   \       0x50   0xE014             B.N      ??wrapper_mqtt_subscribe_2
   2865              }
   \                     ??wrapper_mqtt_subscribe_4: (+1)
   \       0x52   0x9808             LDR      R0,[SP, #+32]
   2866          
   2867              mqtt_debug("PERFORM subscribe to '%s' (msgId=%d)", topicFilter, msgId);
   2868              rc = MQTTSubscribe(c, topicFilter, qos, msgId, topic_handle_func, pcontext);
   \       0x54   0x9001             STR      R0,[SP, #+4]
   \       0x56   0x9700             STR      R7,[SP, #+0]
   \       0x58   0x4643             MOV      R3,R8
   \       0x5A   0x4632             MOV      R2,R6
   \       0x5C   0x4621             MOV      R1,R4
   \       0x5E   0x4628             MOV      R0,R5
   \       0x60   0x....'....        BL       MQTTSubscribe
   \       0x64   0x0004             MOVS     R4,R0
   2869              if (rc != SUCCESS_RETURN) {
   \       0x66   0xD008             BEQ.N    ??wrapper_mqtt_subscribe_5
   2870                  if (rc == MQTT_NETWORK_ERROR) {
   \       0x68   0xF114 0x0F0E      CMN      R4,#+14
   \       0x6C   0xD103             BNE.N    ??wrapper_mqtt_subscribe_6
   2871                      iotx_mc_set_client_state(c, IOTX_MC_STATE_DISCONNECTED);
   \       0x6E   0x2103             MOVS     R1,#+3
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x....'....        BL       iotx_mc_set_client_state
   2872                  }
   2873          
   2874                  mqtt_err("run MQTTSubscribe error, rc = %d", rc);
   2875                  return rc;
   \                     ??wrapper_mqtt_subscribe_6: (+1)
   \       0x76   0x4620             MOV      R0,R4
   \       0x78   0xE000             B.N      ??wrapper_mqtt_subscribe_2
   2876              }
   2877          
   2878              mqtt_info("mqtt subscribe packet sent,topic = %s!", topicFilter);
   2879              return msgId;
   \                     ??wrapper_mqtt_subscribe_5: (+1)
   \       0x7A   0x4640             MOV      R0,R8
   \                     ??wrapper_mqtt_subscribe_2: (+1)
   \       0x7C   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2880          }
   2881          

   \                                 In section .text, align 2, keep-with-next
   2882          int wrapper_mqtt_subscribe_sync(void *c,
   2883                                          const char *topic_filter,
   2884                                          iotx_mqtt_qos_t qos,
   2885                                          iotx_mqtt_event_handle_func_fpt topic_handle_func,
   2886                                          void *pcontext,
   2887                                          int timeout_ms)
   2888          {
   \                     wrapper_mqtt_subscribe_sync: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4692             MOV      R10,R2
   \        0xA   0x4698             MOV      R8,R3
   2889              int             subed;
   2890              int             ret;
   2891              iotx_time_t     timer;
   2892              iotx_mc_client_t *client = (iotx_mc_client_t *)c;
   2893              int cnt = 0;
   2894              mqtt_sub_sync_node_t *node = NULL;
   2895          #ifdef PLATFORM_HAS_DYNMEM
   2896              mqtt_sub_sync_node_t *next = NULL;
   2897          #else
   2898              int idx = 0;
   2899          #endif
   2900              if (client == NULL) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD102             BNE.N    ??wrapper_mqtt_subscribe_sync_0
   2901                  return NULL_VALUE_ERROR;
   \       0x10   0xF06F 0x0001      MVN      R0,#+1
   \       0x14   0xE097             B.N      ??wrapper_mqtt_subscribe_sync_1
   2902              }
   2903          
   2904          #ifdef SUB_PERSISTENCE_ENABLED
   2905              if (qos > IOTX_MQTT_QOS3_SUB_LOCAL) {
   2906                  mqtt_warning("Invalid qos(%d) out of [%d, %d], using %d",
   2907                               qos,
   2908                               IOTX_MQTT_QOS0, IOTX_MQTT_QOS3_SUB_LOCAL, IOTX_MQTT_QOS0);
   2909                  qos = IOTX_MQTT_QOS0;
   2910              }
   2911          #else
   2912              if (qos > IOTX_MQTT_QOS2) {
   \                     ??wrapper_mqtt_subscribe_sync_0: (+1)
   \       0x16   0x4650             MOV      R0,R10
   \       0x18   0x2803             CMP      R0,#+3
   \       0x1A   0xDB01             BLT.N    ??wrapper_mqtt_subscribe_sync_2
   2913                  mqtt_warning("Invalid qos(%d) out of [%d, %d], using %d",
   2914                               qos,
   2915                               IOTX_MQTT_QOS0, IOTX_MQTT_QOS2, IOTX_MQTT_QOS0);
   2916                  qos = IOTX_MQTT_QOS0;
   \       0x1C   0xF04F 0x0A00      MOV      R10,#+0
   \                     ??wrapper_mqtt_subscribe_sync_2: (+1)
   \       0x20   0x9C0D             LDR      R4,[SP, #+52]
   2917              }
   2918          #endif
   2919          
   2920              iotx_time_init(&timer);
   \       0x22   0xA801             ADD      R0,SP,#+4
   \       0x24   0x....'....        BL       iotx_time_init
   2921              utils_time_countdown_ms(&timer, timeout_ms);
   \       0x28   0x4621             MOV      R1,R4
   \       0x2A   0xA801             ADD      R0,SP,#+4
   \       0x2C   0x....'....        BL       utils_time_countdown_ms
   2922          
   2923              ret = -1;
   \       0x30   0xF04F 0x39FF      MOV      R9,#-1
   \       0x34   0x464F             MOV      R7,R9
   2924              subed = 0;
   \       0x36   0x2400             MOVS     R4,#+0
   \       0x38   0xF8DD 0xB030      LDR      R11,[SP, #+48]
   2925              cnt = 0;
   2926              cnt = cnt;
   \       0x3C   0x9502             STR      R5,[SP, #+8]
   2927              do {
   2928          #ifdef PLATFORM_HAS_DYNMEM
   2929                  mqtt_sub_sync_node_t *node = NULL;
   2930                  mqtt_sub_sync_node_t *next = NULL;
   2931          #else
   2932                  int idx = 0;
   2933          #endif
   2934                  if (ret < 0) {
   \                     ??wrapper_mqtt_subscribe_sync_3: (+1)
   \       0x3E   0x2F00             CMP      R7,#+0
   \       0x40   0xD50F             BPL.N    ??wrapper_mqtt_subscribe_sync_4
   2935                      ret = wrapper_mqtt_subscribe(client, topic_filter, qos, topic_handle_func, pcontext);
   \       0x42   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \       0x46   0x4643             MOV      R3,R8
   \       0x48   0x4652             MOV      R2,R10
   \       0x4A   0x9902             LDR      R1,[SP, #+8]
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x....'....        BL       wrapper_mqtt_subscribe
   \       0x52   0x4607             MOV      R7,R0
   2936                      if (_is_in_yield_cb() != 0 || qos == IOTX_MQTT_QOS3_SUB_LOCAL) {
   \       0x54   0x....'....        BL       _is_in_yield_cb
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD176             BNE.N    ??wrapper_mqtt_subscribe_sync_5
   \       0x5C   0x4650             MOV      R0,R10
   \       0x5E   0x2803             CMP      R0,#+3
   \       0x60   0xD073             BEQ.N    ??wrapper_mqtt_subscribe_sync_5
   2937                          return ret;
   2938                      }
   2939                  }
   2940          
   2941                  if (!subed && ret >= 0) {
   \                     ??wrapper_mqtt_subscribe_sync_4: (+1)
   \       0x62   0x2C00             CMP      R4,#+0
   \       0x64   0xD116             BNE.N    ??wrapper_mqtt_subscribe_sync_6
   \       0x66   0x2F00             CMP      R7,#+0
   \       0x68   0xD414             BMI.N    ??wrapper_mqtt_subscribe_sync_6
   2942                      mqtt_sub_sync_node_t *node = NULL;
   2943          #ifndef PLATFORM_HAS_DYNMEM
   2944                      int idx = 0;
   2945          #endif
   2946          #ifdef PLATFORM_HAS_DYNMEM
   2947                      node = (mqtt_sub_sync_node_t *)mqtt_malloc(sizeof(mqtt_sub_sync_node_t));
   \       0x6A   0x2014             MOVS     R0,#+20
   \       0x6C   0x....'....        BL       HAL_Malloc
   \       0x70   0x0005             MOVS     R5,R0
   2948          #else
   2949                      for (idx = 0; idx < IOTX_MC_SUBSYNC_LIST_MAX_LEN; idx++) {
   2950                          if (client->list_sub_sync_ack[idx].used == 0) {
   2951                              memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
   2952                              client->list_sub_sync_ack[idx].used = 1;
   2953                              node = &client->list_sub_sync_ack[idx];
   2954                              break;
   2955                          }
   2956                      }
   2957          #endif
   2958                      if (node != NULL) {
   \       0x72   0xD00F             BEQ.N    ??wrapper_mqtt_subscribe_sync_6
   2959                          mqtt_debug("packet_id = %d", ret);
   2960                          node->packet_id = ret;
   \       0x74   0x602F             STR      R7,[R5, #+0]
   2961                          node->ack_type = IOTX_MQTT_EVENT_UNDEF;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x7128             STRB     R0,[R5, #+4]
   2962          #ifdef PLATFORM_HAS_DYNMEM
   2963                          HAL_MutexLock(client->lock_generic);
   \       0x7A   0x6830             LDR      R0,[R6, #+0]
   \       0x7C   0x....'....        BL       HAL_MutexLock
   2964                          list_add_tail(&node->linked_list, &client->list_sub_sync_ack);
   \       0x80   0xF106 0x01C8      ADD      R1,R6,#+200
   \       0x84   0xF105 0x000C      ADD      R0,R5,#+12
   \       0x88   0x....'....        BL       dlist_add_tail
   2965                          HAL_MutexUnlock(client->lock_generic);
   \       0x8C   0x6830             LDR      R0,[R6, #+0]
   \       0x8E   0x....'....        BL       HAL_MutexUnlock
   2966          #endif
   2967                          subed = 1;
   \       0x92   0x2401             MOVS     R4,#+1
   2968                      }
   2969          
   2970                  }
   2971                  wrapper_mqtt_yield(client, 100);
   \                     ??wrapper_mqtt_subscribe_sync_6: (+1)
   \       0x94   0x2164             MOVS     R1,#+100
   \       0x96   0x4630             MOV      R0,R6
   \       0x98   0x....'....        BL       wrapper_mqtt_yield
   2972          
   2973                  HAL_MutexLock(client->lock_generic);
   \       0x9C   0x6830             LDR      R0,[R6, #+0]
   \       0x9E   0x....'....        BL       HAL_MutexLock
   2974          #ifdef PLATFORM_HAS_DYNMEM
   2975                  list_for_each_entry_safe(node, next, &client->list_sub_sync_ack, linked_list, mqtt_sub_sync_node_t) {
   \       0xA2   0xF8D6 0x00CC      LDR      R0,[R6, #+204]
   \       0xA6   0xF1A0 0x050C      SUB      R5,R0,#+12
   \       0xAA   0xF106 0x01C8      ADD      R1,R6,#+200
   \       0xAE   0x4288             CMP      R0,R1
   \       0xB0   0xD012             BEQ.N    ??wrapper_mqtt_subscribe_sync_7
   2976                      if (node->packet_id == ret) {
   \       0xB2   0x6828             LDR      R0,[R5, #+0]
   \       0xB4   0x42B8             CMP      R0,R7
   \       0xB6   0xD10F             BNE.N    ??wrapper_mqtt_subscribe_sync_7
   2977                          mqtt_debug("node->ack_type=%d cnt=%d", node->ack_type, cnt++);
   2978                          if (node->ack_type == IOTX_MQTT_EVENT_SUBCRIBE_SUCCESS) {
   \       0xB8   0x7928             LDRB     R0,[R5, #+4]
   \       0xBA   0x2803             CMP      R0,#+3
   \       0xBC   0xD01F             BEQ.N    ??wrapper_mqtt_subscribe_sync_8
   2979                              list_del(&node->linked_list);
   2980                              mqtt_free(node);
   2981                              mqtt_debug("success!!");
   2982                              HAL_MutexUnlock(client->lock_generic);
   2983                              return ret;
   2984                          } else if (node->ack_type == IOTX_MQTT_EVENT_SUBCRIBE_NACK) {
   \       0xBE   0x2805             CMP      R0,#+5
   \       0xC0   0xD001             BEQ.N    ??wrapper_mqtt_subscribe_sync_9
   2985                              list_del(&node->linked_list);
   2986                              mqtt_free(node);
   2987                              ret = -1; /* resub */
   2988                              subed = 0;
   2989                          } else if (node->ack_type == IOTX_MQTT_EVENT_SUBCRIBE_TIMEOUT) {
   \       0xC2   0x2804             CMP      R0,#+4
   \       0xC4   0xD108             BNE.N    ??wrapper_mqtt_subscribe_sync_7
   2990                              list_del(&node->linked_list);
   \                     ??wrapper_mqtt_subscribe_sync_9: (+1)
   \       0xC6   0xF105 0x000C      ADD      R0,R5,#+12
   \       0xCA   0x....'....        BL       dlist_del
   2991                              mqtt_free(node);
   \       0xCE   0x4628             MOV      R0,R5
   \       0xD0   0x....'....        BL       HAL_Free
   2992                              ret = -1; /* resub */
   \       0xD4   0x464F             MOV      R7,R9
   2993                              subed = 0;
   \       0xD6   0x2400             MOVS     R4,#+0
   2994                          }
   2995                      }
   2996                      break;
   2997                  }
   2998          #else
   2999                  for (idx = 0; idx < IOTX_MC_SUBSYNC_LIST_MAX_LEN; idx++) {
   3000                      if (client->list_sub_sync_ack[idx].used == 0) {
   3001                          continue;
   3002                      }
   3003          
   3004                      if (client->list_sub_sync_ack[idx].packet_id == ret) {
   3005                          mqtt_debug("client->list_sub_sync_ack[%d].ack_type=%d cnt=%d", idx, client->list_sub_sync_ack[idx].ack_type, cnt++);
   3006                          if (client->list_sub_sync_ack[idx].ack_type == IOTX_MQTT_EVENT_SUBCRIBE_SUCCESS) {
   3007                              memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
   3008                              mqtt_debug("success!!");
   3009                              HAL_MutexUnlock(client->lock_generic);
   3010                              return ret;
   3011                          } else if (client->list_sub_sync_ack[idx].ack_type == IOTX_MQTT_EVENT_SUBCRIBE_NACK) {
   3012                              memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
   3013                              ret = -1; /* resub */
   3014                              subed = 0;
   3015                          } else if (client->list_sub_sync_ack[idx].ack_type == IOTX_MQTT_EVENT_SUBCRIBE_TIMEOUT) {
   3016                              memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
   3017                              ret = -1; /* resub */
   3018                              subed = 0;
   3019                          }
   3020                      }
   3021                      break;
   3022                  }
   3023          #endif
   3024                  HAL_MutexUnlock(client->lock_generic);
   \                     ??wrapper_mqtt_subscribe_sync_7: (+1)
   \       0xD8   0x6830             LDR      R0,[R6, #+0]
   \       0xDA   0x....'....        BL       HAL_MutexUnlock
   3025              } while (!utils_time_is_expired(&timer));
   \       0xDE   0xA801             ADD      R0,SP,#+4
   \       0xE0   0x....'....        BL       utils_time_is_expired
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD0AA             BEQ.N    ??wrapper_mqtt_subscribe_sync_3
   3026              mqtt_warning("sync subscribe time out!!");
   3027          
   3028              HAL_MutexLock(client->lock_generic);
   \       0xE8   0x6830             LDR      R0,[R6, #+0]
   \       0xEA   0x....'....        BL       HAL_MutexLock
   3029          #ifdef PLATFORM_HAS_DYNMEM
   3030              list_for_each_entry_safe(node, next, &client->list_sub_sync_ack, linked_list, mqtt_sub_sync_node_t) {
   \       0xEE   0xF8D6 0x00CC      LDR      R0,[R6, #+204]
   \       0xF2   0xF1A0 0x040C      SUB      R4,R0,#+12
   \       0xF6   0x6920             LDR      R0,[R4, #+16]
   \       0xF8   0xF1A0 0x050C      SUB      R5,R0,#+12
   \       0xFC   0xE019             B.N      ??wrapper_mqtt_subscribe_sync_10
   \                     ??wrapper_mqtt_subscribe_sync_8: (+1)
   \       0xFE   0xF105 0x000C      ADD      R0,R5,#+12
   \      0x102   0x....'....        BL       dlist_del
   \      0x106   0x4628             MOV      R0,R5
   \      0x108   0x....'....        BL       HAL_Free
   \      0x10C   0x6830             LDR      R0,[R6, #+0]
   \      0x10E   0x....'....        BL       HAL_MutexUnlock
   \      0x112   0x4638             MOV      R0,R7
   \      0x114   0xE017             B.N      ??wrapper_mqtt_subscribe_sync_1
   3031                  if (node->packet_id == ret) {
   \                     ??wrapper_mqtt_subscribe_sync_11: (+1)
   \      0x116   0x6820             LDR      R0,[R4, #+0]
   \      0x118   0x42B8             CMP      R0,R7
   \      0x11A   0xD106             BNE.N    ??wrapper_mqtt_subscribe_sync_12
   3032                      list_del(&node->linked_list);
   \      0x11C   0xF104 0x000C      ADD      R0,R4,#+12
   \      0x120   0x....'....        BL       dlist_del
   3033                      mqtt_free(node);
   \      0x124   0x4620             MOV      R0,R4
   \      0x126   0x....'....        BL       HAL_Free
   3034                  }
   3035              }
   \                     ??wrapper_mqtt_subscribe_sync_12: (+1)
   \      0x12A   0x462C             MOV      R4,R5
   \      0x12C   0x6928             LDR      R0,[R5, #+16]
   \      0x12E   0xF1A0 0x050C      SUB      R5,R0,#+12
   \                     ??wrapper_mqtt_subscribe_sync_10: (+1)
   \      0x132   0xF104 0x000C      ADD      R0,R4,#+12
   \      0x136   0xF106 0x01C8      ADD      R1,R6,#+200
   \      0x13A   0x4288             CMP      R0,R1
   \      0x13C   0xD1EB             BNE.N    ??wrapper_mqtt_subscribe_sync_11
   3036          #else
   3037              for (idx = 0; idx < IOTX_MC_SUBSYNC_LIST_MAX_LEN; idx++) {
   3038                  if (client->list_sub_sync_ack[idx].used && node->packet_id == ret) {
   3039                      memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
   3040                  }
   3041              }
   3042          #endif
   3043              HAL_MutexUnlock(client->lock_generic);
   \      0x13E   0x6830             LDR      R0,[R6, #+0]
   \      0x140   0x....'....        BL       HAL_MutexUnlock
   3044          
   3045              return -1;
   \      0x144   0x4648             MOV      R0,R9
   \                     ??wrapper_mqtt_subscribe_sync_1: (+1)
   \      0x146   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   \                     ??wrapper_mqtt_subscribe_sync_5: (+1)
   \      0x14A   0x4638             MOV      R0,R7
   \      0x14C   0xE7FB             B.N      ??wrapper_mqtt_subscribe_sync_1
   3046          }
   3047          

   \                                 In section .text, align 2, keep-with-next
   3048          int wrapper_mqtt_unsubscribe(void *client, const char *topicFilter)
   3049          {
   \                     wrapper_mqtt_unsubscribe: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   3050              int rc = FAIL_RETURN;
   3051              iotx_mc_client_t *c = (iotx_mc_client_t *)client;
   3052              unsigned int msgId;
   3053          
   3054              if (NULL == c || NULL == topicFilter) {
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD001             BEQ.N    ??wrapper_mqtt_unsubscribe_0
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??wrapper_mqtt_unsubscribe_1
   3055                  return NULL_VALUE_ERROR;
   \                     ??wrapper_mqtt_unsubscribe_0: (+1)
   \        0xE   0xF06F 0x0001      MVN      R0,#+1
   \       0x12   0xBD70             POP      {R4-R6,PC}
   3056              }
   3057              msgId = iotx_mc_get_next_packetid(c);
   \                     ??wrapper_mqtt_unsubscribe_1: (+1)
   \       0x14   0x....'....        BL       iotx_mc_get_next_packetid
   \       0x18   0x4606             MOV      R6,R0
   3058          
   3059              if (0 != iotx_mc_check_topic(topicFilter, TOPIC_FILTER_TYPE)) {
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       iotx_mc_check_topic
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD002             BEQ.N    ??wrapper_mqtt_unsubscribe_2
   3060                  mqtt_err("topic format is error,topicFilter = %s", topicFilter);
   3061                  return MQTT_TOPIC_FORMAT_ERROR;
   \       0x26   0xF06F 0x0028      MVN      R0,#+40
   \       0x2A   0xBD70             POP      {R4-R6,PC}
   3062              }
   3063          
   3064              if (!wrapper_mqtt_check_state(c)) {
   \                     ??wrapper_mqtt_unsubscribe_2: (+1)
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x....'....        BL       wrapper_mqtt_check_state
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD102             BNE.N    ??wrapper_mqtt_unsubscribe_3
   3065                  mqtt_err("mqtt client state is error,state = %d", iotx_mc_get_client_state(c));
   3066                  return MQTT_STATE_ERROR;
   \       0x36   0xF06F 0x001A      MVN      R0,#+26
   \       0x3A   0xBD70             POP      {R4-R6,PC}
   3067              }
   3068          
   3069              rc = MQTTUnsubscribe(c, topicFilter, msgId);
   \                     ??wrapper_mqtt_unsubscribe_3: (+1)
   \       0x3C   0x4632             MOV      R2,R6
   \       0x3E   0x4621             MOV      R1,R4
   \       0x40   0x4628             MOV      R0,R5
   \       0x42   0x....'....        BL       MQTTUnsubscribe
   \       0x46   0x0004             MOVS     R4,R0
   3070              if (rc != SUCCESS_RETURN) {
   \       0x48   0xD008             BEQ.N    ??wrapper_mqtt_unsubscribe_4
   3071                  if (rc == MQTT_NETWORK_ERROR) { /* send the subscribe packet */
   \       0x4A   0xF114 0x0F0E      CMN      R4,#+14
   \       0x4E   0xD103             BNE.N    ??wrapper_mqtt_unsubscribe_5
   3072                      iotx_mc_set_client_state(c, IOTX_MC_STATE_DISCONNECTED);
   \       0x50   0x2103             MOVS     R1,#+3
   \       0x52   0x4628             MOV      R0,R5
   \       0x54   0x....'....        BL       iotx_mc_set_client_state
   3073                  }
   3074          
   3075                  mqtt_err("run MQTTUnsubscribe error!, rc = %d", rc);
   3076                  return rc;
   \                     ??wrapper_mqtt_unsubscribe_5: (+1)
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0xBD70             POP      {R4-R6,PC}
   3077              }
   3078          
   3079              mqtt_info("mqtt unsubscribe packet sent,topic = %s!", topicFilter);
   3080              return (int)msgId;
   \                     ??wrapper_mqtt_unsubscribe_4: (+1)
   \       0x5C   0x4630             MOV      R0,R6
   \       0x5E   0xBD70             POP      {R4-R6,PC}       ;; return
   3081          }
   3082          

   \                                 In section .text, align 2, keep-with-next
   3083          int wrapper_mqtt_publish(void *client, const char *topicName, iotx_mqtt_topic_info_pt topic_msg)
   3084          {
   \                     wrapper_mqtt_publish: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4615             MOV      R5,R2
   3085              uint16_t msg_id = 0;
   \        0x8   0x2700             MOVS     R7,#+0
   3086              int rc = FAIL_RETURN;
   3087              iotx_mc_client_t *c = (iotx_mc_client_t *)client;
   3088              if (c == NULL || topicName == NULL || topic_msg == NULL || topic_msg->payload == NULL) {
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD006             BEQ.N    ??wrapper_mqtt_publish_0
   \        0xE   0x2E00             CMP      R6,#+0
   \       0x10   0xD004             BEQ.N    ??wrapper_mqtt_publish_0
   \       0x12   0x2D00             CMP      R5,#+0
   \       0x14   0xD002             BEQ.N    ??wrapper_mqtt_publish_0
   \       0x16   0x6928             LDR      R0,[R5, #+16]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD102             BNE.N    ??wrapper_mqtt_publish_1
   3089                  return NULL_VALUE_ERROR;
   \                     ??wrapper_mqtt_publish_0: (+1)
   \       0x1C   0xF06F 0x0001      MVN      R0,#+1
   \       0x20   0xBDF2             POP      {R1,R4-R7,PC}
   3090              }
   3091          
   3092              if (0 != iotx_mc_check_topic(topicName, TOPIC_NAME_TYPE)) {
   \                     ??wrapper_mqtt_publish_1: (+1)
   \       0x22   0x4639             MOV      R1,R7
   \       0x24   0x4630             MOV      R0,R6
   \       0x26   0x....'....        BL       iotx_mc_check_topic
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD002             BEQ.N    ??wrapper_mqtt_publish_2
   3093                  mqtt_err("topic format is error,topicFilter = %s", topicName);
   3094                  return MQTT_TOPIC_FORMAT_ERROR;
   \       0x2E   0xF06F 0x0028      MVN      R0,#+40
   \       0x32   0xBDF2             POP      {R1,R4-R7,PC}
   3095              }
   3096          
   3097              if (!wrapper_mqtt_check_state(c)) {
   \                     ??wrapper_mqtt_publish_2: (+1)
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       wrapper_mqtt_check_state
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD102             BNE.N    ??wrapper_mqtt_publish_3
   3098                  mqtt_err("mqtt client state is error,state = %d", iotx_mc_get_client_state(c));
   3099                  return MQTT_STATE_ERROR;
   \       0x3E   0xF06F 0x001A      MVN      R0,#+26
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}
   3100              }
   3101          
   3102          #if !WITH_MQTT_ONLY_QOS0
   3103              if (topic_msg->qos == IOTX_MQTT_QOS1 || topic_msg->qos == IOTX_MQTT_QOS2) {
   \                     ??wrapper_mqtt_publish_3: (+1)
   \       0x44   0x78A8             LDRB     R0,[R5, #+2]
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD001             BEQ.N    ??wrapper_mqtt_publish_4
   \       0x4A   0x2802             CMP      R0,#+2
   \       0x4C   0xD104             BNE.N    ??wrapper_mqtt_publish_5
   3104                  msg_id = iotx_mc_get_next_packetid(c);
   \                     ??wrapper_mqtt_publish_4: (+1)
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x....'....        BL       iotx_mc_get_next_packetid
   \       0x54   0x4607             MOV      R7,R0
   3105                  topic_msg->packet_id = msg_id;
   \       0x56   0x802F             STRH     R7,[R5, #+0]
   3106              }
   3107              if (topic_msg->qos == IOTX_MQTT_QOS2) {
   \                     ??wrapper_mqtt_publish_5: (+1)
   \       0x58   0x78A8             LDRB     R0,[R5, #+2]
   \       0x5A   0x2802             CMP      R0,#+2
   \       0x5C   0xD102             BNE.N    ??wrapper_mqtt_publish_6
   3108                  mqtt_err("MQTTPublish return error,MQTT_QOS2 is now not supported.");
   3109                  return MQTT_PUBLISH_QOS_ERROR;
   \       0x5E   0xF06F 0x0013      MVN      R0,#+19
   \       0x62   0xBDF2             POP      {R1,R4-R7,PC}
   3110              }
   3111          #else
   3112              topic_msg->qos = IOTX_MQTT_QOS0;
   3113          #endif
   3114          
   3115          #if defined(INSPECT_MQTT_FLOW) && defined(INFRA_LOG)
   3116              HEXDUMP_DEBUG(topicName, strlen(topicName));
   3117              HEXDUMP_DEBUG(topic_msg->payload, topic_msg->payload_len);
   3118          #endif
   3119          
   3120              rc = MQTTPublish(c, topicName, topic_msg);
   \                     ??wrapper_mqtt_publish_6: (+1)
   \       0x64   0x462A             MOV      R2,R5
   \       0x66   0x4631             MOV      R1,R6
   \       0x68   0x4620             MOV      R0,R4
   \       0x6A   0x....'....        BL       MQTTPublish
   \       0x6E   0x0005             MOVS     R5,R0
   3121              if (rc != SUCCESS_RETURN) { /* send the subscribe packet */
   \       0x70   0xD008             BEQ.N    ??wrapper_mqtt_publish_7
   3122                  if (rc == MQTT_NETWORK_ERROR) {
   \       0x72   0xF115 0x0F0E      CMN      R5,#+14
   \       0x76   0xD103             BNE.N    ??wrapper_mqtt_publish_8
   3123                      iotx_mc_set_client_state(c, IOTX_MC_STATE_DISCONNECTED);
   \       0x78   0x2103             MOVS     R1,#+3
   \       0x7A   0x4620             MOV      R0,R4
   \       0x7C   0x....'....        BL       iotx_mc_set_client_state
   3124                  }
   3125                  mqtt_err("MQTTPublish is error, rc = %d", rc);
   3126                  return rc;
   \                     ??wrapper_mqtt_publish_8: (+1)
   \       0x80   0x4628             MOV      R0,R5
   \       0x82   0xBDF2             POP      {R1,R4-R7,PC}
   3127              }
   3128          
   3129              return (int)msg_id;
   \                     ??wrapper_mqtt_publish_7: (+1)
   \       0x84   0xB2BF             UXTH     R7,R7
   \       0x86   0x4638             MOV      R0,R7
   \       0x88   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3130          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     iotx_ca_crt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0xFFFF'FC0A        DC32     0xfffffc0a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     _in_yield_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     _in_yield_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0xFFFF'FC09        DC32     0xfffffc09

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x6D 0x71          DC8 "mqtt read buffer is too short"
   \              0x74 0x74    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x20    
   \              0x62 0x75    
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x73 0x68    
   \              0x6F 0x72    
   \              0x74 0x00    
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \        0x0   0x2F 0x00          DC8 "/"
   3131          
   3132          #ifdef ASYNC_PROTOCOL_STACK
   3133          int wrapper_mqtt_nwk_event_handler(void *client, iotx_mqtt_nwk_event_t event, iotx_mqtt_nwk_param_t *param)
   3134          {
   3135              int rc = FAIL_RETURN;
   3136              iotx_mc_client_t *pClient = (iotx_mc_client_t *)client;
   3137              if (client == NULL || event >= IOTX_MQTT_SOC_MAX) {
   3138                  return NULL_VALUE_ERROR;
   3139              }
   3140          
   3141              switch (event) {
   3142                  case IOTX_MQTT_SOC_CONNECTED: {
   3143                      rc = _mqtt_connect(pClient);
   3144                      if (rc == SUCCESS_RETURN) {
   3145                          iotx_mc_set_client_state(pClient, IOTX_MC_STATE_CONNECTED);
   3146                      }
   3147                  }
   3148                  break;
   3149                  case IOTX_MQTT_SOC_CLOSE: {
   3150                      iotx_mc_set_client_state(pClient, IOTX_MC_STATE_DISCONNECTED);
   3151                  }
   3152                  break;
   3153                  case IOTX_MQTT_SOC_READ: {
   3154                      HAL_MutexLock(pClient->lock_yield);
   3155                      _mqtt_cycle(pClient);
   3156                      HAL_MutexUnlock(pClient->lock_yield);
   3157                      rc = SUCCESS_RETURN;
   3158                  }
   3159                  break;
   3160                  case IOTX_MQTT_SOC_WRITE: {
   3161          
   3162                  }
   3163                  break;
   3164                  default: {
   3165                      mqtt_err("unknown event: %d", event);
   3166                  }
   3167                  break;
   3168              }
   3169          
   3170              return rc;
   3171          }
   3172          #endif
   3173          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   INIT_AOS_DLIST_HEAD
      16   MQTTConnect
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> MQTTSerialize_connect
        16   -> _alloc_send_buffer
        16   -> _get_connect_length
        16   -> _reset_send_buffer
        16   -> iotx_mc_send_packet
        16   -> iotx_time_init
        16   -> utils_time_countdown_ms
      24   MQTTDisconnect
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> MQTTSerialize_disconnect
        24   -> _alloc_send_buffer
        24   -> _reset_send_buffer
        24   -> iotx_mc_send_packet
        24   -> iotx_time_init
        24   -> utils_time_countdown_ms
      16   MQTTKeepalive
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> MQTTSerialize_pingreq
        16   -> _alloc_send_buffer
        16   -> _reset_send_buffer
        16   -> iotx_mc_send_packet
        16   -> iotx_time_init
        16   -> utils_time_countdown_ms
      24   MQTTPubInfoProc
        24   -> HAL_Free
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> MQTTRePublish
        24   -> dlist_del
        24   -> iotx_mc_get_client_state
        24   -> iotx_mc_set_client_state
        24   -> iotx_time_start
        24   -> utils_time_spend
      24   MQTTPuback
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> MQTTSerialize_ack
        24   -> _alloc_send_buffer
        24   -> _reset_send_buffer
        24   -> iotx_mc_send_packet
        24   -> iotx_time_init
        24   -> utils_time_countdown_ms
      64   MQTTPublish
        64   -> HAL_Free
        64   -> HAL_MutexLock
        64   -> HAL_MutexUnlock
        64   -> MQTTSerialize_publish
        64   -> _alloc_send_buffer
        64   -> _reset_send_buffer
        64   -> dlist_del
        64   -> iotx_facility_json_print
        64   -> iotx_mc_push_pubInfo_to
        64   -> iotx_mc_send_packet
        64   -> iotx_time_init
        64   -> strlen
        64   -> utils_time_countdown_ms
      24   MQTTRePublish
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> iotx_mc_send_packet
        24   -> iotx_time_init
        24   -> utils_time_countdown_ms
      64   MQTTSubscribe
        64   -> HAL_Free
        64   -> HAL_Malloc
        64   -> HAL_MutexLock
        64   -> HAL_MutexUnlock
        64   -> INIT_AOS_DLIST_HEAD
        64   -> MQTTSerialize_subscribe
        64   -> __aeabi_memcpy
        64   -> __aeabi_memset
        64   -> __aeabi_memset4
        64   -> _alloc_send_buffer
        64   -> _reset_send_buffer
        64   -> dlist_add_tail
        64   -> iotx_mc_check_handle_is_identical
        64   -> iotx_mc_send_packet
        64   -> iotx_time_init
        64   -> strlen
        64   -> utils_time_countdown_ms
      56   MQTTUnsubscribe
        56   -> HAL_Free
        56   -> HAL_Malloc
        56   -> HAL_MutexLock
        56   -> HAL_MutexUnlock
        56   -> MQTTPacket_equals
        56   -> MQTTSerialize_unsubscribe
        56   -> __aeabi_memcpy
        56   -> __aeabi_memset
        56   -> __aeabi_memset4
        56   -> _alloc_send_buffer
        56   -> _reset_send_buffer
        56   -> dlist_del
        56   -> iotx_mc_is_topic_matched
        56   -> iotx_mc_send_packet
        56   -> iotx_time_init
        56   -> strlen
        56   -> utils_time_countdown_ms
       0   __dlist_add
       0   __dlist_entry_number
      16   _alloc_recv_buffer
        16   -> HAL_Free
        16   -> HAL_Malloc
        16   -> __aeabi_memcpy
        16   -> __aeabi_memset
      16   _alloc_send_buffer
        16   -> HAL_Free
        16   -> HAL_Malloc
        16   -> __aeabi_memset
       8   _get_connect_length
         0   -> MQTTPacket_len
         8   -> MQTTSerialize_connectLength
       8   _handle_event
         8   -- Indirect call
      16   _iotx_mqtt_event_handle_sub
        16   -> HAL_MutexLock
         0   -> HAL_MutexUnlock
       0   _is_in_yield_cb
      24   _mqtt_connect
        24   -- Indirect call
        24   -> HAL_SleepMs
        24   -> MQTTConnect
        24   -> iotx_mc_set_client_state
        24   -> iotx_mc_wait_CONNACK
        24   -> utils_time_countdown_ms
      16   _mqtt_cycle
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> HAL_SleepMs
        16   -> MQTTPubInfoProc
        16   -> iotx_mc_cycle
        16   -> iotx_time_init
        16   -> iotx_time_left
        16   -> utils_time_countdown_ms
        16   -> utils_time_is_expired
       8   _reset_recv_buffer
         8   -> HAL_Free
       8   _reset_send_buffer
         8   -> HAL_Free
       0   dlist_add_tail
         0   -> __dlist_add
       0   dlist_del
       8   iotx_mc_attempt_reconnect
         8   -- Indirect call
         0   -> wrapper_mqtt_connect
      16   iotx_mc_check_handle_is_identical
        16   -> iotx_mc_check_handle_is_identical_ex
      16   iotx_mc_check_handle_is_identical_ex
        16   -> strlen
        16   -> strncmp
      16   iotx_mc_check_rule
        16   -> strlen
     152   iotx_mc_check_topic
       152   -> __aeabi_memset4
       152   -> infra_strtok
       152   -> iotx_mc_check_rule
       152   -> strlen
       152   -> strncpy
      24   iotx_mc_cycle
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> _reset_recv_buffer
        24   -> iotx_mc_get_client_state
        24   -> iotx_mc_handle_recv_PUBACK
        24   -> iotx_mc_handle_recv_PUBLISH
        24   -> iotx_mc_handle_recv_SUBACK
        24   -> iotx_mc_handle_recv_UNSUBACK
        24   -> iotx_mc_read_packet
        24   -> iotx_mc_set_client_state
      32   iotx_mc_decode_packet
        32   -- Indirect call
      32   iotx_mc_deliver_message
        32   -> HAL_MutexLock
        32   -> HAL_MutexUnlock
        32   -> MQTTPacket_equals
        32   -> _handle_event
        32   -> iotx_mc_is_topic_matched
       8   iotx_mc_disconnect
         8   -- Indirect call
         8   -> MQTTDisconnect
         8   -> iotx_mc_set_client_state
         8   -> wrapper_mqtt_check_state
      16   iotx_mc_disconnect_callback
        16   -- Indirect call
      16   iotx_mc_get_client_state
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
      16   iotx_mc_get_next_packetid
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
      16   iotx_mc_handle_reconnect
        16   -> HAL_SleepMs
        16   -> iotx_mc_attempt_reconnect
        16   -> iotx_mc_set_client_state
        16   -> utils_time_countdown_ms
        16   -> utils_time_is_expired
      16   iotx_mc_handle_recv_CONNACK
        16   -> MQTTDeserialize_connack
      24   iotx_mc_handle_recv_PUBACK
        24   -> MQTTDeserialize_ack
        24   -> _handle_event
        24   -> iotx_mc_mask_pubInfo_from
      72   iotx_mc_handle_recv_PUBLISH
        72   -> MQTTDeserialize_publish
        72   -> MQTTPuback
        72   -> __aeabi_memset4
        72   -> get_msgid
        72   -> iotx_facility_json_print
        72   -> iotx_mc_deliver_message
      64   iotx_mc_handle_recv_SUBACK
        64   -> MQTTDeserialize_suback
        64   -> _handle_event
        64   -> _iotx_mqtt_event_handle_sub
      24   iotx_mc_handle_recv_UNSUBACK
        24   -> MQTTDeserialize_unsuback
        24   -> _handle_event
     112   iotx_mc_init
       112   -> HAL_Free
       112   -> HAL_MutexCreate
       112   -> HAL_MutexDestroy
       112   -> INIT_AOS_DLIST_HEAD
       112   -> __aeabi_memcpy4
       112   -> __aeabi_memset4
       112   -> iotx_mc_pub_wait_list_init
       112   -> iotx_mc_set_client_state
       112   -> iotx_mc_set_connect_params
       112   -> iotx_net_init
       112   -> iotx_time_init
       4   iotx_mc_is_topic_matched
       8   iotx_mc_keepalive
         8   -- Indirect call
         8   -> iotx_mc_disconnect_callback
         8   -> iotx_mc_get_client_state
         8   -> iotx_mc_handle_reconnect
         8   -> iotx_mc_keepalive_sub
         8   -> iotx_mc_reconnect_callback
         0   -> iotx_mc_set_client_state
         8   -> utils_time_countdown_ms
      16   iotx_mc_keepalive_sub
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> MQTTKeepalive
        16   -> iotx_mc_set_client_state
        16   -> utils_time_countdown_ms
        16   -> utils_time_is_expired
        16   -> wrapper_mqtt_check_state
      16   iotx_mc_mask_pubInfo_from
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
      16   iotx_mc_pub_wait_list_deinit
        16   -> HAL_Free
        16   -> dlist_del
       0   iotx_mc_pub_wait_list_init
         0   -> INIT_AOS_DLIST_HEAD
      24   iotx_mc_push_pubInfo_to
        24   -> HAL_Malloc
        24   -> INIT_AOS_DLIST_HEAD
        24   -> __aeabi_memcpy
        24   -> __dlist_entry_number
        24   -> dlist_add_tail
        24   -> iotx_time_start
      40   iotx_mc_read_packet
        40   -- Indirect call
        40   -> HAL_Free
        40   -> HAL_Malloc
        40   -> HAL_MutexLock
        40   -> HAL_MutexUnlock
        40   -> MQTTPacket_encode
        40   -> _alloc_recv_buffer
        40   -> _handle_event
        40   -> iotx_mc_decode_packet
        40   -> iotx_time_left
      16   iotx_mc_reconnect_callback
        16   -- Indirect call
       0   iotx_mc_release
         0   -> HAL_Free
      24   iotx_mc_send_packet
        24   -- Indirect call
        24   -> iotx_time_left
        24   -> utils_time_is_expired
      16   iotx_mc_set_client_state
        16   -> HAL_MutexLock
         0   -> HAL_MutexUnlock
      16   iotx_mc_set_connect_params
        16   -> __aeabi_memcpy4
      24   iotx_mc_wait_CONNACK
        24   -> HAL_MutexLock
        24   -> HAL_MutexUnlock
        24   -> _reset_recv_buffer
        24   -> iotx_mc_handle_recv_CONNACK
        24   -> iotx_mc_read_packet
        24   -> iotx_time_init
        24   -> utils_time_countdown_ms
       8   wrapper_mqtt_check_state
         8   -> iotx_mc_get_client_state
      16   wrapper_mqtt_connect
        16   -- Indirect call
        16   -> HAL_SleepMs
         0   -> _mqtt_connect
      16   wrapper_mqtt_init
        16   -> HAL_Malloc
        16   -> __aeabi_memset4
        16   -> iotx_mc_init
        16   -> iotx_mc_release
      24   wrapper_mqtt_publish
        24   -> MQTTPublish
        24   -> iotx_mc_check_topic
        24   -> iotx_mc_get_next_packetid
        24   -> iotx_mc_set_client_state
        24   -> wrapper_mqtt_check_state
      24   wrapper_mqtt_release
        24   -> HAL_Free
        24   -> HAL_MutexDestroy
        24   -> HAL_SleepMs
        24   -> dlist_del
        24   -> iotx_mc_disconnect
        24   -> iotx_mc_pub_wait_list_deinit
        24   -> iotx_mc_set_client_state
      32   wrapper_mqtt_subscribe
        32   -> MQTTSubscribe
        32   -> iotx_mc_check_topic
        32   -> iotx_mc_get_next_packetid
        32   -> iotx_mc_set_client_state
        32   -> strlen
        32   -> wrapper_mqtt_check_state
      48   wrapper_mqtt_subscribe_sync
        48   -> HAL_Free
        48   -> HAL_Malloc
        48   -> HAL_MutexLock
        48   -> HAL_MutexUnlock
        48   -> _is_in_yield_cb
        48   -> dlist_add_tail
        48   -> dlist_del
        48   -> iotx_time_init
        48   -> utils_time_countdown_ms
        48   -> utils_time_is_expired
        48   -> wrapper_mqtt_subscribe
        48   -> wrapper_mqtt_yield
      16   wrapper_mqtt_unsubscribe
        16   -> MQTTUnsubscribe
        16   -> iotx_mc_check_topic
        16   -> iotx_mc_get_next_packetid
        16   -> iotx_mc_set_client_state
        16   -> wrapper_mqtt_check_state
      16   wrapper_mqtt_yield
        16   -> HAL_MutexLock
        16   -> HAL_MutexUnlock
        16   -> _mqtt_cycle
        16   -> iotx_mc_keepalive


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
      32  ?_0
       2  ?_1
      88  ?_2
      12  ?_3
      12  ?_4
      12  ?_5
       6  INIT_AOS_DLIST_HEAD
     158  MQTTConnect
     108  MQTTDisconnect
     146  MQTTKeepalive
     144  MQTTPubInfoProc
     176  MQTTPuback
     354  MQTTPublish
      68  MQTTRePublish
     448  MQTTSubscribe
     454  MQTTUnsubscribe
      10  __dlist_add
      20  __dlist_entry_number
     110  _alloc_recv_buffer
      72  _alloc_send_buffer
      14  _get_connect_length
      36  _handle_event
       4  _in_yield_cb
      74  _iotx_mqtt_event_handle_sub
       8  _is_in_yield_cb
     162  _mqtt_connect
      86  _mqtt_cycle
      30  _reset_recv_buffer
      30  _reset_send_buffer
       6  dlist_add_tail
      10  dlist_del
      30  iotx_mc_attempt_reconnect
      46  iotx_mc_check_handle_is_identical
      76  iotx_mc_check_handle_is_identical_ex
      68  iotx_mc_check_rule
     116  iotx_mc_check_topic
     270  iotx_mc_cycle
     114  iotx_mc_decode_packet
     178  iotx_mc_deliver_message
      46  iotx_mc_disconnect
      38  iotx_mc_disconnect_callback
      24  iotx_mc_get_client_state
      48  iotx_mc_get_next_packetid
     108  iotx_mc_handle_reconnect
     106  iotx_mc_handle_recv_CONNACK
      98  iotx_mc_handle_recv_PUBACK
     188  iotx_mc_handle_recv_PUBLISH
     156  iotx_mc_handle_recv_SUBACK
      78  iotx_mc_handle_recv_UNSUBACK
     418  iotx_mc_init
     114  iotx_mc_is_topic_matched
      96  iotx_mc_keepalive
     108  iotx_mc_keepalive_sub
      72  iotx_mc_mask_pubInfo_from
      52  iotx_mc_pub_wait_list_deinit
       4  iotx_mc_pub_wait_list_init
     136  iotx_mc_push_pubInfo_to
     486  iotx_mc_read_packet
      38  iotx_mc_reconnect_callback
       4  iotx_mc_release
     104  iotx_mc_send_packet
      26  iotx_mc_set_client_state
     206  iotx_mc_set_connect_params
     152  iotx_mc_wait_CONNACK
      26  wrapper_mqtt_check_state
      72  wrapper_mqtt_connect
      48  wrapper_mqtt_init
     138  wrapper_mqtt_publish
     182  wrapper_mqtt_release
     128  wrapper_mqtt_subscribe
     334  wrapper_mqtt_subscribe_sync
      96  wrapper_mqtt_unsubscribe
      64  wrapper_mqtt_yield

 
     4 bytes in section .bss
   158 bytes in section .rodata
 7 654 bytes in section .text
 
 7 654 bytes of CODE  memory
   158 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
