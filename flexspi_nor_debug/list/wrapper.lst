###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         26/Jun/2019  17:07:58
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\wrapper.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\2\EWB62F.tmp
#        (C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\wrapper.c -D DEBUG
#        -D USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1 -D
#        CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list -lA
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list --diag_suppress
#        Pa082,Pa050 -o C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\gzkc_smart_nbiot/source\app_preinclude.h -I
#        C:\Development\gzkc_smart_nbiot/board\ -I
#        C:\Development\gzkc_smart_nbiot/source\ -I
#        C:\Development\gzkc_smart_nbiot/CMSIS\ -I
#        C:\Development\gzkc_smart_nbiot/amazon-freertos/freertos/portable\ -I
#        C:\Development\gzkc_smart_nbiot/amazon-freertos/include\ -I
#        C:\Development\gzkc_smart_nbiot/component/lists\ -I
#        C:\Development\gzkc_smart_nbiot/component/serial_manager\ -I
#        C:\Development\gzkc_smart_nbiot/component/uart\ -I
#        C:\Development\gzkc_smart_nbiot/component/kv\ -I
#        C:\Development\gzkc_smart_nbiot/component/kv/include\ -I
#        C:\Development\gzkc_smart_nbiot/device\ -I
#        C:\Development\gzkc_smart_nbiot/doc\ -I
#        C:\Development\gzkc_smart_nbiot/drivers\ -I
#        C:\Development\gzkc_smart_nbiot/src\ -I
#        C:\Development\gzkc_smart_nbiot/startup\ -I
#        C:\Development\gzkc_smart_nbiot/utilities\ -I
#        C:\Development\gzkc_smart_nbiot/xip\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\atm\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_model\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_sign\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\infra\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\mqtt\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\external_libs\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_cloud\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\CoAPPacket\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\server\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\os\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\awss_reset\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\include\mbedtls\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\include\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list\wrapper.lst
#    Object file  =  
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\obj\wrapper.o
#
###############################################################################

C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\wrapper.c
      1          /**
      2           * NOTE:
      3           *
      4           * HAL_TCP_xxx API reference implementation: wrappers/os/ubuntu/HAL_TCP_linux.c
      5           *
      6           */
      7          #include "infra_types.h"
      8          #include "infra_defs.h"
      9          #include "infra_compat.h"
     10          #include "wrappers_defs.h"
     11          #include "FreeRTOS.h"
     12          #include "timers.h"
     13          #include "queue.h"
     14          #include "semphr.h"
     15          #include "portmacro.h"
     16          #include "at_wrapper.h"
     17          #include "mimxrt1052.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     __NVIC_SetPriority: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   \        0x2   0xD404             BMI.N    ??__NVIC_SetPriority_0
   \        0x4   0x0109             LSLS     R1,R1,#+4
   \        0x6   0x....'....        LDR.W    R2,??DataTable16  ;; 0xe000e400
   \        0xA   0x5411             STRB     R1,[R2, R0]
   \        0xC   0x4770             BX       LR
   \                     ??__NVIC_SetPriority_0: (+1)
   \        0xE   0x0109             LSLS     R1,R1,#+4
   \       0x10   0x....'....        LDR.W    R2,??DataTable16_1  ;; 0xe000ed18
   \       0x14   0xF000 0x000F      AND      R0,R0,#0xF
   \       0x18   0x4410             ADD      R0,R2,R0
   \       0x1A   0xF800 0x1C04      STRB     R1,[R0, #-4]
   \       0x1E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t SysTick_Config(uint32_t)
   \                     SysTick_Config: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x1E41             SUBS     R1,R0,#+1
   \        0x4   0xF1B1 0x7F80      CMP      R1,#+16777216
   \        0x8   0xD301             BCC.N    ??SysTick_Config_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xBD02             POP      {R1,PC}
   \                     ??SysTick_Config_0: (+1)
   \        0xE   0x1E40             SUBS     R0,R0,#+1
   \       0x10   0x....'....        LDR.W    R1,??DataTable16_2  ;; 0xe000e014
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \       0x16   0x210F             MOVS     R1,#+15
   \       0x18   0xF04F 0x30FF      MOV      R0,#-1
   \       0x1C   0x....'....        BL       __NVIC_SetPriority
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x....'....        LDR.W    R1,??DataTable16_3  ;; 0xe000e018
   \       0x26   0x6008             STR      R0,[R1, #+0]
   \       0x28   0x2007             MOVS     R0,#+7
   \       0x2A   0x....'....        LDR.W    R1,??DataTable16_4  ;; 0xe000e010
   \       0x2E   0x6008             STR      R0,[R1, #+0]
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD02             POP      {R1,PC}          ;; return
     18          #include "fsl_trng.h"
     19          #include "fsl_clock.h"
     20          #include "fsl_lpuart.h"
     21          
     22          

   \                                 In section .bss, align 1
     23          unsigned char srandom_inited = 0;
   \                     srandom_inited:
   \        0x0                      DS8 1
     24          #ifndef SECURITY_MATERIAL_APP
     25          #define PRODUCT_KEY_D      "a1I5Y6v8HwT"
     26          #define PRODUCT_SECRET_D   "S56FG57Rqjr24CHo"
     27          #define DEVICE_NAME_D      "smart_wm_test1"
     28          #define DEVICE_SECRET_D    "3qLxqnrCCxhEVJUJjq88jEYkPwi2CZCr"
     29          #define FIRMWARE_VER_D	 "1.1.1"
     30          #endif
     31          
     32          #ifndef EIO
     33          #define EIO 5
     34          #endif
     35          
     36          #define UART_TX_INT_THRESHOLD 1
     37          static volatile uint32_t sys_tick_cnt;
     38          static volatile uint8_t wrapped = 0;

   \                                 In section .rodata, align 4
     39          static const uint32_t s_uartBaseAddrs[8] = {(uint32_t)LPUART1_BASE, (uint32_t)LPUART2_BASE,
   \                     s_uartBaseAddrs:
   \        0x0   0x4018'4000        DC32 1075331072, 1075347456, 1075363840, 1075380224, 1075396608
   \              0x4018'8000  
   \              0x4018'C000  
   \              0x4019'0000  
   \              0x4019'4000  
   \       0x14   0x4019'8000        DC32 1075412992, 1075429376, 1075445760
   \              0x4019'C000  
   \              0x401A'0000  
     40          (uint32_t)LPUART3_BASE, (uint32_t)LPUART4_BASE, (uint32_t)LPUART5_BASE, (uint32_t)LPUART6_BASE, (uint32_t)LPUART7_BASE, 
     41          (uint32_t)LPUART8_BASE};
     42          static lpuart_handle_t s_handle[9];
     43          
     44          

   \                                 In section .bss, align 4
     45          volatile static uint32_t uart_status;
   \                     uart_status:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     46          volatile static uint32_t uart_rxstatus;
   \                     uart_rxstatus:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     47          TaskHandle_t isr_uart_handle;
   \                     isr_uart_handle:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     48          QueueHandle_t uart_txwait_sem,uart_rxwait_sem,check_st_sem;
   \                     uart_txwait_sem:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \                     uart_rxwait_sem:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \                     check_st_sem:
   \        0x0                      DS8 4
     49          

   \                                 In section .bss, align 1
     50          static uint8_t seam_wait_tx,seam_wait_rx;
   \                     seam_wait_tx:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
   \                     seam_wait_rx:
   \        0x0                      DS8 1
     51          /* Global Variable for VFS DEBUG Output */
     52          static void uart_callback(LPUART_Type *base, lpuart_handle_t *handle, status_t status, void *userData)
     53          {
     54              if (kStatus_LPUART_TxIdle == status)
     55              {
     56                  uart_status = kStatus_LPUART_TxIdle;
     57          
     58              }
     59          
     60              if (kStatus_LPUART_RxIdle == status)
     61              {
     62                  uart_rxstatus = kStatus_LPUART_RxIdle;
     63          
     64              }
     65          }
     66          
     67          

   \                                 In section .text, align 2, keep-with-next
     68          int32_t HAL_Uart_rxWait(uint32_t timeout){
   \                     HAL_Uart_rxWait: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     69          #if 1
     70            TickType_t xdelay = timeout/portTICK_PERIOD_MS;
     71            volatile uint32_t tick_prev = xTaskGetTickCount();
   \        0x4   0x....'....        BL       xTaskGetTickCount
   \        0x8   0x9000             STR      R0,[SP, #+0]
     72            while(uart_rxstatus == kStatus_LPUART_RxBusy){
   \                     ??HAL_Uart_rxWait_0: (+1)
   \        0xA   0x....'....        LDR.W    R0,??DataTable16_5
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0xF240 0x5115      MOVW     R1,#+1301
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD107             BNE.N    ??HAL_Uart_rxWait_1
     73            		if(xTaskGetTickCount() - tick_prev  > xdelay){
   \       0x18   0x....'....        BL       xTaskGetTickCount
   \       0x1C   0x9900             LDR      R1,[SP, #+0]
   \       0x1E   0x1A40             SUBS     R0,R0,R1
   \       0x20   0x4284             CMP      R4,R0
   \       0x22   0xD2F2             BCS.N    ??HAL_Uart_rxWait_0
     74          
     75          			return 1;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xBD16             POP      {R1,R2,R4,PC}
     76          
     77            		}
     78            }
     79          	return 0;
   \                     ??HAL_Uart_rxWait_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     80          #else
     81          	while(uart_rxstatus == kStatus_LPUART_RxBusy){
     82          		seam_wait_rx = 1;
     83          		xSemaphoreGive(check_st_sem);
     84          		HAL_SemaphoreWait(uart_rxwait_sem,timeout);
     85          		seam_wait_rx = 0;
     86          		if(uart_rxstatus == kStatus_LPUART_RxBusy)
     87          			return -1;
     88          	}
     89          	return 0;
     90          #endif
     91          }
     92          
     93          

   \                                 In section .text, align 2, keep-with-next
     94          int32_t HAL_Uart_txWait(uint32_t timeout){
   \                     HAL_Uart_txWait: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     95          #if 1
     96              TickType_t xdelay = timeout/portTICK_PERIOD_MS;
     97            volatile uint32_t tick_prev = xTaskGetTickCount();
   \        0x4   0x....'....        BL       xTaskGetTickCount
   \        0x8   0x9000             STR      R0,[SP, #+0]
     98            while(uart_status == kStatus_LPUART_TxBusy){
   \                     ??HAL_Uart_txWait_0: (+1)
   \        0xA   0x....'....        LDR.W    R0,??DataTable16_6
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0xF240 0x5114      MOVW     R1,#+1300
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD107             BNE.N    ??HAL_Uart_txWait_1
     99                if(xTaskGetTickCount() - tick_prev  > xdelay){
   \       0x18   0x....'....        BL       xTaskGetTickCount
   \       0x1C   0x9900             LDR      R1,[SP, #+0]
   \       0x1E   0x1A40             SUBS     R0,R0,R1
   \       0x20   0x4284             CMP      R4,R0
   \       0x22   0xD2F2             BCS.N    ??HAL_Uart_txWait_0
    100          
    101          			return 1;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xBD16             POP      {R1,R2,R4,PC}
    102          
    103            		}
    104            }
    105          	return 0;
   \                     ??HAL_Uart_txWait_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    106          #else
    107          	if(uart_status == kStatus_LPUART_TxBusy){
    108          		seam_wait_tx = 1;
    109          		xSemaphoreGive(check_st_sem);
    110          		HAL_SemaphoreWait(uart_txwait_sem,timeout);
    111          		
    112          		seam_wait_tx = 0;
    113          		if(uart_status == kStatus_LPUART_TxBusy)
    114          			return -1;
    115          	}
    116          	return 0;
    117          #endif
    118          
    119          }
    120          
    121          /**
    122           * Deinitialises a UART interface
    123           *
    124           * @param[in]  uart  the interface which should be deinitialised
    125           *
    126           * @return  0 : on success, EIO : if an error occurred with any step
    127           */

   \                                 In section .text, align 2, keep-with-next
    128          int32_t HAL_AT_Uart_Deinit(uart_dev_t *uart)
    129          {
   \                     HAL_AT_Uart_Deinit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    130          	LPUART_Deinit((LPUART_Type *)s_uartBaseAddrs[uart->port]);
   \        0x2   0x....             LDR.N    R1,??DataTable16_7
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \        0xA   0x....'....        BL       LPUART_Deinit
    131          	HAL_SemaphoreDestroy(uart_rxwait_sem);
   \        0xE   0x....             LDR.N    R0,??DataTable16_8
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x....'....        BL       HAL_SemaphoreDestroy
    132          	HAL_SemaphoreDestroy(uart_txwait_sem);
   \       0x16   0x....             LDR.N    R0,??DataTable16_9
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x....'....        BL       HAL_SemaphoreDestroy
    133          	HAL_SemaphoreDestroy(check_st_sem);
   \       0x1E   0x....             LDR.N    R0,??DataTable16_10
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0x....'....        BL       HAL_SemaphoreDestroy
    134          	
    135          	return (int32_t)0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD02             POP      {R1,PC}          ;; return
    136          }
    137          

   \                                 In section .text, align 2, keep-with-next
    138          void uart2_interrupt_handle_task( void *pvParameters )
    139          {
   \                     uart2_interrupt_handle_task: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....             LDR.N    R4,??DataTable16_11
   \        0x4   0xE005             B.N      ??uart2_interrupt_handle_task_0
    140              for( ;; )
    141              {
    142                  if( seam_wait_tx || seam_wait_rx )
    143                  {
    144                  	if((uart_status == kStatus_LPUART_TxIdle)&&seam_wait_tx){
    145          				seam_wait_tx = 0;
    146          				xSemaphoreGive(uart_txwait_sem);
    147          
    148                  	}
    149          			if((uart_rxstatus == kStatus_LPUART_RxIdle)&&seam_wait_rx){
    150          				seam_wait_rx = 0;
    151          				xSemaphoreGive(uart_rxwait_sem);
    152                  	}
    153          
    154                  }else{
    155          			HAL_SemaphoreWait(check_st_sem,5000);
   \                     ??uart2_interrupt_handle_task_1: (+1)
   \        0x6   0xF241 0x3188      MOVW     R1,#+5000
   \        0xA   0x....             LDR.N    R0,??DataTable16_10
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x....'....        BL       HAL_SemaphoreWait
    156                  }
   \                     ??uart2_interrupt_handle_task_0: (+1)
   \       0x12   0x....             LDR.N    R1,??DataTable16_12
   \       0x14   0x7808             LDRB     R0,[R1, #+0]
   \       0x16   0x7822             LDRB     R2,[R4, #+0]
   \       0x18   0x4310             ORRS     R0,R2,R0
   \       0x1A   0xD0F4             BEQ.N    ??uart2_interrupt_handle_task_1
   \       0x1C   0x....             LDR.N    R0,??DataTable16_6
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0xF240 0x5216      MOVW     R2,#+1302
   \       0x24   0x4290             CMP      R0,R2
   \       0x26   0xD10B             BNE.N    ??uart2_interrupt_handle_task_2
   \       0x28   0x7808             LDRB     R0,[R1, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD008             BEQ.N    ??uart2_interrupt_handle_task_2
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x7008             STRB     R0,[R1, #+0]
   \       0x32   0x4603             MOV      R3,R0
   \       0x34   0x4602             MOV      R2,R0
   \       0x36   0x4601             MOV      R1,R0
   \       0x38   0x....             LDR.N    R0,??DataTable16_9
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0x....'....        BL       xQueueGenericSend
   \                     ??uart2_interrupt_handle_task_2: (+1)
   \       0x40   0x....             LDR.N    R0,??DataTable16_5
   \       0x42   0x6800             LDR      R0,[R0, #+0]
   \       0x44   0xF240 0x5117      MOVW     R1,#+1303
   \       0x48   0x4288             CMP      R0,R1
   \       0x4A   0xD1E2             BNE.N    ??uart2_interrupt_handle_task_0
   \       0x4C   0x7820             LDRB     R0,[R4, #+0]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD0DF             BEQ.N    ??uart2_interrupt_handle_task_0
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x7020             STRB     R0,[R4, #+0]
   \       0x56   0x4603             MOV      R3,R0
   \       0x58   0x4602             MOV      R2,R0
   \       0x5A   0x4601             MOV      R1,R0
   \       0x5C   0x....             LDR.N    R0,??DataTable16_8
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0x....'....        BL       xQueueGenericSend
   \       0x64   0xE7D5             B.N      ??uart2_interrupt_handle_task_0
    157              }
    158          }
    159          
    160          
    161          /**
    162           * Initialises a UART interface
    163           *
    164           *
    165           * @param[in]  uart  the interface which should be initialised
    166           *
    167           * @return  0 : on success, EIO : if an error occurred with any step
    168           */
    169          #define USE_LPUART_RTOS 1
    170          #if USE_LPUART_RTOS
    171          #include "fsl_lpuart_freertos.h"

   \                                 In section .bss, align 4
    172          lpuart_rtos_handle_t handle;
   \                     handle:
   \        0x0                      DS8 40
    173          

   \                                 In section .bss, align 4
    174          struct _lpuart_handle t_handle;
   \                     t_handle:
   \        0x0                      DS8 48

   \                                 In section .bss, align 4
    175          uint8_t background_buffer[512];
   \                     background_buffer:
   \        0x0                      DS8 512

   \                                 In section .data, align 4
    176          lpuart_rtos_config_t lpuart_config = {
   \                     lpuart_config:
   \        0x0   0x0000'0000        DC32 0H, 0, 115200
   \              0x0000'0000  
   \              0x0001'C200  
   \        0xC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x10   0x....'....        DC32 background_buffer, 512
   \              0x0000'0200  
    177              .baudrate    = 115200,
    178              .parity      = kLPUART_ParityDisabled,
    179              .stopbits    = kLPUART_OneStopBit,
    180              .buffer      = background_buffer,
    181              .buffer_size = sizeof(background_buffer),
    182          };
    183          #endif

   \                                 In section .text, align 2, keep-with-next
    184          int32_t HAL_AT_Uart_Init(uart_dev_t *uart)
    185          {
   \                     HAL_AT_Uart_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    186          #if USE_LPUART_RTOS
    187            lpuart_config.srcclk = BOARD_DebugConsoleSrcFreq();
                                          ^
Warning[Pe223]: function "BOARD_DebugConsoleSrcFreq" declared implicitly
   \        0x4   0x....             LDR.N    R5,??DataTable16_13
   \        0x6   0x....'....        BL       BOARD_DebugConsoleSrcFreq
   \        0xA   0x6068             STR      R0,[R5, #+4]
    188            lpuart_config.base   = (LPUART_Type *)s_uartBaseAddrs[uart->port];
   \        0xC   0x....             LDR.N    R0,??DataTable16_7
   \        0xE   0x7821             LDRB     R1,[R4, #+0]
   \       0x10   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \       0x14   0x6028             STR      R0,[R5, #+0]
    189            NVIC_SetPriority(LPUART3_IRQn,  (1<<__NVIC_PRIO_BITS) - 1);
   \       0x16   0x210F             MOVS     R1,#+15
   \       0x18   0x2016             MOVS     R0,#+22
   \       0x1A   0x....'....        BL       __NVIC_SetPriority
    190            LPUART_RTOS_Init(&handle, &t_handle, &lpuart_config);
   \       0x1E   0x462A             MOV      R2,R5
   \       0x20   0x....             LDR.N    R1,??DataTable16_14
   \       0x22   0x....             LDR.N    R0,??DataTable16_15
   \       0x24   0x....'....        BL       LPUART_RTOS_Init
    191          #else
    192          	lpuart_config_t config = {0};
    193          	status_t status;
    194          	uint8_t *addr;
    195          	size_t size;
    196          	
    197          	LPUART_GetDefaultConfig(&config);
    198          	config.baudRate_Bps = uart->config.baud_rate;
    199          	config.enableTx = true;
    200          	config.enableRx = true;
    201          
    202          	switch (uart->config.parity)
    203          	{
    204          		case NO_PARITY:
    205          			config.parityMode = kLPUART_ParityDisabled;
    206          			break;
    207          		case ODD_PARITY:
    208          			config.parityMode = kLPUART_ParityOdd;
    209          			break;
    210          		case EVEN_PARITY:
    211          			config.parityMode = kLPUART_ParityEven;
    212          			break;
    213          		default:
    214          			return EIO;
    215          	}
    216          
    217          	switch (uart->config.data_width)
    218          	{
    219          #if defined(FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT) && FSL_FEATURE_LPUART_HAS_7BIT_DATA_SUPPORT
    220          		case DATA_WIDTH_7BIT:
    221          			config.dataBitsCount = kLPUART_SevenDataBits;
    222          			break;
    223          #endif
    224          		case DATA_WIDTH_8BIT:
    225          			config.dataBitsCount = kLPUART_EightDataBits;
    226          			break;
    227          		default:
    228          			return EIO;
    229          	}
    230          
    231          	switch (uart->config.stop_bits)
    232          	{
    233          		case STOP_BITS_1:
    234          			config.stopBitCount = kLPUART_OneStopBit;
    235          			break;
    236          		case STOP_BITS_2:
    237          			config.stopBitCount = kLPUART_TwoStopBit;
    238          			break;
    239          		default:
    240          			return EIO;
    241          	}
    242          	
    243          	/* TODO: Need to have array to save clock source for all uart instances */
    244          	uint32_t freq = 0;
    245          	freq = BOARD_DebugConsoleSrcFreq();
    246          	status = LPUART_Init((LPUART_Type *)s_uartBaseAddrs[uart->port], &config, freq);
    247          	
    248          	if (kStatus_Success != status)
    249          		return EIO;
    250          	
    251          
    252          	/* Create handle for LPUART */
    253          	LPUART_TransferCreateHandle((LPUART_Type *)s_uartBaseAddrs[uart->port], &s_handle[uart->port],
    254          								uart_callback, uart);
    255          
    256          	if (uart->port == 2){
    257          
    258          		size = 512;
    259          		addr = HAL_Malloc(size);
    260          		if (addr != NULL){
    261          		    LPUART_TransferStartRingBuffer((LPUART_Type *)s_uartBaseAddrs[uart->port], &s_handle[uart->port],
    262          		                                    addr, size);
    263          		}else{
    264          		    return -1;
    265          		}
    266          	}
    267                  
    268          #if 1
    269                  
    270          #else
    271          	xTaskCreate(
    272                            uart2_interrupt_handle_task,       /* Function that implements the task. */
    273                            "u2_isr_handle",          /* Text name for the task. */
    274                            256,      /* Stack size in words, not bytes. */
    275                            NULL,    /* Parameter passed into the task. */
    276                            (0),/* Priority at which the task is created. */
    277                            &isr_uart_handle);      /* Used to pass out the created task's handle. */
    278          	uart_rxwait_sem = HAL_SemaphoreCreate();
    279          	uart_txwait_sem = HAL_SemaphoreCreate();
    280          	check_st_sem = HAL_SemaphoreCreate();
    281                  
    282          #endif
    283          #endif
    284          	return 0;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    285          }
    286          
    287          
    288          /**
    289           * Receive data on a UART interface
    290           *
    291           * @param[in]   uart         the UART interface
    292           * @param[out]  data         pointer to the buffer which will store incoming data
    293           * @param[in]   expect_size  number of bytes to receive
    294           * @param[out]  recv_size    number of bytes received
    295           * @param[in]   timeout      timeout in milisecond, set this value to HAL_WAIT_FOREVER
    296           *                           if you want to wait forever
    297           *
    298           * @return  0 : on success, EIO : if an error occurred with any step
    299           */

   \                                 In section .text, align 2, keep-with-next
    300          int32_t HAL_AT_Uart_Recv(uart_dev_t *uart, void *data, uint32_t expect_size,
    301                                   uint32_t *recv_size, uint32_t timeout)
    302          {
   \                     HAL_AT_Uart_Recv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x9802             LDR      R0,[SP, #+8]
    303            #if USE_LPUART_RTOS
    304            int ret = LPUART_RTOS_Receive(&handle, data, expect_size, recv_size,timeout/portTICK_PERIOD_MS);
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x....             LDR.N    R0,??DataTable16_15
   \        0x8   0x....'....        BL       LPUART_RTOS_Receive
    305            if(ret != 0){
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD000             BEQ.N    ??HAL_AT_Uart_Recv_0
    306          	ret = EIO;
   \       0x10   0x2005             MOVS     R0,#+5
    307            }
    308            return ret;
   \                     ??HAL_AT_Uart_Recv_0: (+1)
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
    309          #else
    310          	if(uart_rxstatus == kStatus_LPUART_RxBusy){
    311          			return EIO;
    312          		}
    313          
    314          	lpuart_transfer_t xfer;
    315              int32_t ret = 0;
    316              LPUART_Type *uartBase = (LPUART_Type *)s_uartBaseAddrs[uart->port];
    317              lpuart_handle_t *handle = &s_handle[uart->port];
    318          
    319              if (timeout == 0)
    320              {
    321                  timeout = 1000;
    322              }
    323          
    324              xfer.data = (uint8_t *)data;
    325              xfer.dataSize = expect_size;
    326          	uart_rxstatus = kStatus_LPUART_RxBusy;
    327              if (kStatus_Success != LPUART_TransferReceiveNonBlocking(uartBase, handle, &xfer, recv_size))
    328              {
    329          		uart_rxstatus = kStatus_LPUART_RxIdle;
    330                  return EIO;
    331              }
    332          	
    333          
    334          
    335          
    336              if (HAL_Uart_rxWait(timeout) != 0)
    337              {
    338                  LPUART_TransferAbortReceive(uartBase, handle);
    339          		uart_rxstatus = kStatus_LPUART_RxIdle;
    340          
    341                  *recv_size = 0;
    342          
    343                  ret = EIO;
    344              }
    345              else
    346              {
    347                  *recv_size = expect_size;
    348              }
    349            return ret;
    350          #endif
    351             
    352          }
    353          
    354          /**
    355           * Transmit data on a UART interface
    356           *
    357           * @param[in]  uart     the UART interface
    358           * @param[in]  data     pointer to the start of data
    359           * @param[in]  size     number of bytes to transmit
    360           * @param[in]  timeout  timeout in milisecond, set this value to HAL_WAIT_FOREVER
    361           *                      if you want to wait forever
    362           *
    363           * @return  0 : on success, EIO : if an error occurred with any step
    364           */

   \                                 In section .text, align 2, keep-with-next
    365          int32_t HAL_AT_Uart_Send(uart_dev_t *uart, const void *data, uint32_t size, uint32_t timeout)
    366          {
   \                     HAL_AT_Uart_Send: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    367            #if USE_LPUART_RTOS
    368            if (timeout == 0)
   \        0x2   0x2B00             CMP      R3,#+0
   \        0x4   0xD101             BNE.N    ??HAL_AT_Uart_Send_0
    369            {
    370          	  timeout = 1000;
   \        0x6   0xF44F 0x737A      MOV      R3,#+1000
    371            }
    372            int ret = 0;
    373            ret = LPUART_RTOS_Send(&handle, (uint8_t *)data, size,timeout/portTICK_PERIOD_MS);
   \                     ??HAL_AT_Uart_Send_0: (+1)
   \        0xA   0x....             LDR.N    R0,??DataTable16_15
   \        0xC   0x....'....        BL       LPUART_RTOS_Send
    374            if(ret != 0){
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD000             BEQ.N    ??HAL_AT_Uart_Send_1
    375          	
    376          
    377          	ret = EIO;
   \       0x14   0x2005             MOVS     R0,#+5
    378          
    379            }
    380            return ret;
   \                     ??HAL_AT_Uart_Send_1: (+1)
   \       0x16   0xBD02             POP      {R1,PC}          ;; return
    381          #else
    382          	if(uart_status == kStatus_LPUART_TxBusy){
    383          		return EIO;
    384          	}
    385          	lpuart_transfer_t xfer;
    386              int32_t ret = 0;
    387              LPUART_Type *uartBase = (LPUART_Type *)s_uartBaseAddrs[uart->port];
    388              lpuart_handle_t *handle = &s_handle[uart->port];
    389          
    390              if (timeout == 0)
    391              {
    392                  timeout = 1000;
    393              }
    394          
    395          
    396          
    397              if (size < UART_TX_INT_THRESHOLD)
    398              {
    399                  LPUART_WriteBlocking(uartBase, (uint8_t *)data, size);
    400              }
    401              else
    402              {
    403                  xfer.data = (uint8_t *)data;
    404                  
    405                  xfer.dataSize = size;
    406          		uart_status = kStatus_LPUART_TxBusy;
    407                  LPUART_TransferSendNonBlocking(uartBase, handle, &xfer);
    408                  /* Wait for transfer finish */
    409                 
    410                  if (HAL_Uart_txWait(timeout) != 0)
    411                  {
    412                      LPUART_TransferAbortSend(uartBase, handle);
    413          			uart_status = kStatus_LPUART_TxIdle;
    414          
    415                      ret = EIO;
    416                  }
    417              }
    418          
    419          
    420              return ret;
    421          #endif
    422          }
    423          /**
    424           * @brief Deallocate memory block
    425           *
    426           * @param[in] ptr @n Pointer to a memory block previously allocated with platform_malloc.
    427           * @return None.
    428           * @see None.
    429           * @note None.
    430           */

   \                                 In section .text, align 2, keep-with-next
    431          void HAL_Free(void *ptr)
    432          {
    433          	vPortFree(ptr);
   \                     HAL_Free: (+1)
   \        0x0   0x....'....        B.W      vPortFree
    434          }
    435          
    436          
    437          /**
    438           * @brief Get device name from user's system persistent storage
    439           *
    440           * @param [ou] device_name: array to store device name, max length is IOTX_DEVICE_NAME_LEN
    441           * @return the actual length of device name
    442           */

   \                                 In section .text, align 2, keep-with-next
    443          int HAL_GetDeviceName(char device_name[IOTX_DEVICE_NAME_LEN + 1])
    444          {
   \                     HAL_GetDeviceName: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    445          
    446          	if(strlen(DEVICE_NAME_D) <= IOTX_DEVICE_NAME_LEN){
    447                          memset(device_name, 0x0, IOTX_DEVICE_NAME_LEN);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2120             MOVS     R1,#+32
   \        0x8   0x....'....        BL       __aeabi_memset
    448          		strncpy(device_name, DEVICE_NAME_D, strlen(DEVICE_NAME_D));
   \        0xC   0x220E             MOVS     R2,#+14
   \        0xE   0x....             LDR.N    R1,??DataTable16_16
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       strncpy
    449          		return (int)strlen(device_name);
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1C   0x....'....        B.W      strlen
    450          	}else{
    451          
    452          		return -1;
    453          	}
    454          }
    455          
    456          
    457          /**
    458           * @brief Get device secret from user's system persistent storage
    459           *
    460           * @param [ou] device_secret: array to store device secret, max length is IOTX_DEVICE_SECRET_LEN
    461           * @return the actual length of device secret
    462           */

   \                                 In section .text, align 2, keep-with-next
    463          int HAL_GetDeviceSecret(char device_secret[IOTX_DEVICE_SECRET_LEN + 1])
    464          {
   \                     HAL_GetDeviceSecret: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    465          	if(strlen(DEVICE_SECRET_D) <= IOTX_DEVICE_SECRET_LEN){
    466                          memset(device_secret, 0x0, IOTX_DEVICE_SECRET_LEN);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2140             MOVS     R1,#+64
   \        0x8   0x....'....        BL       __aeabi_memset
    467          		strncpy(device_secret, DEVICE_SECRET_D, strlen(DEVICE_SECRET_D));
   \        0xC   0x2220             MOVS     R2,#+32
   \        0xE   0x....             LDR.N    R1,??DataTable16_17
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       strncpy
    468          		return (int)strlen(DEVICE_SECRET_D);
   \       0x16   0x2020             MOVS     R0,#+32
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    469          	}else{
    470          
    471          		return -1;
    472          	}
    473          }
    474          
    475          
    476          /**
    477           * @brief Get firmware version
    478           *
    479           * @param [ou] version: array to store firmware version, max length is IOTX_FIRMWARE_VER_LEN
    480           * @return the actual length of firmware version
    481           */

   \                                 In section .text, align 2, keep-with-next
    482          int HAL_GetFirmwareVersion(char *version)
    483          {
   \                     HAL_GetFirmwareVersion: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    484          	if(strlen(FIRMWARE_VER_D) <= IOTX_FIRMWARE_VER_LEN){
    485                          memset(version, 0x0, IOTX_FIRMWARE_VER_LEN);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2120             MOVS     R1,#+32
   \        0x8   0x....'....        BL       __aeabi_memset
    486          		strncpy(version, FIRMWARE_VER_D, strlen(FIRMWARE_VER_D));
   \        0xC   0x2205             MOVS     R2,#+5
   \        0xE   0x....             LDR.N    R1,??DataTable16_18
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       strncpy
    487          		version[strlen(FIRMWARE_VER_D)] = '\0';
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x7160             STRB     R0,[R4, #+5]
    488          		return (int)strlen(version);
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x20   0x....'....        B.W      strlen
    489          	}else{
    490          		return -1;
    491          	}
    492          }
    493          
    494          
    495          /**
    496           * @brief Get product key from user's system persistent storage
    497           *
    498           * @param [ou] product_key: array to store product key, max length is IOTX_PRODUCT_KEY_LEN
    499           * @return  the actual length of product key
    500           */

   \                                 In section .text, align 2, keep-with-next
    501          int HAL_GetProductKey(char product_key[IOTX_PRODUCT_KEY_LEN + 1])
    502          {
   \                     HAL_GetProductKey: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    503          	if(strlen(PRODUCT_KEY_D) <= IOTX_PRODUCT_KEY_LEN){
    504                          memset(product_key, 0x0, IOTX_PRODUCT_KEY_LEN);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2114             MOVS     R1,#+20
   \        0x8   0x....'....        BL       __aeabi_memset
    505          		strncpy(product_key, PRODUCT_KEY_D, strlen(PRODUCT_KEY_D));
   \        0xC   0x220B             MOVS     R2,#+11
   \        0xE   0x....             LDR.N    R1,??DataTable16_19
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       strncpy
    506          
    507          		return (int)strlen(PRODUCT_KEY_D);
   \       0x16   0x200B             MOVS     R0,#+11
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    508          	}else{
    509          		return -1;
    510          	}
    511          }
    512          
    513          

   \                                 In section .text, align 2, keep-with-next
    514          int HAL_GetProductSecret(char product_secret[IOTX_PRODUCT_SECRET_LEN + 1])
    515          {
   \                     HAL_GetProductSecret: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    516          	if(sizeof(PRODUCT_SECRET_D) <= IOTX_PRODUCT_SECRET_LEN){
    517                          memset(product_secret, 0x0, IOTX_PRODUCT_SECRET_LEN);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2140             MOVS     R1,#+64
   \        0x8   0x....'....        BL       __aeabi_memset
    518          		strncpy(product_secret, PRODUCT_SECRET_D, strlen(PRODUCT_SECRET_D));
   \        0xC   0x2210             MOVS     R2,#+16
   \        0xE   0x....             LDR.N    R1,??DataTable16_20
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       strncpy
    519          
    520          		return (int)strlen(PRODUCT_SECRET_D);
   \       0x16   0x2010             MOVS     R0,#+16
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    521          	}else{
    522          		return -1;
    523          	}
    524          }
    525          

   \                                 In section .text, align 2, keep-with-next
    526          int HAL_Kv_Get(const char *key, void *val, int *buffer_len)
    527          {
    528              return kv_item_get(key, val, buffer_len);
                            ^
Warning[Pe223]: function "kv_item_get" declared implicitly
   \                     HAL_Kv_Get: (+1)
   \        0x0   0x....'....        B.W      kv_item_get
    529          }
    530          

   \                                 In section .text, align 2, keep-with-next
    531          int HAL_Kv_Set(const char *key, const void *val, int len, int sync)
    532          {  
    533              return kv_item_set(key, val, len);
                            ^
Warning[Pe223]: function "kv_item_set" declared implicitly

  static void uart_callback(LPUART_Type *base, lpuart_handle_t *handle, status_t status, void *userData)
              ^
"C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\wrapper.c",52  Warning[Pe177]: 
          function "uart_callback" was declared but never referenced
   \                     HAL_Kv_Set: (+1)
   \        0x0   0x....'....        B.W      kv_item_set
    534          }
    535          /**
    536           * @brief Allocates a block of size bytes of memory, returning a pointer to the beginning of the block.
    537           *
    538           * @param [in] size @n specify block size in bytes.
    539           * @return A pointer to the beginning of the block.
    540           * @see None.
    541           * @note Block value is indeterminate.
    542           */

   \                                 In section .text, align 2, keep-with-next
    543          void *HAL_Malloc(uint32_t size)
    544          {
    545          	return ((void *)pvPortMalloc(size));
   \                     HAL_Malloc: (+1)
   \        0x0   0x....'....        B.W      pvPortMalloc
    546          }
    547          
    548          
    549          /**
    550           * @brief Create a mutex.
    551           *
    552           * @retval NULL : Initialize mutex failed.
    553           * @retval NOT_NULL : The mutex handle.
    554           * @see None.
    555           * @note None.
    556           */

   \                                 In section .text, align 2, keep-with-next
    557          void *HAL_MutexCreate(void)
    558          {
   \                     HAL_MutexCreate: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    559                QueueHandle_t sem;
    560          
    561              sem = (QueueHandle_t)xSemaphoreCreateMutex();
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x....'....        BL       xQueueCreateMutex
    562              if (0 == sem) {
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD100             BNE.N    ??HAL_MutexCreate_0
    563                return NULL;
   \        0xC   0x2000             MOVS     R0,#+0
    564              }
    565          
    566              return sem;
   \                     ??HAL_MutexCreate_0: (+1)
   \        0xE   0xBD02             POP      {R1,PC}          ;; return
    567          }
    568          
    569          
    570          /**
    571           * @brief Destroy the specified mutex object, it will release related resource.
    572           *
    573           * @param [in] mutex @n The specified mutex.
    574           * @return None.
    575           * @see None.
    576           * @note None.
    577           */

   \                                 In section .text, align 2, keep-with-next
    578          void HAL_MutexDestroy(void *mutex)
    579          {
    580          	QueueHandle_t sem;
    581              if (mutex == NULL) {
   \                     HAL_MutexDestroy: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??HAL_MutexDestroy_0
    582                  return;
    583              }
    584              sem = (QueueHandle_t)mutex;
    585              vSemaphoreDelete(sem);
   \        0x4   0x....'....        B.W      vQueueDelete
   \                     ??HAL_MutexDestroy_0: (+1)
   \        0x8   0x4770             BX       LR               ;; return
    586          }
    587          
    588          
    589          /**
    590           * @brief Waits until the specified mutex is in the signaled state.
    591           *
    592           * @param [in] mutex @n the specified mutex.
    593           * @return None.
    594           * @see None.
    595           * @note None.
    596           */

   \                                 In section .text, align 2, keep-with-next
    597          void HAL_MutexLock(void *mutex)
    598          {
   \                     HAL_MutexLock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    599          	BaseType_t ret;
    600              QueueHandle_t sem;
    601              if (mutex == NULL) {
   \        0x4   0xD00B             BEQ.N    ??HAL_MutexLock_0
    602                  return;
    603              }
    604          
    605              sem = (QueueHandle_t)mutex;
    606              ret = xSemaphoreTake(sem, 0xffffffff);
   \        0x6   0xF04F 0x31FF      MOV      R1,#-1
   \        0xA   0x....'....        BL       xQueueSemaphoreTake
   \        0xE   0xE004             B.N      ??HAL_MutexLock_1
    607              while (pdPASS != ret) {
    608                  ret = xSemaphoreTake(sem, 0xffffffff);
   \                     ??HAL_MutexLock_2: (+1)
   \       0x10   0xF04F 0x31FF      MOV      R1,#-1
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       xQueueSemaphoreTake
    609              }
   \                     ??HAL_MutexLock_1: (+1)
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD1F8             BNE.N    ??HAL_MutexLock_2
    610          }
   \                     ??HAL_MutexLock_0: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
    611          
    612          
    613          /**
    614           * @brief Releases ownership of the specified mutex object..
    615           *
    616           * @param [in] mutex @n the specified mutex.
    617           * @return None.
    618           * @see None.
    619           * @note None.
    620           */

   \                                 In section .text, align 2, keep-with-next
    621          void HAL_MutexUnlock(void *mutex)
    622          {
    623          	QueueHandle_t sem;
    624              if (mutex == NULL) {
   \                     HAL_MutexUnlock: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD004             BEQ.N    ??HAL_MutexUnlock_0
    625                  return;
    626              }
    627              sem = (QueueHandle_t)mutex;
    628              (void)xSemaphoreGive(sem);
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x461A             MOV      R2,R3
   \        0x8   0x4611             MOV      R1,R2
   \        0xA   0x....'....        B.W      xQueueGenericSend
   \                     ??HAL_MutexUnlock_0: (+1)
   \        0xE   0x4770             BX       LR               ;; return
    629          }
    630          
    631          
    632          /**
    633           * @brief Writes formatted data to stream.
    634           *
    635           * @param [in] fmt: @n String that contains the text to be written, it can optionally contain embedded format specifiers
    636               that specifies how subsequent arguments are converted for output.
    637           * @param [in] ...: @n the variable argument list, for formatted and inserted in the resulting string replacing their respective specifiers.
    638           * @return None.
    639           * @see None.
    640           * @note None.
    641           */
    642           #if 0
    643          void HAL_Printf(const char *fmt, ...)
    644          {
    645                  va_list args;
    646                  va_start(args, fmt);
    647                  format_printf(fmt,args);
    648                  va_end(args);
    649          	return;
    650          }
    651          #endif
    652          

   \                                 In section .text, align 2, keep-with-next
    653          uint32_t HAL_Random(uint32_t region)
    654          {
   \                     HAL_Random: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    655              uint32_t rand = 0xffffffff;
   \        0x4   0xF04F 0x30FF      MOV      R0,#-1
   \        0x8   0x9000             STR      R0,[SP, #+0]
    656              
    657              TRNG_GetRandomData(TRNG, (void *)&rand, 1);
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0x4669             MOV      R1,SP
   \        0xE   0x....             LDR.N    R0,??DataTable16_21  ;; 0x400cc000
   \       0x10   0x....'....        BL       TRNG_GetRandomData
    658                  
    659          	return (rand%region);
   \       0x14   0x9800             LDR      R0,[SP, #+0]
   \       0x16   0x4601             MOV      R1,R0
   \       0x18   0xFBB1 0xF1F4      UDIV     R1,R1,R4
   \       0x1C   0xFB04 0x0411      MLS      R4,R4,R1,R0
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    660          }
    661          /**
    662           * @brief Sleep thread itself.
    663           *
    664           * @param [in] ms @n the time interval for which execution is to be suspended, in milliseconds.
    665           * @return None.
    666           * @see None.
    667           * @note None.
    668           */

   \                                 In section .text, align 2, keep-with-next
    669          void HAL_SleepMs(uint32_t ms)
    670          {
    671          	const TickType_t xdelay = ms/portTICK_PERIOD_MS;
    672          	vTaskDelay(xdelay);
   \                     HAL_SleepMs: (+1)
   \        0x0   0x....'....        B.W      vTaskDelay
    673              //uint32_t current_tick = xTaskGetTickCount();
    674          	//uint32_t anchor = current_tick + ms;
    675               //   uint32_t loopb = 0xffffffff;
    676                //  while(loopb--);
    677          	//while((anchor - current_tick>0) && (anchor - current_tick < 0xffffff)){
    678                   // current_tick = xTaskGetTickCount();
    679                  //}
    680          }
    681          
    682          
    683          /**
    684           * @brief Writes formatted data to string.
    685           *
    686           * @param [out] str: @n String that holds written text.
    687           * @param [in] len: @n Maximum length of character will be written
    688           * @param [in] fmt: @n Format that contains the text to be written, it can optionally contain embedded format specifiers
    689               that specifies how subsequent arguments are converted for output.
    690           * @param [in] ...: @n the variable argument list, for formatted and inserted in the resulting string replacing their respective specifiers.
    691           * @return bytes of character successfully written into string.
    692           * @see None.
    693           * @note None.
    694           */

   \                                 In section .text, align 2, keep-with-next
    695          int HAL_Snprintf(char *str, const int len, const char *fmt, ...)
    696          {
   \                     HAL_Snprintf: (+1)
   \        0x0   0xB408             PUSH     {R3}
   \        0x2   0xB500             PUSH     {LR}
    697          	va_list args;
    698          	int rc;
    699          
    700          	va_start(args, fmt);
   \        0x4   0xAB01             ADD      R3,SP,#+4
    701          	rc = vsnprintf(str, len, fmt, args);
    702          	va_end(args);
    703          	return rc;
   \        0x6   0x....'....        BL       vsnprintf
   \        0xA   0xF85D 0xFB08      LDR      PC,[SP], #+8     ;; return
    704          
    705          
    706          }
    707          
    708          

   \                                 In section .text, align 2, keep-with-next
    709          void HAL_Srandom(uint32_t seed)
    710          {
   \                     HAL_Srandom: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_22
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD000             BEQ.N    ??HAL_Srandom_0
   \        0x8   0x4770             BX       LR
   \                     ??HAL_Srandom_0: (+1)
   \        0xA   0xB500             PUSH     {LR}
   \        0xC   0xB095             SUB      SP,SP,#+84
    711          	if (!srandom_inited){
    712          	
    713          		trng_config_t trngConfig;
    714          		/* Initialize TRNG configuration structure to default.*/
    715          		/*
    716          		 * trngConfig.lock = TRNG_USER_CONFIG_DEFAULT_LOCK;
    717          		 * trngConfig.clockMode = kTRNG_ClockModeRingOscillator;
    718          		 * trngConfig.ringOscDiv = TRNG_USER_CONFIG_DEFAULT_OSC_DIV;
    719          		 * trngConfig.sampleMode = kTRNG_SampleModeRaw;
    720          		 * trngConfig.entropyDelay = TRNG_USER_CONFIG_DEFAULT_ENTROPY_DELAY;
    721          		 * trngConfig.sampleSize = TRNG_USER_CONFIG_DEFAULT_SAMPLE_SIZE;
    722          		 * trngConfig.sparseBitLimit = TRNG_USER_CONFIG_DEFAULT_SPARSE_BIT_LIMIT;
    723          		 * trngConfig.retryCount = TRNG_USER_CONFIG_DEFAULT_RETRY_COUNT;
    724          		 * trngConfig.longRunMaxLimit = TRNG_USER_CONFIG_DEFAULT_RUN_MAX_LIMIT;
    725          		 * trngConfig.monobitLimit.maximum = TRNG_USER_CONFIG_DEFAULT_MONOBIT_MAXIMUM;
    726          		 * trngConfig.monobitLimit.minimum = TRNG_USER_CONFIG_DEFAULT_MONOBIT_MINIMUM;
    727          		 * trngConfig.runBit1Limit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT1_MAXIMUM;
    728          		 * trngConfig.runBit1Limit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT1_MINIMUM;
    729          		 * trngConfig.runBit2Limit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT2_MAXIMUM;
    730          		 * trngConfig.runBit2Limit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT2_MINIMUM;
    731          		 * trngConfig.runBit3Limit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT3_MAXIMUM;
    732          		 * trngConfig.runBit3Limit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT3_MINIMUM;
    733          		 * trngConfig.runBit4Limit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT4_MAXIMUM;
    734          		 * trngConfig.runBit4Limit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT4_MINIMUM;
    735          		 * trngConfig.runBit5Limit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT5_MAXIMUM;
    736          		 * trngConfig.runBit5Limit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT5_MINIMUM;
    737          		 * trngConfig.runBit6PlusLimit.maximum = TRNG_USER_CONFIG_DEFAULT_RUNBIT6PLUS_MAXIMUM;
    738          		 * trngConfig.runBit6PlusLimit.minimum = TRNG_USER_CONFIG_DEFAULT_RUNBIT6PLUS_MINIMUM;
    739          		 * trngConfig.pokerLimit.maximum = TRNG_USER_CONFIG_DEFAULT_POKER_MAXIMUM;
    740          		 * trngConfig.pokerLimit.minimum = TRNG_USER_CONFIG_DEFAULT_POKER_MINIMUM;
    741          		 * trngConfig.frequencyCountLimit.maximum = TRNG_USER_CONFIG_DEFAULT_FREQUENCY_MAXIMUM;
    742          		 * trngConfig.frequencyCountLimit.minimum = TRNG_USER_CONFIG_DEFAULT_FREQUENCY_MINIMUM;
    743          		 */
    744          		TRNG_GetDefaultConfig(&trngConfig);
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x....'....        BL       TRNG_GetDefaultConfig
    745          		/* Set sample mode of the TRNG ring oscillator to Von Neumann, for better random data.*/
    746          		trngConfig.sampleMode = kTRNG_SampleModeVonNeumann;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF88D 0x0003      STRB     R0,[SP, #+3]
    747          		/* Initialize TRNG */
    748          		TRNG_Init(TRNG, &trngConfig);
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x....             LDR.N    R0,??DataTable16_21  ;; 0x400cc000
   \       0x1E   0x....'....        BL       TRNG_Init
    749          	}
    750          
    751          	return;
   \       0x22   0xB015             ADD      SP,SP,#+84
   \       0x24   0xBD00             POP      {PC}             ;; return
    752          }
    753          
    754          /**
    755           * @brief   create a semaphore
    756           *
    757           * @return semaphore handle.
    758           * @see None.
    759           * @note The recommended value of maximum count of the semaphore is 255.
    760           */

   \                                 In section .text, align 2, keep-with-next
    761          void *HAL_SemaphoreCreate(void)
    762          {
   \                     HAL_SemaphoreCreate: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    763          	QueueHandle_t sem = 0;
    764              sem = (QueueHandle_t)xSemaphoreCreateCounting(10, 0);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x200A             MOVS     R0,#+10
   \        0x6   0x....'....        BL       xQueueCreateCountingSemaphore
    765              if (0 == sem) {
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD100             BNE.N    ??HAL_SemaphoreCreate_0
    766                  return NULL;
   \        0xE   0x2000             MOVS     R0,#+0
    767              }
    768          
    769              return sem;
   \                     ??HAL_SemaphoreCreate_0: (+1)
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
    770          }
    771          
    772          
    773          /**
    774           * @brief   destory a semaphore
    775           *
    776           * @param[in] sem @n the specified sem.
    777           * @return None.
    778           * @see None.
    779           * @note None.
    780           */

   \                                 In section .text, align 2, keep-with-next
    781          void HAL_SemaphoreDestroy(void *sem)
    782          {
    783          	QueueHandle_t queue;
    784          
    785              if (sem == NULL) {
   \                     HAL_SemaphoreDestroy: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD001             BEQ.N    ??HAL_SemaphoreDestroy_0
    786                  return;
    787              }
    788              queue = (QueueHandle_t)sem;
    789          
    790              vSemaphoreDelete(queue);
   \        0x4   0x....'....        B.W      vQueueDelete
   \                     ??HAL_SemaphoreDestroy_0: (+1)
   \        0x8   0x4770             BX       LR               ;; return
    791          }
    792          
    793          
    794          /**
    795           * @brief   signal thread wait on a semaphore
    796           *
    797           * @param[in] sem @n the specified semaphore.
    798           * @return None.
    799           * @see None.
    800           * @note None.
    801           */

   \                                 In section .text, align 2, keep-with-next
    802          void HAL_SemaphorePost(void *sem)
    803          {
    804          	QueueHandle_t queue;
    805              if (sem == NULL) {
   \                     HAL_SemaphorePost: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD004             BEQ.N    ??HAL_SemaphorePost_0
    806                  return;
    807              }
    808              queue = (QueueHandle_t)sem;
    809              (void)xSemaphoreGive(queue);
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x461A             MOV      R2,R3
   \        0x8   0x4611             MOV      R1,R2
   \        0xA   0x....'....        B.W      xQueueGenericSend
   \                     ??HAL_SemaphorePost_0: (+1)
   \        0xE   0x4770             BX       LR               ;; return
    810          }
    811          /**
    812           * @brief   wait on a semaphore
    813           *
    814           * @param[in] sem @n the specified semaphore.
    815           * @param[in] timeout_ms @n timeout interval in millisecond.
    816               If timeout_ms is PLATFORM_WAIT_INFINITE, the function will return only when the semaphore is signaled.
    817           * @return
    818             @verbatim
    819             =  0: The state of the specified object is signaled.
    820             =  -1: The time-out interval elapsed, and the object's state is nonsignaled.
    821             @endverbatim
    822           * @see None.
    823           * @note None.
    824           */

   \                                 In section .text, align 2, keep-with-next
    825          int HAL_SemaphoreWait(void *sem, uint32_t timeout_ms)
    826          {
   \                     HAL_SemaphoreWait: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    827          	BaseType_t ret = 0;
    828              QueueHandle_t queue;
    829              if (sem == NULL) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD102             BNE.N    ??HAL_SemaphoreWait_0
    830                  return -1;
   \        0x6   0xF04F 0x30FF      MOV      R0,#-1
   \        0xA   0xBD02             POP      {R1,PC}
    831              }
    832          
    833              queue = (QueueHandle_t)sem;
    834              ret = xSemaphoreTake(queue, timeout_ms/portTICK_PERIOD_MS);
    835              if (pdPASS != ret) {
   \                     ??HAL_SemaphoreWait_0: (+1)
   \        0xC   0x....'....        BL       xQueueSemaphoreTake
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD002             BEQ.N    ??HAL_SemaphoreWait_1
    836                  return -1;
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xBD02             POP      {R1,PC}
    837              }
    838              return 0;
   \                     ??HAL_SemaphoreWait_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD02             POP      {R1,PC}          ;; return
    839          }
    840          
    841          /**
    842           * @brief  create a thread
    843           *
    844           * @param[out] thread_handle @n The new thread handle, memory allocated before thread created and return it, free it after thread joined or exit.
    845           * @param[in] start_routine @n A pointer to the application-defined function to be executed by the thread.
    846                  This pointer represents the starting address of the thread.
    847           * @param[in] arg @n A pointer to a variable to be passed to the start_routine.
    848           * @param[in] hal_os_thread_param @n A pointer to stack params.
    849           * @param[out] stack_used @n if platform used stack buffer, set stack_used to 1, otherwise set it to 0.
    850           * @return
    851             @verbatim
    852               = 0: on success.
    853               = -1: error occur.
    854             @endverbatim
    855           * @see None.
    856           * @note None.
    857           */
    858           #ifndef DEFAULT_THREAD_NAME
    859           #define DEFAULT_THREAD_NAME "wrapper_"
    860           #define TASK_STACK_ALIGN_SIZE 4u
    861           #endif
    862           

   \                                 In section .text, align 2, keep-with-next
    863          int HAL_ThreadCreate(
    864                      void **thread_handle,
    865                      void *(*work_routine)(void *),
    866                      void *arg,
    867                      hal_os_thread_param_t *hal_os_thread_param,
    868                      int *stack_used)
    869          {
   \                     HAL_ThreadCreate: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    870            
    871          
    872          	char *name;
    873              size_t stacksize;
    874          
    875              if (thread_handle == NULL) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD102             BNE.N    ??HAL_ThreadCreate_0
    876                  return -1;
   \        0xA   0xF04F 0x30FF      MOV      R0,#-1
   \        0xE   0xBD76             POP      {R1,R2,R4-R6,PC}
    877              }
    878          
    879              if (work_routine == NULL) {
   \                     ??HAL_ThreadCreate_0: (+1)
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0xD102             BNE.N    ??HAL_ThreadCreate_1
    880                  return -1;
   \       0x14   0xF04F 0x30FF      MOV      R0,#-1
   \       0x18   0xBD76             POP      {R1,R2,R4-R6,PC}
    881              }
    882          
    883              if (hal_os_thread_param == NULL) {
   \                     ??HAL_ThreadCreate_1: (+1)
   \       0x1A   0x2B00             CMP      R3,#+0
   \       0x1C   0xD102             BNE.N    ??HAL_ThreadCreate_2
    884                  return -1;
   \       0x1E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x22   0xBD76             POP      {R1,R2,R4-R6,PC}
    885              }
   \                     ??HAL_ThreadCreate_2: (+1)
   \       0x24   0x9806             LDR      R0,[SP, #+24]
    886              if (stack_used == NULL) {
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD102             BNE.N    ??HAL_ThreadCreate_3
    887                  return -1;
   \       0x2A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x2E   0xBD76             POP      {R1,R2,R4-R6,PC}
    888              }
    889          
    890              if (stack_used != NULL) {
   \                     ??HAL_ThreadCreate_3: (+1)
   \       0x30   0xD001             BEQ.N    ??HAL_ThreadCreate_4
    891                  *stack_used = 0;
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x6001             STR      R1,[R0, #+0]
    892              }
    893          
    894              if (!hal_os_thread_param->name) {
   \                     ??HAL_ThreadCreate_4: (+1)
   \       0x36   0x6918             LDR      R0,[R3, #+16]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD101             BNE.N    ??HAL_ThreadCreate_5
    895                  name = DEFAULT_THREAD_NAME;
   \       0x3C   0x....             LDR.N    R1,??DataTable16_23
   \       0x3E   0xE000             B.N      ??HAL_ThreadCreate_6
    896              } else {
    897                  name = hal_os_thread_param->name;
   \                     ??HAL_ThreadCreate_5: (+1)
   \       0x40   0x4601             MOV      R1,R0
    898              }
    899          
    900              if (hal_os_thread_param->stack_size == 0) {
   \                     ??HAL_ThreadCreate_6: (+1)
   \       0x42   0x6898             LDR      R0,[R3, #+8]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD101             BNE.N    ??HAL_ThreadCreate_7
    901                  stacksize = configMINIMAL_STACK_SIZE;
   \       0x48   0xF44F 0x7080      MOV      R0,#+256
    902              } else {
    903                  stacksize = hal_os_thread_param->stack_size;
    904              }
    905          
    906           
    907              stacksize = (stacksize + TASK_STACK_ALIGN_SIZE - 1) / TASK_STACK_ALIGN_SIZE;
    908          	static TaskHandle_t xtask = NULL;
    909              BaseType_t ret = xTaskCreate((TaskFunction_t )(work_routine), name,stacksize,arg,hal_os_thread_param->priority,&xtask);
    910              if (NULL == ret) {
   \                     ??HAL_ThreadCreate_7: (+1)
   \       0x4C   0x....             LDR.N    R6,??DataTable16_24
   \       0x4E   0x9601             STR      R6,[SP, #+4]
   \       0x50   0xF9B3 0x3000      LDRSH    R3,[R3, #+0]
   \       0x54   0x9300             STR      R3,[SP, #+0]
   \       0x56   0x4613             MOV      R3,R2
   \       0x58   0x1CC0             ADDS     R0,R0,#+3
   \       0x5A   0x0880             LSRS     R0,R0,#+2
   \       0x5C   0x4602             MOV      R2,R0
   \       0x5E   0xB292             UXTH     R2,R2
   \       0x60   0x4628             MOV      R0,R5
   \       0x62   0x....'....        BL       xTaskCreate
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD102             BNE.N    ??HAL_ThreadCreate_8
    911                  return -1;
   \       0x6A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x6E   0xBD76             POP      {R1,R2,R4-R6,PC}
    912              }
    913              *thread_handle = (void *)xtask;
   \                     ??HAL_ThreadCreate_8: (+1)
   \       0x70   0x6830             LDR      R0,[R6, #+0]
   \       0x72   0x6020             STR      R0,[R4, #+0]
    914          
    915              return 0;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    916          }

   \                                 In section .bss, align 4
   \                     `HAL_ThreadCreate::xtask`:
   \        0x0                      DS8 4

   \                                 In section .text, align 2, keep-with-next
    917          void HAL_ThreadDelete(void *thread_handle)
    918          {
    919          	vTaskDelete((TaskHandle_t )thread_handle);
   \                     HAL_ThreadDelete: (+1)
   \        0x0   0x....'....        B.W      vTaskDelete
    920          }
    921          
    922          

   \                                 In section .text, align 2, keep-with-next
    923          void *HAL_Timer_Create(const char *name, void (*func)(void *), void *user_data)
    924          {
   \                     HAL_Timer_Create: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4613             MOV      R3,R2
    925          	TimerHandle_t thandle = xTimerCreate(name, 1000, pdFALSE, user_data, (TimerCallbackFunction_t)func);
    926          	
    927          	return (void *)thandle;
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0xF44F 0x717A      MOV      R1,#+1000
   \        0xC   0x....'....        BL       xTimerCreate
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
    928          }
    929          
    930          

   \                                 In section .text, align 2, keep-with-next
    931          int HAL_Timer_Delete(void *timer)
    932          {
   \                     HAL_Timer_Delete: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    933          	return (int )xTimerDelete((TimerHandle_t ) timer, 0);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0x460B             MOV      R3,R1
   \        0x8   0x460A             MOV      R2,R1
   \        0xA   0x2105             MOVS     R1,#+5
   \        0xC   0x....'....        BL       xTimerGenericCommand
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
    934          }
    935          
    936          

   \                                 In section .text, align 2, keep-with-next
    937          int HAL_Timer_Start(void *timer, int ms)
    938          {
   \                     HAL_Timer_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    939          	BaseType_t ret = xTimerStart((TimerHandle_t ) timer,pdMS_TO_TICKS(ms));
    940          	return (int )ret;
   \        0x6   0x....'....        BL       xTaskGetTickCount
   \        0xA   0x4602             MOV      R2,R0
   \        0xC   0xF44F 0x707A      MOV      R0,#+1000
   \       0x10   0x4345             MULS     R5,R0,R5
   \       0x12   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \       0x16   0x9000             STR      R0,[SP, #+0]
   \       0x18   0x2300             MOVS     R3,#+0
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       xTimerGenericCommand
   \       0x22   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    941          }
    942          
    943          

   \                                 In section .text, align 2, keep-with-next
    944          int HAL_Timer_Stop(void *timer)
    945          {
   \                     HAL_Timer_Stop: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    946          	BaseType_t ret = xTimerStop((TimerHandle_t ) timer, 0);
    947          	return (int )ret;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0x460B             MOV      R3,R1
   \        0x8   0x460A             MOV      R2,R1
   \        0xA   0x2103             MOVS     R1,#+3
   \        0xC   0x....'....        BL       xTimerGenericCommand
   \       0x10   0xBD02             POP      {R1,PC}          ;; return
    948          }
    949          
    950          
    951          
    952          /**
    953           * @brief Retrieves the number of milliseconds that have elapsed since the system was boot.
    954           *
    955           * @return the number of milliseconds.
    956           * @see None.
    957           * @note None.
    958           */

   \                                 In section .text, align 2, keep-with-next
    959          uint64_t HAL_UptimeMs(void)
    960          {
   \                     HAL_UptimeMs: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    961          	return (uint64_t)xTaskGetTickCount();
   \        0x2   0x....'....        BL       xTaskGetTickCount
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xBD04             POP      {R2,PC}          ;; return
    962          }
    963          /*
    964          void SysTick_Handler(void)
    965          {
    966              sys_tick_cnt++;
    967          	if(!sys_tick_cnt){
    968          		wrapped = 1;
    969          	}
    970          	if(sys_tick_cnt > 20){
    971          		wrapped = 0;
    972          
    973          	}
    974          }
    975          */
    976          

   \                                 In section .text, align 2, keep-with-next
    977          void HAL_timerInit(void ){
   \                     HAL_timerInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    978            SysTick_Config(CLOCK_GetFreq(kCLOCK_CoreSysClk) / 1000U);
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x....'....        BL       CLOCK_GetFreq
   \        0x8   0xF44F 0x717A      MOV      R1,#+1000
   \        0xC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x10   0xE8BD 0x4002      POP      {R1,LR}
   \       0x14   0x....             B.N      SysTick_Config
    979          }
    980          

   \                                 In section .text, align 2, keep-with-next
    981          int HAL_Vsnprintf(char *str, const int len, const char *format, va_list ap)
    982          {
    983          	return 1;
   \                     HAL_Vsnprintf: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
    984          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0xE000'E400        DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0xE000'ED18        DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0xE000'E014        DC32     0xe000e014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0xE000'E018        DC32     0xe000e018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0xE000'E010        DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x....'....        DC32     uart_rxstatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0x....'....        DC32     uart_status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x....'....        DC32     s_uartBaseAddrs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0x....'....        DC32     uart_rxwait_sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \        0x0   0x....'....        DC32     uart_txwait_sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \        0x0   0x....'....        DC32     check_st_sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \        0x0   0x....'....        DC32     seam_wait_rx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \        0x0   0x....'....        DC32     seam_wait_tx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \        0x0   0x....'....        DC32     lpuart_config

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \        0x0   0x....'....        DC32     t_handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \        0x0   0x....'....        DC32     handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_20:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_21:
   \        0x0   0x400C'C000        DC32     0x400cc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_22:
   \        0x0   0x....'....        DC32     srandom_inited

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_23:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_24:
   \        0x0   0x....'....        DC32     `HAL_ThreadCreate::xtask`

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x73 0x6D          DC8 "smart_wm_test1"
   \              0x61 0x72    
   \              0x74 0x5F    
   \              0x77 0x6D    
   \              0x5F 0x74    
   \              0x65 0x73    
   \              0x74 0x31    
   \              0x00         
   \        0xF   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x33 0x71          DC8 "3qLxqnrCCxhEVJUJjq88jEYkPwi2CZCr"
   \              0x4C 0x78    
   \              0x71 0x6E    
   \              0x72 0x43    
   \              0x43 0x78    
   \              0x68 0x45    
   \              0x56 0x4A    
   \              0x55 0x4A    
   \              0x6A 0x71    
   \              0x38 0x38    
   \              0x6A 0x45    
   \              0x59 0x6B    
   \              0x50 0x77    
   \              0x69 0x32    
   \              0x43 0x5A    
   \              0x43 0x72    
   \              0x00         
   \       0x21   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x31 0x2E          DC8 "1.1.1"
   \              0x31 0x2E    
   \              0x31 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x61 0x31          DC8 "a1I5Y6v8HwT"
   \              0x49 0x35    
   \              0x59 0x36    
   \              0x76 0x38    
   \              0x48 0x77    
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x53 0x35          DC8 "S56FG57Rqjr24CHo"
   \              0x36 0x46    
   \              0x47 0x35    
   \              0x37 0x52    
   \              0x71 0x6A    
   \              0x72 0x32    
   \              0x34 0x43    
   \              0x48 0x6F    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x77 0x72          DC8 "wrapper_"
   \              0x61 0x70    
   \              0x70 0x65    
   \              0x72 0x5F    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_AT_Uart_Deinit
         8   -> HAL_SemaphoreDestroy
         8   -> LPUART_Deinit
      16   HAL_AT_Uart_Init
        16   -> BOARD_DebugConsoleSrcFreq
        16   -> LPUART_RTOS_Init
        16   -> __NVIC_SetPriority
       8   HAL_AT_Uart_Recv
         8   -> LPUART_RTOS_Receive
       8   HAL_AT_Uart_Send
         8   -> LPUART_RTOS_Send
       0   HAL_Free
         0   -> vPortFree
       8   HAL_GetDeviceName
         8   -> __aeabi_memset
         0   -> strlen
         8   -> strncpy
       8   HAL_GetDeviceSecret
         8   -> __aeabi_memset
         8   -> strncpy
       8   HAL_GetFirmwareVersion
         8   -> __aeabi_memset
         0   -> strlen
         8   -> strncpy
       8   HAL_GetProductKey
         8   -> __aeabi_memset
         8   -> strncpy
       8   HAL_GetProductSecret
         8   -> __aeabi_memset
         8   -> strncpy
       0   HAL_Kv_Get
         0   -> kv_item_get
       0   HAL_Kv_Set
         0   -> kv_item_set
       0   HAL_Malloc
         0   -> pvPortMalloc
       8   HAL_MutexCreate
         8   -> xQueueCreateMutex
       0   HAL_MutexDestroy
         0   -> vQueueDelete
       8   HAL_MutexLock
         8   -> xQueueSemaphoreTake
       0   HAL_MutexUnlock
         0   -> xQueueGenericSend
      16   HAL_Random
        16   -> TRNG_GetRandomData
       8   HAL_SemaphoreCreate
         8   -> xQueueCreateCountingSemaphore
       0   HAL_SemaphoreDestroy
         0   -> vQueueDelete
       0   HAL_SemaphorePost
         0   -> xQueueGenericSend
       8   HAL_SemaphoreWait
         8   -> xQueueSemaphoreTake
       0   HAL_SleepMs
         0   -> vTaskDelay
       8   HAL_Snprintf
         8   -> vsnprintf
      88   HAL_Srandom
        88   -> TRNG_GetDefaultConfig
        88   -> TRNG_Init
      24   HAL_ThreadCreate
        24   -> xTaskCreate
       0   HAL_ThreadDelete
         0   -> vTaskDelete
       8   HAL_Timer_Create
         8   -> xTimerCreate
       8   HAL_Timer_Delete
         8   -> xTimerGenericCommand
      16   HAL_Timer_Start
        16   -> xTaskGetTickCount
        16   -> xTimerGenericCommand
       8   HAL_Timer_Stop
         8   -> xTimerGenericCommand
      16   HAL_Uart_rxWait
        16   -> xTaskGetTickCount
      16   HAL_Uart_txWait
        16   -> xTaskGetTickCount
       8   HAL_UptimeMs
         8   -> xTaskGetTickCount
       0   HAL_Vsnprintf
       8   HAL_timerInit
         8   -> CLOCK_GetFreq
         0   -> SysTick_Config
       8   SysTick_Config
         8   -> __NVIC_SetPriority
       0   __NVIC_SetPriority
       8   uart2_interrupt_handle_task
         8   -> HAL_SemaphoreWait
         8   -> xQueueGenericSend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      16  ?_0
      36  ?_1
       8  ?_2
      12  ?_3
      20  ?_4
      12  ?_5
      42  HAL_AT_Uart_Deinit
      44  HAL_AT_Uart_Init
      20  HAL_AT_Uart_Recv
      24  HAL_AT_Uart_Send
       4  HAL_Free
      32  HAL_GetDeviceName
      26  HAL_GetDeviceSecret
      36  HAL_GetFirmwareVersion
      26  HAL_GetProductKey
      26  HAL_GetProductSecret
       4  HAL_Kv_Get
       4  HAL_Kv_Set
       4  HAL_Malloc
      16  HAL_MutexCreate
      10  HAL_MutexDestroy
      32  HAL_MutexLock
      16  HAL_MutexUnlock
      36  HAL_Random
      18  HAL_SemaphoreCreate
      10  HAL_SemaphoreDestroy
      16  HAL_SemaphorePost
      30  HAL_SemaphoreWait
       4  HAL_SleepMs
      14  HAL_Snprintf
      38  HAL_Srandom
     120  HAL_ThreadCreate
       4  HAL_ThreadDelete
      18  HAL_Timer_Create
      18  HAL_Timer_Delete
      36  HAL_Timer_Start
      18  HAL_Timer_Stop
      44  HAL_Uart_rxWait
      44  HAL_Uart_txWait
      10  HAL_UptimeMs
       4  HAL_Vsnprintf
      22  HAL_timerInit
      52  SysTick_Config
      32  __NVIC_SetPriority
     512  background_buffer
       4  check_st_sem
      40  handle
       4  isr_uart_handle
      24  lpuart_config
      32  s_uartBaseAddrs
       1  seam_wait_rx
       1  seam_wait_tx
       1  srandom_inited
      48  t_handle
     102  uart2_interrupt_handle_task
       4  uart_rxstatus
       4  uart_rxwait_sem
       4  uart_status
       4  uart_txwait_sem
       4  xtask

 
   631 bytes in section .bss
    24 bytes in section .data
   136 bytes in section .rodata
 1 156 bytes in section .text
 
 1 156 bytes of CODE  memory
   136 bytes of CONST memory
   655 bytes of DATA  memory

Errors: none
Warnings: 4
