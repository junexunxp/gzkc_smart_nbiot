###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         26/Jun/2019  16:21:55
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  C:\Development\gzkc_smart_nbiot\component\kv\kv_adapt.c
#    Command line =  
#        -f C:\Users\nxf42695\AppData\Local\Temp\2\EW91AE.tmp
#        (C:\Development\gzkc_smart_nbiot\component\kv\kv_adapt.c -D DEBUG -D
#        USE_RTOS -D XIP_EXTERNAL_FLASH=1 -D XIP_BOOT_HEADER_ENABLE=1 -D
#        CPU_MIMXRT1052DVL6B -D FSL_RTOS_FREE_RTOS -D PRINTF_ADVANCED_ENABLE -D
#        "MBEDTLS_CONFIG_FILE=\"ksdk_mbedtls_config.h\"" -lC
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list -lA
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list --diag_suppress
#        Pa082,Pa050 -o C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" --preinclude
#        C:\Development\gzkc_smart_nbiot/source\app_preinclude.h -I
#        C:\Development\gzkc_smart_nbiot/board\ -I
#        C:\Development\gzkc_smart_nbiot/source\ -I
#        C:\Development\gzkc_smart_nbiot/CMSIS\ -I
#        C:\Development\gzkc_smart_nbiot/amazon-freertos/freertos/portable\ -I
#        C:\Development\gzkc_smart_nbiot/amazon-freertos/include\ -I
#        C:\Development\gzkc_smart_nbiot/component/lists\ -I
#        C:\Development\gzkc_smart_nbiot/component/serial_manager\ -I
#        C:\Development\gzkc_smart_nbiot/component/uart\ -I
#        C:\Development\gzkc_smart_nbiot/component/kv\ -I
#        C:\Development\gzkc_smart_nbiot/component/kv/include\ -I
#        C:\Development\gzkc_smart_nbiot/device\ -I
#        C:\Development\gzkc_smart_nbiot/doc\ -I
#        C:\Development\gzkc_smart_nbiot/drivers\ -I
#        C:\Development\gzkc_smart_nbiot/src\ -I
#        C:\Development\gzkc_smart_nbiot/startup\ -I
#        C:\Development\gzkc_smart_nbiot/utilities\ -I
#        C:\Development\gzkc_smart_nbiot/xip\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\atm\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_model\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_sign\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\infra\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\mqtt\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\wrappers\external_libs\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_cloud\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\CoAPPacket\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\coap_server\server\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\os\ -I
#        C:\Development\gzkc_smart_nbiot\csdk\eng\dev_bind\impl\awss_reset\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\include\mbedtls\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\include\ -I
#        C:\Development\gzkc_smart_nbiot\mbedtls\port\ksdk\ -Om)
#    Locale       =  C
#    List file    =  
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\list\kv_adapt.lst
#    Object file  =  
#        C:\Development\gzkc_smart_nbiot\flexspi_nor_debug\obj\kv_adapt.o
#
###############################################################################

C:\Development\gzkc_smart_nbiot\component\kv\kv_adapt.c
      1          /*
      2           * Copyright (C) 2015-2017 Alibaba Group Holding Limited
      3           */
      4          
      5          #include "kv_api.h"
      6          
      7          #include "kv_conf.h"
      8          #include "kv_adapt.h"
      9               
     10          #include "flexspi_hyper_flash_ops.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t DisableGlobalIRQ(void)
   \                     DisableGlobalIRQ: (+1)
   \        0x0   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0x4   0xB672             CPSID    I
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EnableGlobalIRQ(uint32_t)
   \                     EnableGlobalIRQ: (+1)
   \        0x0   0xF380 0x8810      MSR      PRIMASK,R0
   \        0x4   0x4770             BX       LR               ;; return
     11          #include "fsl_cache.h"
     12          
     13          #include "FreeRTOS.h"
     14          #include "task.h"
     15          #include "wrappers_defs.h"
     16          
     17          #include "fsl_debug_console.h"
     18               
     19          #define KV_FLASH_BASE               (0x03C00000)    // 60MB - 64MB
     20          #define KV_FLASH_SECTOR_SIZE        (1 << KV_CONFIG_BLOCK_SIZE_BITS)
     21          #define FLASH_PAGE_SIZE_BYTES       512
     22          
     23          void *HAL_MutexCreate(void);
     24          void  HAL_MutexDestroy(void *mutex);
     25          void  HAL_MutexLock(void *mutex);
     26          void  HAL_MutexUnlock(void *mutex);
     27          void *HAL_SemaphoreCreate(void);
     28          void  HAL_SemaphoreDestroy(void *sem);
     29          void  HAL_SemaphorePost(void *sem);
     30          int   HAL_SemaphoreWait(void *sem, uint32_t timeout_ms);
     31          void *HAL_Malloc(uint32_t size);
     32          void  HAL_Free(void *ptr);
     33          

   \                                 In section .bss, align 4
     34          static TaskHandle_t kv_task_handle;
   \                     kv_task_handle:
   \        0x0                      DS8 4
     35          

   \                                 In section .text, align 2, keep-with-next
     36          int32_t kv_flash_read(uint32_t offset, void *buf, uint32_t nbytes)
     37          {
   \                     kv_flash_read: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x460B             MOV      R3,R1
     38              uint32_t cpu_addr;
     39              
     40             // PRINTF("R - kv_flash_read, offset = %d, nbytes = %d\r\n", offset, nbytes);
     41              
     42              cpu_addr = FlexSPI_AMBA_BASE + KV_FLASH_BASE + offset;
     43              memcpy(buf, (void *)cpu_addr, nbytes);
   \        0x4   0x....             LDR.N    R1,??DataTable5  ;; 0x63c00000
   \        0x6   0x1808             ADDS     R0,R1,R0
   \        0x8   0x4601             MOV      R1,R0
   \        0xA   0x4618             MOV      R0,R3
   \        0xC   0x....'....        BL       __aeabi_memcpy
     44              
     45              return 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
     46          }
     47          

   \                                 In section .text, align 2, keep-with-next
     48          int32_t kv_flash_write(uint32_t offset, void *buf, uint32_t nbytes)
     49          {
   \                     kv_flash_write: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x4691             MOV      R9,R2
     50              /* Must be 4-byte aligned. */
     51              SDK_ALIGN(static uint8_t intBuffer[FLASH_PAGE_SIZE_BYTES], 4);
     52          
     53              status_t status;
     54              uint32_t phy_address;
     55              uint32_t page_offset;
     56              uint32_t phyAddrAlign;
     57              uint32_t memcpylen;
     58              uint32_t sizeLeft = nbytes;
   \        0x8   0x46C8             MOV      R8,R9
     59              const uint8_t *buffer = (const uint8_t *)buf;
   \        0xA   0x460F             MOV      R7,R1
     60              
     61             // PRINTF("P - kv_flash_write, offset = %d, nbytes = %d, [0]=%d, [1]=%d, [2]=%d, [3]=%d\r\n", offset, nbytes, buffer[0], buffer[1], buffer[2], buffer[3]);
     62              
     63              uint32_t old_primask = DisableGlobalIRQ();
   \        0xC   0x....'....        BL       DisableGlobalIRQ
   \       0x10   0x4606             MOV      R6,R0
     64              //taskENTERCRITICAL();
     65              phy_address = KV_FLASH_BASE + offset;
   \       0x12   0xF105 0x7570      ADD      R5,R5,#+62914560
     66              
     67             /* Check if the startaddress is the page size aligned */
     68              if ((phy_address % FLASH_PAGE_SIZE_BYTES) != 0)
   \       0x16   0x05E8             LSLS     R0,R5,#+23
   \       0x18   0xD02C             BEQ.N    ??kv_flash_write_0
     69              {
     70                  page_offset = phy_address % FLASH_PAGE_SIZE_BYTES;
   \       0x1A   0xF3C5 0x0408      UBFX     R4,R5,#+0,#+9
     71                  phyAddrAlign = (phy_address / FLASH_PAGE_SIZE_BYTES) * FLASH_PAGE_SIZE_BYTES;
   \       0x1E   0x0A6D             LSRS     R5,R5,#+9
   \       0x20   0x026D             LSLS     R5,R5,#+9
     72                  memcpylen = nbytes;
     73          
     74                  /* Check if the area across pages. */
     75                  if (page_offset + nbytes > FLASH_PAGE_SIZE_BYTES)
   \       0x22   0xEB09 0x0004      ADD      R0,R9,R4
   \       0x26   0xF240 0x2101      MOVW     R1,#+513
   \       0x2A   0x4288             CMP      R0,R1
   \       0x2C   0xD301             BCC.N    ??kv_flash_write_1
     76                  {
     77                      memcpylen = FLASH_PAGE_SIZE_BYTES - page_offset;
   \       0x2E   0xF5C4 0x7900      RSB      R9,R4,#+512
     78                  }
     79          
     80                  /* Need to read the page first*/
     81                  memcpy(intBuffer, (void*)(phyAddrAlign + FlexSPI_AMBA_BASE), FLASH_PAGE_SIZE_BYTES);
   \                     ??kv_flash_write_1: (+1)
   \       0x32   0x....'....        LDR.W    R10,??DataTable5_1
   \       0x36   0xF44F 0x7200      MOV      R2,#+512
   \       0x3A   0xF105 0x41C0      ADD      R1,R5,#+1610612736
   \       0x3E   0x4650             MOV      R0,R10
   \       0x40   0x....'....        BL       __aeabi_memcpy
     82          
     83                  /* Change the data required to be changed. */
     84                  memcpy((void*)(((uint32_t)intBuffer) + page_offset), buffer, memcpylen);
   \       0x44   0x464A             MOV      R2,R9
   \       0x46   0x4639             MOV      R1,R7
   \       0x48   0x4454             ADD      R4,R4,R10
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x....'....        BL       __aeabi_memcpy
     85                  
     86                  status = flexspi_nor_flash_page_program(FLEXSPI, phyAddrAlign, (uint32_t const *)intBuffer);
   \       0x50   0x4652             MOV      R2,R10
   \       0x52   0x4629             MOV      R1,R5
   \       0x54   0x....             LDR.N    R0,??DataTable5_2  ;; 0x402a8000
   \       0x56   0x....'....        BL       flexspi_nor_flash_page_program
   \       0x5A   0x0004             MOVS     R4,R0
     87                  if (status != kStatus_Success)
   \       0x5C   0xD159             BNE.N    ??kv_flash_write_2
     88                  {
     89                      EnableGlobalIRQ(old_primask);
     90                      //taskEXITCRITICAL();
     91                      return status;
     92                  }
     93                  
     94                  DCACHE_InvalidateByRange(FlexSPI_AMBA_BASE + phyAddrAlign, FLASH_PAGE_SIZE_BYTES);
   \       0x5E   0xF44F 0x7100      MOV      R1,#+512
   \       0x62   0xF105 0x40C0      ADD      R0,R5,#+1610612736
   \       0x66   0x....'....        BL       DCACHE_InvalidateByRange
     95          
     96                  /* Update the address and size */
     97                  phy_address = phyAddrAlign + FLASH_PAGE_SIZE_BYTES;
   \       0x6A   0xF505 0x7500      ADD      R5,R5,#+512
     98                  sizeLeft -= memcpylen;
   \       0x6E   0xEBA8 0x0809      SUB      R8,R8,R9
     99                  buffer += memcpylen;
   \       0x72   0x444F             ADD      R7,R7,R9
   \                     ??kv_flash_write_0: (+1)
   \       0x74   0x4644             MOV      R4,R8
   \       0x76   0x....'....        LDR.W    R8,??DataTable5_1
    100              }
    101              
    102              /* Now the startAddr is page size aligned. */
    103              while (sizeLeft >= FLASH_PAGE_SIZE_BYTES)
   \                     ??kv_flash_write_3: (+1)
   \       0x7A   0xF5B4 0x7F00      CMP      R4,#+512
   \       0x7E   0xD331             BCC.N    ??kv_flash_write_4
    104              {
    105                  /* Make sure 4 byte align. */
    106                  if (0 != ((uint32_t)buffer & 0x03))
   \       0x80   0xF017 0x0003      ANDS     R0,R7,#0x3
   \       0x84   0xD105             BNE.N    ??kv_flash_write_5
    107                  {
    108                      memcpy(intBuffer, buffer, FLASH_PAGE_SIZE_BYTES);
    109                      
    110                      status = flexspi_nor_flash_page_program(FLEXSPI, phy_address, (uint32_t const *)intBuffer);
    111                  }
    112                  else
    113                  {
    114                      status = flexspi_nor_flash_page_program(FLEXSPI, phy_address, (uint32_t const *)buffer);
   \       0x86   0x463A             MOV      R2,R7
   \       0x88   0x4629             MOV      R1,R5
   \       0x8A   0x....             LDR.N    R0,??DataTable5_2  ;; 0x402a8000
   \       0x8C   0x....'....        BL       flexspi_nor_flash_page_program
   \       0x90   0xE00A             B.N      ??kv_flash_write_6
    115                  }
   \                     ??kv_flash_write_5: (+1)
   \       0x92   0xF44F 0x7200      MOV      R2,#+512
   \       0x96   0x4639             MOV      R1,R7
   \       0x98   0x4640             MOV      R0,R8
   \       0x9A   0x....'....        BL       __aeabi_memcpy
   \       0x9E   0x4642             MOV      R2,R8
   \       0xA0   0x4629             MOV      R1,R5
   \       0xA2   0x....             LDR.N    R0,??DataTable5_2  ;; 0x402a8000
   \       0xA4   0x....'....        BL       flexspi_nor_flash_page_program
    116          
    117                  if (status != kStatus_Success)
   \                     ??kv_flash_write_6: (+1)
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD119             BNE.N    ??kv_flash_write_7
    118                  {
    119                      EnableGlobalIRQ(old_primask);
    120                      //taskEXITCRITICAL();
    121                      return status;
    122                  }
    123                  
    124                  DCACHE_InvalidateByRange(FlexSPI_AMBA_BASE + phy_address, FLASH_PAGE_SIZE_BYTES);
   \       0xAC   0xF44F 0x7100      MOV      R1,#+512
   \       0xB0   0xF105 0x40C0      ADD      R0,R5,#+1610612736
   \       0xB4   0x....'....        BL       DCACHE_InvalidateByRange
    125          
    126                  phy_address += FLASH_PAGE_SIZE_BYTES;
   \       0xB8   0xF505 0x7500      ADD      R5,R5,#+512
    127                  sizeLeft -= FLASH_PAGE_SIZE_BYTES;
   \       0xBC   0xF5A4 0x7400      SUB      R4,R4,#+512
    128                  buffer += FLASH_PAGE_SIZE_BYTES;
   \       0xC0   0xF507 0x7700      ADD      R7,R7,#+512
   \       0xC4   0xE7D9             B.N      ??kv_flash_write_3
    129              }
    130              
    131              if (sizeLeft)
    132              {
    133                  memcpy(intBuffer, buffer, sizeLeft);
    134                  memcpy(intBuffer + sizeLeft, (void*)(phy_address + FlexSPI_AMBA_BASE + sizeLeft), FLASH_PAGE_SIZE_BYTES - sizeLeft);
    135          
    136                  status = flexspi_nor_flash_page_program(FLEXSPI, phy_address, (uint32_t const *)intBuffer);
    137                  if (status != kStatus_Success)
    138                  {
    139                      EnableGlobalIRQ(old_primask);
    140                      //taskEXITCRITICAL();
    141                      return status;
    142                  }
    143                  
    144                  DCACHE_InvalidateByRange(FlexSPI_AMBA_BASE + phy_address, FLASH_PAGE_SIZE_BYTES);
   \                     ??kv_flash_write_8: (+1)
   \       0xC6   0xF44F 0x7100      MOV      R1,#+512
   \       0xCA   0xF105 0x45C0      ADD      R5,R5,#+1610612736
   \       0xCE   0x4628             MOV      R0,R5
   \       0xD0   0x....'....        BL       DCACHE_InvalidateByRange
    145              }
    146              EnableGlobalIRQ(old_primask);
   \                     ??kv_flash_write_9: (+1)
   \       0xD4   0x4630             MOV      R0,R6
   \       0xD6   0x....'....        BL       EnableGlobalIRQ
    147              return 0;
   \       0xDA   0x2000             MOVS     R0,#+0
   \                     ??kv_flash_write_10: (+1)
   \       0xDC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??kv_flash_write_7: (+1)
   \       0xE0   0x4604             MOV      R4,R0
   \       0xE2   0xE016             B.N      ??kv_flash_write_2
   \                     ??kv_flash_write_4: (+1)
   \       0xE4   0x2C00             CMP      R4,#+0
   \       0xE6   0xD0F5             BEQ.N    ??kv_flash_write_9
   \       0xE8   0x4622             MOV      R2,R4
   \       0xEA   0x4639             MOV      R1,R7
   \       0xEC   0x4640             MOV      R0,R8
   \       0xEE   0x....'....        BL       __aeabi_memcpy
   \       0xF2   0xF5C4 0x7200      RSB      R2,R4,#+512
   \       0xF6   0x1961             ADDS     R1,R4,R5
   \       0xF8   0xF101 0x41C0      ADD      R1,R1,#+1610612736
   \       0xFC   0xEB08 0x0004      ADD      R0,R8,R4
   \      0x100   0x....'....        BL       __aeabi_memcpy
   \      0x104   0x4642             MOV      R2,R8
   \      0x106   0x4629             MOV      R1,R5
   \      0x108   0x....             LDR.N    R0,??DataTable5_2  ;; 0x402a8000
   \      0x10A   0x....'....        BL       flexspi_nor_flash_page_program
   \      0x10E   0x0004             MOVS     R4,R0
   \      0x110   0xD0D9             BEQ.N    ??kv_flash_write_8
   \                     ??kv_flash_write_2: (+1)
   \      0x112   0x4630             MOV      R0,R6
   \      0x114   0x....'....        BL       EnableGlobalIRQ
   \      0x118   0x4620             MOV      R0,R4
   \      0x11A   0xE7DF             B.N      ??kv_flash_write_10
    148          }

   \                                 In section .bss, align 4
   \                     `kv_flash_write::intBuffer`:
   \        0x0                      DS8 512
    149          

   \                                 In section .text, align 2, keep-with-next
    150          int32_t kv_flash_erase(uint32_t offset, uint32_t size)
    151          {
   \                     kv_flash_erase: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460A             MOV      R2,R1
    152              /* 
    153                  offset always start at the boundary of sector
    154                  size is always 256KB
    155              */
    156              PRINTF("E - kv_flash_erase, offset = %d, size = %d\r\n", offset, size);
   \        0x6   0x4621             MOV      R1,R4
   \        0x8   0x....             LDR.N    R0,??DataTable5_3
   \        0xA   0x....'....        BL       DbgConsole_Printf
    157              
    158              uint32_t old_primask = DisableGlobalIRQ();
   \        0xE   0x....'....        BL       DisableGlobalIRQ
   \       0x12   0x4605             MOV      R5,R0
    159              //taskENTERCRITICAL();
    160              if (flexspi_nor_flash_erase_sector(FLEXSPI, KV_FLASH_BASE + offset) != kStatus_Success) {
   \       0x14   0xF104 0x7170      ADD      R1,R4,#+62914560
   \       0x18   0x....             LDR.N    R0,??DataTable5_2  ;; 0x402a8000
   \       0x1A   0x....'....        BL       flexspi_nor_flash_erase_sector
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0xD004             BEQ.N    ??kv_flash_erase_0
    161                  
    162                  EnableGlobalIRQ(old_primask);
   \       0x24   0x....'....        BL       EnableGlobalIRQ
    163                  //taskEXITCRITICAL();
    164                  return -1;
   \       0x28   0xF04F 0x30FF      MOV      R0,#-1
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
    165              }
    166              //taskEXITCRITICAL();
    167              EnableGlobalIRQ(old_primask);
   \                     ??kv_flash_erase_0: (+1)
   \       0x2E   0x....'....        BL       EnableGlobalIRQ
    168              DCACHE_InvalidateByRange(FlexSPI_AMBA_BASE + KV_FLASH_BASE + offset, KV_FLASH_SECTOR_SIZE);
   \       0x32   0xF44F 0x2180      MOV      R1,#+262144
   \       0x36   0x....             LDR.N    R0,??DataTable5  ;; 0x63c00000
   \       0x38   0x1904             ADDS     R4,R0,R4
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x....'....        BL       DCACHE_InvalidateByRange
    169              return 0;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    170          }
    171          

   \                                 In section .text, align 2, keep-with-next
    172          void *kv_lock_create(void)
    173          {
    174              return HAL_MutexCreate();
   \                     kv_lock_create: (+1)
   \        0x0   0x....'....        B.W      HAL_MutexCreate
    175          }
    176          

   \                                 In section .text, align 2, keep-with-next
    177          int32_t kv_lock_free(void *lock)
    178          {
   \                     kv_lock_free: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    179              HAL_MutexDestroy(lock);
   \        0x2   0x....'....        BL       HAL_MutexDestroy
    180              return 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
    181          }
    182          

   \                                 In section .text, align 2, keep-with-next
    183          int32_t kv_lock(void *lock)
    184          {
   \                     kv_lock: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    185              HAL_MutexLock(lock);
   \        0x2   0x....'....        BL       HAL_MutexLock
    186              return 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
    187          }
    188          

   \                                 In section .text, align 2, keep-with-next
    189          int32_t kv_unlock(void *lock)
    190          {
   \                     kv_unlock: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    191              HAL_MutexUnlock(lock);
   \        0x2   0x....'....        BL       HAL_MutexUnlock
    192              return 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
    193          }
    194          

   \                                 In section .text, align 2, keep-with-next
    195          void *kv_sem_create(void)
    196          {
    197              return HAL_SemaphoreCreate();
   \                     kv_sem_create: (+1)
   \        0x0   0x....'....        B.W      HAL_SemaphoreCreate
    198          }
    199          

   \                                 In section .text, align 2, keep-with-next
    200          int32_t kv_sem_free(void *sem)
    201          {
   \                     kv_sem_free: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    202              HAL_SemaphoreDestroy(sem);
   \        0x2   0x....'....        BL       HAL_SemaphoreDestroy
    203              return 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
    204          }
    205          

   \                                 In section .text, align 2, keep-with-next
    206          int32_t kv_sem_wait(void *sem)
    207          {
    208              return HAL_SemaphoreWait(sem, portMAX_DELAY);
   \                     kv_sem_wait: (+1)
   \        0x0   0xF04F 0x31FF      MOV      R1,#-1
   \        0x4   0x....'....        B.W      HAL_SemaphoreWait
    209          }
    210          

   \                                 In section .text, align 2, keep-with-next
    211          int32_t kv_sem_post_all(void *sem)
    212          {
   \                     kv_sem_post_all: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    213              HAL_SemaphorePost(sem);
   \        0x2   0x....'....        BL       HAL_SemaphorePost
    214              return 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
    215          }
    216          

   \                                 In section .text, align 2, keep-with-next
    217          int32_t kv_start_task(const char *name, void (*fn)(void *), void *arg,
    218                                uint32_t stack)
    219          {
   \                     kv_start_task: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4619             MOV      R1,R3
    220          	(void)xTaskCreate((TaskFunction_t)fn,
    221                                name,
    222                                stack,
    223                                arg,
    224                                4,
    225                                &kv_task_handle);
   \        0x6   0x....             LDR.N    R3,??DataTable5_4
   \        0x8   0x9301             STR      R3,[SP, #+4]
   \        0xA   0x2304             MOVS     R3,#+4
   \        0xC   0x9300             STR      R3,[SP, #+0]
   \        0xE   0x4613             MOV      R3,R2
   \       0x10   0x460A             MOV      R2,R1
   \       0x12   0xB292             UXTH     R2,R2
   \       0x14   0x4601             MOV      R1,R0
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x....'....        BL       xTaskCreate
    226              return 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    227          }
    228          

   \                                 In section .text, align 2, keep-with-next
    229          void kv_delete_task(void)
    230          {
    231              vTaskDelete(kv_task_handle);
   \                     kv_delete_task: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable5_4
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      vTaskDelete
    232          }
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void *kv_malloc(uint32_t size)
    235          {
    236              return HAL_Malloc(size);
   \                     kv_malloc: (+1)
   \        0x0   0x....'....        B.W      HAL_Malloc
    237          }
    238          

   \                                 In section .text, align 2, keep-with-next
    239          void kv_free(void *ptr)
    240          {
    241              HAL_Free(ptr);
   \                     kv_free: (+1)
   \        0x0   0x....'....        B.W      HAL_Free
    242          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x63C0'0000        DC32     0x63c00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     `kv_flash_write::intBuffer`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x402A'8000        DC32     0x402a8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x....'....        DC32     kv_task_handle

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x45 0x20          DC8 "E - kv_flash_erase, offset = %d, size = %d\015\012"
   \              0x2D 0x20    
   \              0x6B 0x76    
   \              0x5F 0x66    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x5F 0x65    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x2C 0x20    
   \              0x6F 0x66    
   \              0x66 0x73    
   \              0x65 0x74    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x64 0x2C    
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \       0x2D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DisableGlobalIRQ
       0   EnableGlobalIRQ
       0   kv_delete_task
         0   -> vTaskDelete
      16   kv_flash_erase
        16   -> DCACHE_InvalidateByRange
        16   -> DbgConsole_Printf
        16   -> DisableGlobalIRQ
        16   -> EnableGlobalIRQ
        16   -> flexspi_nor_flash_erase_sector
       8   kv_flash_read
         8   -> __aeabi_memcpy
      32   kv_flash_write
        32   -> DCACHE_InvalidateByRange
        32   -> DisableGlobalIRQ
        32   -> EnableGlobalIRQ
        32   -> __aeabi_memcpy
        32   -> flexspi_nor_flash_page_program
       0   kv_free
         0   -> HAL_Free
       8   kv_lock
         8   -> HAL_MutexLock
       0   kv_lock_create
         0   -> HAL_MutexCreate
       8   kv_lock_free
         8   -> HAL_MutexDestroy
       0   kv_malloc
         0   -> HAL_Malloc
       0   kv_sem_create
         0   -> HAL_SemaphoreCreate
       8   kv_sem_free
         8   -> HAL_SemaphoreDestroy
       8   kv_sem_post_all
         8   -> HAL_SemaphorePost
       0   kv_sem_wait
         0   -> HAL_SemaphoreWait
      16   kv_start_task
        16   -> xTaskCreate
       8   kv_unlock
         8   -> HAL_MutexUnlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
      48  ?_0
       8  DisableGlobalIRQ
       6  EnableGlobalIRQ
     512  intBuffer
       8  kv_delete_task
      68  kv_flash_erase
      20  kv_flash_read
     284  kv_flash_write
       4  kv_free
      10  kv_lock
       4  kv_lock_create
      10  kv_lock_free
       4  kv_malloc
       4  kv_sem_create
      10  kv_sem_free
      10  kv_sem_post_all
       8  kv_sem_wait
      32  kv_start_task
       4  kv_task_handle
      10  kv_unlock

 
 516 bytes in section .bss
  48 bytes in section .rodata
 520 bytes in section .text
 
 520 bytes of CODE  memory
  48 bytes of CONST memory
 516 bytes of DATA  memory

Errors: none
Warnings: none
